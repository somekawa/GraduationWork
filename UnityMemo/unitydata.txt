最初のブレークポイントが置けるようになるまで

①VisualStudioInstollerでUnityのツールが
　入っているか確認する

②Edit>Preferences>Generalの、
　Code Optimization On SetUpの項目が
　Debugになっているか確認する

③Edit>Preferences>External Toolsの、
　External Script EditorにVisualStudioのやつが
　設定されているか確認する

④VisualStudio側で、
　デバッグ>Unityデバッガーのアタッチを押して、
　出てくるかを確認して押下する

この4つでだいたいおわるはず

------------------------------------------------
<Animationの切替>
[Wait->Run]
isRunのフラグがtrueのとき、とする
[Run->Wait]
isRunのフラグがfalseのとき、とする

<お目目をぱちくりさせる方法>
Unityちゃんに、AutoBlinkforSD.csをアタッチする
引数の、Ref_faceという場所には「_face」を入れる

アニメーションで参考にしたサイト↓---------------

FaceUpdate.csの、「Invalid Layer Index」の警告についての対処法
https://thinkit.co.jp/story/2014/11/06/5372?page=0%2C1

コライダーの大きさと、キャラクターコントローラーを使った移動制御について
https://goodlucknetlife.com/unity-how-to-charactorcontroller/

特に、アニメーションの切替方法について
https://www.eda-inc.jp/unitychan/

------------------------------------------------

<五芒星のイラスト>
https://www.ac-illust.com/main/detail.php?id=1890670&word=%E4%BA%94%E8%8A%92%E6%98%9F%E9%AD%94%E6%B3%95%E9%99%A3#
※イラストACから拝借


<キャラの方向転換について>
参照したもの↓
https://www.hanachiru-blog.com/entry/2019/02/20/183552

transform.rotation = Quaternion.LookRotation(movedir);
と書くことで、ボタン押下時にmovedirに値が入るから
移動させたい方向というのが決められる

<他のモーションアセットを、unityちゃんにつける>
参照したもの↓
https://unity-shoshinsha.biz/archives/987

https://obenkyolab.com/?p=2112

AnimaterにしっかりStateを追加して設定すれば
動いてくれました。
※Has Exit Timeにチェックを付ける/付けないは
ちゃんと考えたほうがいい
(例)Wait->Attackについては、
Waitのアニメーションが終わってからAttackに移動するとボタン押下時に即座に反応してくれないと困るから、チェックは外して合ったほうがいい
逆に、Attack->Waitは、
Attackのアニメーションが最後まで再生されてから
Waitに戻ってほしいので、チェックがついていたほうがいい

<Unityちゃんに武器をもたせる>-------------------
参照したもの↓
https://unity-shoshinsha.biz/archives/987

武器アセットをいれて、上記のサイト通りに右手の子供として設定。そのあとにCharacter1_RightHandのTransform値を武器にコピペしたらいけそう
後はちょっとした座標調整と、サイズの変更

武器の    X      Y     Z
Position 0.06  -0.2   0.04
Rotation -10    0     180
Scale    0.5    0.5   0.5

-----------------------------------------------

<武器を振るモーションの後>----------------------
少しずつ座標がずれているから、ずれないようにしないといけない

参照したもの↓
https://indie-du.com/entry/2016/05/14/095612

UnityちゃんについてるAnimatorのApplyRootMotionのチェックをはずしたら座標がずれなくなった

ただそうすると、床をすり抜けて落下していくようになった。UnityちゃんにつけてるRigidBodyのUseGravityのチェックをはずしたら落下はしなくなったけど、根本的な解決にはなってなさそう。。。

<CharactorControllを使わないでキャラ操作>
参照したもの↓
https://gametukurikata.com/program/rigidbodyandcollider

CharactorControllをRemoveして、
RigidBodyとCapsuleColliderをつける。
値は上記のサイトをマネする。

一部違う所だけ抜粋↓
CapsuleColliderのCenterは、
(X)0,(Y)0.5,(Z)0にする
Radiusは0.5で、Heightは1にする

以上で、UseGravityを入れてもすり抜けないし、
コライダー同士で接触しておかしくなることもない。

-----------------------------------------------

<Apply Root Motionについての追加知識>-----------
参照したもの↓
https://light11.hatenadiary.com/entry/2019/04/18/003100

特定のMotionのみチェックを外した状態にする。
ということも可能らしい。

------------------------------------------------

<MainCameraをUnityちゃんに追従させる>-----------
参照したもの↓
https://xr-hub.com/archives/7057
なぜか、MainCameraをunityちゃんの子オブジェクトに
する方法は全部失敗した。
CameraSample.csの方法でやった
-----------------------------------------------

<MainCameraとButtleCameraを切り替える>----------
参照したもの↓
https://xr-hub.com/archives/6038
この記事の中では、MainとSubで切替の説明をしている

MainCameraの文字のMainとCameraの間に空白があるのを消したほうがバグを生まないですむ。

CameraControllerという空のオブジェクトを用意しておいて、そこに新規Scriptで[CameraMng]をつくって
アタッチするようにしたらいい。
[CameraMng]の内容は上記のURLに記載されている。

制作するゲームはランダムな値でエンカウントして、
エンカウントしたらカメラを切り替わるようにしたい
------------------------------------------------

<MainCameraにはUnityちゃんの武器を映さない>------
まず、新規で[Weapon]というLayerを追加する。
次にUnityちゃんの右手の子供にした[Staff]のLayerに
[Weapon]を設定する。

MainCameraのインスペクター内にCameraがあって
そこにCullingMaskがある。
最初の設定では[Everything]になって全てのレイヤーを映すようにしているが、ここから[Weapon]を除外。
その結果、MainCamera上には映らなくなる。

ButtleCameraは[Everything]のままなので武器も映る

※ついでに書いとくと、unityちゃんは、武器以外
　[Player]というLayerを新規で用意して付けている
------------------------------------------------

<Unityちゃんの通常モードと戦闘モードを分ける>----
新規でButtleUnitychanControllerを作成し、
ButtleCameraがONのときのみUpdate処理を続行し、
SPACEキーを押下すると杖を振るモーションを行う。

ButtleUnitychanControllerはUnityちゃんにアタッチした。

ついでに、バトルカメラもunityちゃんに追従するようにButtleCameraにもCameraSample.csをアタッチした

他キャラと一緒に戦う仕組みならunityちゃん専用の攻撃Scriptではなく、ちゃんと親をつくって、
ポリモーフィズムにしたほうがいい。
汎用性を高めること！

(例)攻撃ボタンを押す(親クラス)→敵選択(親クラス)→攻撃モーションとダメージ計算をする(子クラス)

いまのうちからキャラを複製して検証したほうがいい
------------------------------------------------

<ButtleMngで全てのキャラのアクションを操作する>--
キャラ1体1体にButtleUnitychanControllerをつけるのは馬鹿だな。と思ったので、修正。

ヒエラルキーに空のオブジェクトをつくって、
ButtleMngと命名。同じくScriptを新規作成して、
そちらにもButtleMng.csと命名。新規Scriptを空のオブジェクトにアタッチする。

使用するにあたって、CharListにキャラオブジェクトを登録する必要がある。Script内にキャラ名のenumが
あるため、それと同じ順番でキャラオブジェクトをアタッチしないといけない。

それを利用してcharMap_を作成。
charMapは、キーをenum,値をキャラオブジェクトにしている。
foreachで回して、構造体に登録していく方針にした。

構造体を使うことで、キャラ1体1体の情報を差別化できる。

攻撃モーションの途中で、次のキャラの操作に移行してしまい。モーションが途切れるバグがあったため、

構造体にisMoveとanimTimeを追加して、モーションに
間をつくるようにした。
ただし、Scriptにも記載しているが、キャラによってモーションの間を調整する必要があるかもしれない。
その場合は、maxAnimTime等を外部データからもってこれるようにしたほうが効果的だと思う。

以上の実装方法により、キャラクター毎にコントローラースクリプトを用意する必要がなくなった。

------------------------------------------------



これより下は、0831パッケージに入っていない所。

<バトルUIの回転するUIの作り方>------------------
参照したもの↓
https://scrapbox.io/remi-tech/Unity%E3%81%A7%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%9F%E8%A7%92%E5%BA%A6%E3%81%BE%E3%81%A7%E5%9B%9E%E3%81%97%E3%81%A6%E6%AD%A2%E3%82%81%E3%82%8B%E6%96%B9%E6%B3%95

まず、ButtleCanvasをヒエラルキーに作成して、
中にImageを追加する。UIにしたい画像のTexture Type
をSprite(2D and UI)にしてから、Imageにアタッチ

Imageには新規ScriptでImageRotate.csを作成して、
アタッチする。
このスクリプト内で回転処理を行っていく。

回転処理については上記の参照サイトと全く同じ。

①キー入力によって回転させたい角度を決める
②①をクォータニオンに直す
③画像の現在のクォータニオンを調べる
④Quaternion.Angleという関数を使い、②と③の角度
　の差を求める
⑤④の差が一定値以下なら回転終了し、
　規定値を満たしていなかったら回転を続行する。

まだActiveの切替とかしてないからバトル中以外でも
出てきちゃうけど、明日からまた修正頑張ろう。

FieldMngをつくって、戦闘と通常を切り替えられるようにします。
CameraMngでAキー操作でカメラ切替にしているところ
から修正。
enumつくって参照できるようにしてあげる。

毎回戦闘モードの最初が同じコマンドを上に出すようにしないといけないから、ImageRotateにResetRotateという関数を追加。呼び出し先は、ButtleMngです。
関数の中で、0,0,0の初期値に戻るようにした。
また、そのさいにはちゃんとtargetRotate_も0.0fに
初期化しないと、バグが発生する。

-----------------------------------------------

<FieldMngでMODEの管理をする>--------------------
MODEというのは、探索モード/戦闘モード/メニュー
とかの、フィールド上で遷移するもの。

今は、時間経過で戦闘モードになるようにしてテスト
している。

空のオブジェクトを作成して、FieldMngと命名。
それに新規Scriptをアタッチして、その名前も
FieldMng.csにした。

FieldMng.cs内ではさっき書いた通り、時間経過で遷移するようにswitch文を書いている。

MODEが切り替わる事でCameraMng内のカメラ切替や、
ButtleMng内の攻撃モーション操作ができるようにならないといけないから、static変数でnowModeをつくり、
どのクラスからでもFieldMng.nowModeで現在の状態を
見れるようにした。

また、ButtleUICanvasについては、ButtleMngで
表示/非表示を管理するために、ButtleMng.csにpublic変数を追加して、アタッチできる場所を用意した。
missingに注意すること！！

これからも「複数クラスからの参照」があり、
「唯一の変数」で良いならstaticにしたほうがいい。
情報も持ち越せるだろうしね。

------------------------------------------------

<MODEがButtleなら、UnitychanControllerをoffに>--

UnitychanController.csに、MODEがSEARCHなら動く
ようにしたらいいね。それ以外ならreturnさせれば早い。

MODEが切り替わる時に走っていると、走りモーション
が終わらなくなる為、returnの前に、is_Runをfaseに
する処理を入れておく。

また、戦闘モードで行動する順を毎回守る為に、
returnの前に、nowTurnChar_ = CharcterNum.UNI;
を入れる。

町の中でもSEARCHにしておけばいいかな？

------------------------------------------------

<戦闘用ワープポイント>--------------------------
実際のゲームフィールドでは、ひらけた空間を1ヶ所は
用意しておき、そこに戦闘では一時的にワープさせる
→ゲームフィールド毎に、戦闘用ポイントを設置する

あとはモードが切り替わったときにキャラの向きと位置の所定位置をきめとく。

ButtleMngでキャラを取得してるから、場所と向きを
予め設定できる何かを用意しておく。

<テストでポイントを作ってみる>
以下、バトルワープポイントのことをBWPと記載する。

キャラが2体なので、2つ設置する必要がある。
まず、BWPをまとめる空のオブジェクトを作成して、
ButtleWarpPointPackと命名。(座標0,0,0にする)
その後、それの子供に2つCubeで、BWP0,BWP1を作成。
(必要がない、BoxColliderをremoveしておく。)

ButtleMng.csにバトルワープポイントの取得を書く。
そのために、public変数で、BWPPackをアタッチできる所をつくる。
マップ毎にSceneを分けるのであれば、この方法で問題ない…はず。

BWPPackの子の座標をStart関数内で別の変数に保存する。
戦闘モードに切り替わるときに、その座標をキャラに入れてあげたらよい。
キャラの向きは、実際のマップをつくってみないとわからないが、全て進行方向を、統一する必要がある。

メモリーリークを防ぐ書き方の参考↓
https://madnesslabo.net/utage/?page_id=11109#i-17

基本的に、Sceneを丸ごと削除したらメモリーリークの
発生は起きにくい。(削除＝アンロード)
ただ、Sceneを跨いでも残る情報(シングルトンとかMng系の何か)とかがあると、
参照次第ではメモリーリークになるかもしれないからDestroyのあとにnullを代入する注意が必要。

------------------------------------------------

<戦闘用ワープポイントでのキャラの向き>-----------

戦闘用UIの回転方法と類似している。はず。
①buttleWarpPointsRotate_という配列変数を用意する
②buttleWarpPointsPos_と同じタイミングでStart関数でワープポイントの回転角をクォータニオンで取得
③戦闘モードになったとき、キャラクターの回転角に
②のクォータニオンを代入するだけ。

BWPの箱を回転させれば、その向きにキャラも変更できるはず。できました。
------------------------------------------------

<敵とのエンカウントまでの色変化の作り方>---------
テストとして、普通の3DオブジェクトにEncountColorという新規Scriptで作成したものをアタッチして行った。

参照したもの↓
https://teratail.com/questions/302182

今回は、255とかのbyte単位で変化させるのを使用した

色合いの変化を
青→青緑→緑→黄色→オレンジ→赤
と変化させた。

まず、青の値を減算して緑の値を加算する
加算：green * (time_ / toButtleTime_)
減算：255 - (blue * (time_ / toButtleTime_))

time_ / toButtleTime_は、
(現在値 / エンカウント発生時間)なので
0～1の値にできる。
これに255を乗算するとその時間に適した値を出せる。
減算したい時はさらに先頭に255 - をつけると良い。

time_ / toButtleTime_が0.5fを超えたら
redStartFlg_をtrueにして、赤の加算を始める。
このとき、青の減算を早めて、緑も減算を行う。

これで、色の変化は完成した。

次に、time_ / toButtleTime_の計算をFieldMng.cs
で行い、EncountColor.csに引っ張ってくる方法を考える。

------------------------------------------------

<EncountColor.csがFieldMng.csの値を参照する>----

EncountColor.csで変数追加して、
(private FieldMng fieldMng_;)

Start関数で名前検索をかけて、中のコンポーネントの
FieldMngを取得する。

fieldMng_ =　GameObject.Find("FieldMng").
　　　　　　  GetComponent<FieldMng>();

あとは、Update関数で毎回取得して、
float time = fieldMng_.GetNowEncountTime();

いままで、(time_ / toButtleTime_)と書いて計算式を書いていたところをtimeに変更する。

最後に、戦闘が終了したら、また青からスタートするように戻す方法を考えないととと・・・

nowModeがMODE.BUTTLEなら計算をせずreturnにして
値を初期化する。

------------------------------------------------

<[Field]をバトルカメラから除外する>-

新規でレイヤーを作成[Field]
MainCameraのCullingMaskでは、[Field]に
チェックをつける。

ButtleCameraのCullingMaskでは、[Field]に
チェックをつけない。

他にも映したくないものが増えてきたら[Field]に
レイヤーを設定すればいい

------------------------------------------------

<FieldUICanvasを作成して、画像の色を変更させる>--

素材を入手したときのアナウンスとかも入れられるように、新規にヒエラルキーにFieldUICanvasを作った。

レイヤーはFieldに設定し、さっきまで色変化のテストにつかっていたものを修正していく。

①FieldUICanvas内にImageを作成。
　テストでつくったwhite.pngを入れる。
　Colorをクリックすると、色相環がでてくるが、
　色相環の右下に[RGB0-255]とか書いてるやつがある　これを[RGB0-1.0]に変更しておく。

②EncountColor.csではマテリアルだったところを
  Imageにしたり変更を行う
　特に注意する点は、①で0～1.0にしたため、

image_.color = 
new Color(r/255.0f , g/255.0f , b/255.0f, 1.0f);

こんなかんじで、255.0fで割る必要がある。

------------------------------------------------

<UI要素はCulling Maskできないと書かれてて>-------

FieldUICanvasを追加したものの、なぜかレイヤー分けしてもバトルカメラにエンカウント目安UIでてきたので
調べたところ。
Culling Maskができないとか書かれてた。

よって、FieldUICanvasを非表示にする方法を考えることになった。

他の普通のオブジェクトは[Field]でカメラ分けできると思うから、レイヤー自体は残しておきます。

ButtleMng.csのUpdate関数の最初のif文に、
戦闘モードじゃなかったらbuttleUICanvasをfalseに
するってところがあるから、このタイミングで
FieldUICanvasはtrueになっている必要がある。

よって、ButtleMngのpublic変数を増やして、
FieldUICanvasをアタッチできるようにしたら早い。

FieldUICanvasをfalseに戻すほうもちゃんと書いとく

これで、戦闘モード中はカメラに映らないように修正ができた。
-----------------------------------------------

<EncountColor.csの改良>------------------------
同じような計算を複数回行っているため、別関数に
計算内容をまとめて、フラグや値で処理を分けて、
計算結果を関数の返り値にするようにした。
(ColorValueCalculation関数のことです)
-----------------------------------------------

<キャラが歩いているときだけエンカウント時間加算>-
今は止まっているときでも時間が加算されているので
FieldMng.csを修正して、歩いているときだけ。に
変更していく。

[歩いている＝座標移動している]だから、
UnitychanController.csでフラグを立てて、
FieldMngで参照できるようにしたらいいかな？？

UnitychanControllerもマネージャー的なオブジェクトに近いから、今回はfindで検索しよう。

FieldMng.csにprivate変数でplayer_を追加して
findで名前検索。
Update関数でplayer_.GetMoveFlag()を呼び出す。

GetMoveFlag()というのは、UnitychanController.cs
で新規に作成した関数で、GetBoolの状態を取得する。

------------------------------------------------

<Findとプロトタイプ宣言からのインスペクター指定>-

別のオブジェクトについているスクリプトを見たい時
①find検索
②findTag検索
③public Gameobjectとしてプロトタイプ宣言して、　Inspectorから指定する

がある。

それぞれのメリットとデメリット↓
https://marunouchi-tech.i-studio.co.jp/2266/

まとめ部分だけ載せておくと、
a.マネージャー的なオブジェクトはStartの時にFind
b.表示非表示を繰り返すようなものはInspector上から　指定して使う
c.Insulatorから指定するのは便利だが、大量のオブジ　ェクトを確保しようとするとプロトタイプ宣言の箇　所がとても多くなる。
　そこは親オブジェクトだけInspector上から取得し、　子オブジェクト等は親オブジェクトから取得する。

つまり、表示非表示管理をしないものは基本findを
start関数で行うといいのかもしれない

------------------------------------------------

<コマンドの回転に区別をつける>-------------------
まずは、攻撃コマンドとそれ以外にわけてみる。

回転してたらわからなくなったからメモ
右回転と左回転を比べる。

右　　 左
0  と +-360は一緒 
90 と -270 は一緒
180と -180 は一緒
270と -90  は一緒

左　+　360 = 右!!!

マイナス値なら+360で計算したらうまくいった

Quaternion.Angleを使っているif文内に処理を
追加しました。

------------------------------------------------

<ButtleMng.csにコマンド情報を渡す>--------------
すでにこれまでの実装の経緯で、ButtleMng.csの引数にButtleUICanvasがいて、buttleCommandUI_という
変数にImageRotate.csの情報がある。

アタックモーションになっているときに、
if(buttleCommandUI_.GetNowCommand() == 　　ImageRotate.COMMAND.ATTACK)

というのでif文を追加したらうまく選択ができていた

GetNowCommandという関数はImageRotate.csに新規で
追加しました。

他のスクリプトでpublicのenumと==の判定をしたいときは、今回みたいなif文の書き方をしたらいいみたい

-----------------------------------------------

<unityちゃんの通常攻撃>-------------------------

KY_effectsというアセットのエフェクトで作成する。

参照したもの↓
https://gametukurikata.com/program/shockwave

KY_effects > MagicEffectsPackFree > prefab
の中の、ErekiBall2を複製して「UniAttack」と命名。
(オリジナルは念のためとっとくようにする)

①一度、ヒエラルキーにおいてアンパッケージ化する

②UniAttackの親オブジェクトにSphereColliderを
　つける。IsTriggerにチェックをつける
　RigidBodyを追加し、UseGravityのチェックを外す

③ButtleMng.csにAttackStart()という上記のサイト　の関数を追加して、②をアタッチできるようにする

④新規Scriptで、「MagicMove.cs」を作成
　内容は、上記のサイトのShockwaveMoveスクリプトを
　持ってくる。一部判定でいらない部分があるので
　削除もおこなう

⑤UniAttackに、MagicMove.csをアタッチ

⑥再びPrefab化する

⑦ButtleMngというオブジェクトについている　　ButtleMng.csにProjectファイルのprefabから直接　ドラッグ&ドロップする
　(ヒエラルキーに置いてたUniAttackは消してよし)

UniAttackが自然消滅しないから、Start関数に、
Destroy(this.gameObject,5);
みたいに指定した時間が過ぎたら消えるようにしとく

でもたぶん最終的には敵に当たったら消えるからいらないとは思う。


<発動させたキャラの位置から弾がでるようにする>
よくよく考えたら、ちゃんと座標指定ができてなかった。

ButtleMng.csのAttackStart()という関数で弾の発生位置を調整してインスタンスしているから、キャラの戦闘開始時の座標を保存して、それを使用する必要がある。

a.戦闘開始時のそれぞれのキャラ座標を保存する
①CharcterSettingの構造体に、buttlePosという変数　を追加する

②Update関数内で、setCallOnce_がfalseの時に
　foreach文で戦闘用座標と回転角度を代入している所　がある為、そこに
charSetting[(int)character.Key].buttlePos = character.Value.gameObject.transform.position;
　と追加する。
　おそらく、非戦闘時にメニュー画面でキャラの立　　ち位置を交換とかしても、戦闘開始時に必ずここの　処理が呼ばれるので、エフェクト発生位置の目安に　できる。

b.AttackStart関数でエフェクトの座標を調整する
　今行動ターンが来ているキャラだとわかるように      AttackStart((int)nowTurnChar_);という風に
　引数を持たせる。
　
　あとは、関数内で
　var adjustPos = 
　new Vector3(charSetting[charNum].buttlePos.x, 　　　　charSetting[charNum].buttlePos.y + 0.5f, 　　　　charSetting[charNum].buttlePos.z);
　とすれば完成ですね。

-----------------------------------------------

<通常攻撃が敵に当たるか確認する>----------------

まずはテストの敵を用意する。
①Cubeを出して配置
→BoxColliderのIsTriggerはチェックなしでok
→Rigidbodyの追加をし、UseGravityはチェックなし
②新規Tag  →Enemy
　①にEnemyというタグをつける
③MagicMove.csに判定があるので、敵に当たると
　弾と敵が消えるのを確認する
------------------------------------------------

<攻撃弾連打できちゃうバグ>----------------------
Spaceキーを押下したら～のif文の中で、
isMoveをtrueにしている箇所がある。
そこを、

if(!charSetting[(int)nowTurnChar_].isMove)
{
   AttackStart((int)nowTurnChar_);
   charSetting[(int)nowTurnChar_].isMove = true;
}

とすることで、連打しても1キャラにつき1攻撃エフェクトしか発生させないようにできる。

------------------------------------------------

<ButtleMng.csの肥大化軽減方法について>----------
ButtleMngは、あくまで戦闘中全般をまとめるのが目的なのに、今はキャラクターの内容に偏っている。
そのため、新規にCharacterMngをつくって、
戦闘中/探索中の両方のキャラ状態を管理できるスクリプトを用意したほうが良い。

空のオブジェクトを作成して、[CharacterMng]と命名
新規Scriptを作成して、[CharacterMng.cs]と命名
空のオブジェクトに新規Scriptをアタッチする。

ButtleMng.csでは、CharacterMng.csの
Buttle関数とButtleSetCallOnce関数を呼び出している

*重要*
それぞれにアタッチするものも増減があったため
記載しておく

→の左辺が引数、右辺がヒエラルキーのやつ
<ButtleMng>
・ButtleUICanvas → ButtleUICanvas
・FieldUICanvas  → FieldUICanvas 

<CharacterMng>
・ButtleUICanvas→ButtleUICanvas
・CharList：2
Element0 → SD_unitychan_humanoid0
Element1 → SD_unitychan_humanoid1
・ButtleWarpPointPack → ButtleWarpPointPack
・UniAttackPrefab_    → UniAttack

------------------------------------------------

<攻撃コマンド以外のコマンドを仮実装する>---------
CharacterMng.csに、攻撃コマンド以外のコマンドを
仮実装していく。

Buttle関数のスペースキーを押したの処理にswitch文を入れておく。
コマンド別にデバッグログが出力されるようにしとく

いまはこれで十分だろう。
------------------------------------------------

<敵の生成ポイントをつくる>----------------------

出現ポイントを用意しておいて、そこにインスタンスされるようにしたい。

ヒエラルキーの階層としては、

敵のワープポイント管理親
　→1体の時の親
　　→実際の座標にするBox(1)
　→2体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　→3体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　　→実際の座標にするBox(3)
　→4体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　　→実際の座標にするBox(3)
　　→実際の座標にするBox(4)

こんな感じかしら？

------------------------------------------------

<まずは、中央に1体出せるようにしよう>------------
[敵のワープポイント管理親]として、[EnemyInstancePointPack]という空のオブジェクトを作成

[→1体の時の親]として、EnemyInstancePointPackの
子供に[1]という空のオブジェクトを作成
(ここを番号にすることによって、
　名前をint型で取得できるようになる)

[→実際の座標にするBox(1)]として[1]の子供に
また、[1]というCubeを作成
BoxColliderをRemoveして、座標(x:0,y:0.5,z:3.5)に
設置する。

※EnemyCubeはEnemyMaterialで赤を用意してアタッチ
　その後、Prefab化してヒエラルキーから除外する。

空のオブジェクトを作成し[EnemyInstanceMng]と命名
新規Scriptを作成し、[EnemyInstanceMng.cs]と命名
空のオブジェクトに新規Scriptをアタッチする。

EnemyInstanceMngのEnemyInstancePointPackという
引数に、ヒエラルキーのEnemyInstancePointPackを
アタッチする。

<EnemyInstanceMng.csの中身>
Start関数で2重foreach分を回す。
子と孫で順番に回したあとに、enemyPosSetMap_という変数にインスタンスしたい座標について保存する。
詳細はスクリプトを読んでね。

テストとして、public変数を追加して、Enemyとする
先ほどPrefab化したEnemyCube(Assets-Prefab-Enemy)
をEnemyInstanceMngのEnemyCubeという引数にアタッチする。

あとはEnemyCubeのインスタンスタイミングの調整と、
実際のインスタンス処理を行えば完成かな？

①インスタンスタイミング
ButtleMng.csのUpdate関数内にある
if(!setCallOnce_)の中にEnemyInstanceMng.csが
呼び出せればよい。
まずは、ButtleMng.csにFindでEnemyInstanceMngを
取得した変数を用意しておく。

②実際のインスタンス処理
これはEnemyInstanceMng.csでやる内容
EnemyInstance(int mapNum)というpublic関数を
用意したため、そこを見てね。
あとは、この関数を①の呼び出し予定位置で呼べば終わり。

------------------------------------------------

<敵が2,3,4体でるバージョンもつくろう>------------

EnemyInstancePointPackに[2][3][4]もつくろう
設定方法は上記と同じ。
確認するときは、ButtleMng.csで呼んでいるEnemyInstance関数の引数値を変更してね。

※デバッグ用に、ButtleMngのインスペクターからいじ　れるようにしときます。
　→debugEnemyNumという引数をButtleMngに追加

-----------------------------------------------

<UniAttackプレハブの修正>-----------------------

RigidBodyのRadius→0.5
に変更する

------------------------------------------------

<敵の方向に向かって攻撃が飛ぶようにする>---------

テストとして、敵の数が1の場合で行う。

CharacterMng.csにAttackStart関数があり、ここで
弾の飛ぶ方向が設定されている。
そのため、ここに敵の座標を渡せたら良い。

EnemyInstanceMng.csにGetEnemyPosという関数を追加して、敵の座標を持ってくることはできたが、
UNI→問題なく当てられる
DEMO→違う方向に飛ぶ
方向の設定が、キャラの立ち位置によってうまくいっていない

参照したもの↓
https://teratail.com/questions/201882
ベストアンサーでは、座標位置を正規化している。
これを「対象敵 - 行動中のキャラ」にすることで
実装する事が出来た。

------------------------------------------------

<キャラが攻撃する敵を選べるようにする>-----------

(処理の流れ)
攻撃コマンド押下→敵を選択する矢印的なのを操作→
SPACEキー押下→攻撃モーション

敵選択も、コマンドを回転させるやつと同じボタンでいいと思う。

※攻撃cancelボタンも必要(コマンド選択へ戻す)

・・・どうやってつくろう＞＜

(案)
CharacterMng.csでSpaceキーを押したときに、
矢印のクラスへenemyInstanceMng_のpos情報を渡して、矢印のクラスで敵選択の操作をする。
再びSPACEキーを押されたら選択した敵の座標が矢印のクラスからCharacterMng.csにreturnされるようにして、そのreturnされた座標に対して攻撃を飛ばすようにする。
※cancelボタンが押されてもreturn -1;とかにして、
　CharacterMng.csに戻されるようにする。

------------------------------------------------

<上記の(案)を使って、敵選択を実装する>-----------

まずは、CharacterMng.cのStart関数で、敵の出現座標を全てEnemyInstanceMng.csから受け取っておく。

矢印のクラスへenemyInstanceMng_のpos情報を渡す際に敵の出現座標を全て渡すのは効率が悪いので、
ButtleMng.cs側で敵の出現数を決定した後、
CharacterMng.csに新規で用意したSetEnemyNum関数に
値を設定するようにした。
(enemyNum_という変数に保存しておく)

これで矢印のクラスpos情報を渡すときは、
enemyInstancePos_[enemyNum_]とすれば必要な座標だけ渡すことができる。はず。

あとは、テストとして矢印の代わりにSphereを用意して[EnemySelectObj]と命名。Collider外す。
そこに新規Scriptの[EnemySelect.cs]をアタッチ。

[EnemySelectObj]は、ButtleUICanvasの子供にしておく。

CharacterMng.csにはもともとbuttleUICanvasをアタッチしていたので、private変数でEnemySelect.csを
取得できるようにする。

EnemySelect.cs側にSetPosList関数を用意して、
CharacterMng.csのSetEnemyNum関数内で呼び出す。

SetPosList関数ではY座標を高くしないといけないため
参照したもの↓
https://among-ev.hatenadiary.org/entry/20100925/1285412730
上記のサイトを参考に調整した。

次は、キー操作で矢印の位置が移動するようにする。
EnemySelect.csのUpdate関数に条件付きで位置移動を
させれば完成。
※InstancePointを全て左から順にするようにヒエラル　キーを設定しなおす

<ATTACKを選択する前から矢印がでてるバグ>
CharacterMng.csでselectFlg_という変数を作り、
ATTACK時に切り替えられるようにしておく。
また、矢印の表示/非表示をCameraMng.cs側で
設定できるように、SetActiveという関数を追加した。


EnemySelect.csにGetSelectEnemyPosを追加して、
最終的に選択した敵の座標をCharacterMng.csの
AttackStart関数に情報を引っ張ってこれるようにした

<敵選択中にコマンドがくるくるしちゃうバグ>
ImageRotate.csにrotaFlg_という変数を追加してSetRotaFlgという関数も追加。
CharacterMng.cs側で設定できるようにしたため、
buttleCommandUI_.SetRotaFlg(!selectFlg);という
処理をButtle関数のATTACKのcase文内に追加した。

<選択した敵にぶつかるまえに違う敵に当たり、
 弾が消滅してしまうバグ>
MgicMove.csのOnTriggerEnter関数で当たり判定をするとき、選択した敵以外ならDestroyしないようにする

CharacterMng.csのAttackStart関数で生成されるから
ここに、選択した敵かの判別ができるようにしたい
MagicMove.csにSetTargetNum関数を作り、
CharacterMng.cs側から選択した敵の番号を設定できるようにした。

次に、EnemyInstanceMng.csのEnemyInstance関数で
生成した敵の名前を[EnemyCube]から変更し、
生成順で番号にした。詳細は下のサイト

EnemyCubeに名前を付ける
参照したもの↓
https://teratail.com/questions/44869

あとはMagicMove.csの当たり判定時にif文を追加して
当たった敵と選択していた敵の番号が一致しているかを見てDestroyするかしないかを決めるようにした。

------------------------------------------------

<Destroyした敵の座標の上に矢印がでるバグ>--------

Destroyされた敵の座標部分はとばすようにしたい。

EnemySelece.csでつくっているposList_をタプルに変更して、座標情報とbool情報を持たせるようにした。

boolの方はSetPosList関数の中で座標情報分Addした
後に、全てtrueにしてposList_に代入する。

そして、GetSelectNum関数でreturn selectNum_の前に該当するposList_のboolをfalseにする。
(リストから削除すると要素が上に詰められて番号が異なるバグがでるため使わないようにした。)

あとは、Update関数でselectNumが加算or減算される時に、「falseになっている座標は飛ばす」ようにしたい
while文でつくった。

EnemySelect.csにMoveSelectKeyという関数を新規で作成して、そこで飛ばす処理を書いた。

最奥の敵と最手前の敵を倒した時に、while文だけでは
その敵の位置に矢印を置かないようにする。という処理が実装できなかった。
(while文を抜ける条件と被るから)
その為、tmpFlgやforeach文を追加してつくった。

UP処理の方では、foreach文を逆回しする必要があるので、posList_.Item2.Reverse();等を書いている。
ただし、逆回しにしたまま処理を終わらないように、
最後にもまたposList_.Item2.Reverse();を書いておくこと！

<Destroy後にSPACEキー押下したら、消された所から
 矢印がスタートしてしまうバグ>
HキーやJキーで切り替える範囲を狭めることは上記の処理で完成したが、消した直後にまたSPACEキーで選択するときは消えた敵のいた頭上からスタートしてしまう。

EnemySelect.csにResetSelectPointという関数を新規で用意し、MoveSelectKey関数のDOWN処理にあるforeach部分と同じ処理をいれる。
※まったく同じ処理なので、むしろResetSelectPoint　関数の内容を、MoveSelectKey関数のDOWN処理に呼ぶ　ようにした。
これをCharacterMng.csのStartAttack関数のGetSelectNum関数を読んだあとに入れ込む。

これで矢印のスタート位置をリセットできるようになった。

------------------------------------------------

<キャラが攻撃対象の方を向くようにする>-----------

参照したもの↓
https://code.hildsoft.com/entry/2017/07/06/060658

CharacterMng.csのStartAttack関数に、
charMap_[nowTurnChar_].transform.localRotation = Quaternion.LookRotation
(enePos - charSetting[charNum].buttlePos);
という一文を追加した。

これにより、方向を変える事ができるようになった。
------------------------------------------------

<2回目以降敵と遭遇するとEnemyCubeが宙に浮いてる>-

バグですね。
原因は、矢印用にy軸にoffsetかけた座標が使われてしまっているから。

座標のコピーがうまくいっていないんだと思う。

(対処法)
CharacterMng.csのSetEnemyNumで、今までは
buttleEnemySelect_.SetPosList
(enemyInstancePos_[enemyNum_]);という風に
直接敵の初期座標を引数に入れていたが、

これをコピーされるように
List<Vector3> tmpInsPos = 
new List<Vector3>(enemyInstancePos_[enemyNum_]);

buttleEnemySelect_.SetPosList(tmpInsPos);

上記のように一時変数に入れたものを引数に入れるようにしたら、きちんとコピーされるようになって、
矢印のy座標が2回目以降使われなくなった。

------------------------------------------------

<敵選択中に、コマンド選択に戻れるようにする>-----

つくるのをすっかり忘れていた…。

EnemySelect.csにReturnSelectCommand関数を作成して、返り値をboolにしておく。
特定のキー(いまはTキー)を押下されたときにreturnで
falseを返すようにし、それをCharacterMng.cs側で確認できるようにして、falseなら、selectFlg_をfalse
になるようにしておく。
※そのときにはImageRota.csのSetRotaFlgをtrueに
　するのを忘れずに！

これでコマンド選択に戻れるようになった。
------------------------------------------------

<キャラ毎のデータ管理について考える>-------------
現状は、CharacterMng.csに攻撃処理とかまとめて
しまっているから良くない。
これからキャラ毎にステータスとかも発生するから、
今のうちに直していく必要がある。

参照したもの↓
https://gametukurikata.com/csharp/csharpinheritance

(自分なりの解釈)
インターフェース：多重継承可能。
様々なクラスに使いたいものをまとめる。
(例)Attack,Damage,HPとかとか…
例に書いたものは、キャラも敵も使うよね！ってやつ

抽象クラス：多重継承ができない。
同じ性質のクラスに使いたいものをまとめる。
(例)LevelUp関連,Weapon関連,Defenceとかとか…
例に書いたものは、キャラに必要だけど敵にはいらないよね！ってやつ

(改善手順)
①Chara.csを作る
　これは、最終的にCharacterMng.csでインスタンス
　されるクラスになる

②インターフェースをつくる
　Scriptでつくるみたいで、普通のスクリプトの
　書き方とは違うみたい。詳細は上記のサイトで！

③抽象クラスをつくる
　CharaBase.csみたいなのを用意して、
　Chara.csの下準備をするクラス

④①に、②と③を継承する

⑤Chara.csに必要となる内容を書いていく

それでは、詳細を書きながら実装していきます。

------------------------------------------------

<インタフェースの作成>--------------------------
InterfaceButtle.csという名前で作成する。
内容の書き方は上記のサイト通り。
現状思いつく限りでは、Attack,Damage,HPぐらい…。
------------------------------------------------

<抽象クラスの作成>------------------------------
CharaBase.csという名前で作成する。
内容の書き方は上記のサイト通り。

抽象関数として、
LevelUp,Weapon,Defence,Magic,Itemというのを用意
------------------------------------------------

<Chara.csの作成>-------------------------------
いよいよ、各キャラへインスタンスするスクリプトを
作成する。Chara.csという名前で作成する。

※抽象クラスをインタフェースより先に継承元として
　記述しないとエラーがでるみたい

つくっているうちにまたよくわからなくなってきた。

…あとはこのChara.csをCharacterMng.csで
インスタンスすればいい、のか？
サイトではMakeCharacter.csを別で用意してるみたい
だけど、そこをCharacetrMng,csで置き換えて考えていきます。

------------------------------------------------

<CharacterMng.csでChara.csをインスタンスする>---
※CharcterNumのenumをpublicにして、
CharaBase.csとChara.csにCharacterNumを使った変数とか引数を追加しました。

キャラ毎の情報をChara.csから取得する方式にする為
CharacterMng.csに、List<Chara> charasList_ を
用意して、Start関数のforeach文で.Addするようにした。.Addと同時にChara.csを各キャラにインスタンスする。その為、引数にオブジェクト名,番号,情報一式
を入れられるように工夫した。
※情報一式をCharacterMng.cs内で次回以降使う時は、
　Chara.csのGet関数から引き出す為、情報一式の初期　設定はforeach文内で使い捨ての変数で良い。

あとは、いままで
charSetting[(int)キャラ番号]とかでやっていたのを
charasList_[(int)キャラ番号].(Chara.cs側の関数)
というような書き方に直していくだけ。結構変わったところが多いので、よく見直しておいたほうがいい。


Chara.csをインスタンスするときに外部データのキャラデータをその前に読み込んでおいて、newの引数に入れて渡すようにする。
そうしたら、各キャラにそれぞれのステータス値を渡せる。はず。たぶん。。。

------------------------------------------------

<いろいろメモ欄>
にげるコマンドは、回転座標から切り離して設置したい。にげるコマンドの代わりに、防御コマンドを
いれるようにする。
→にげるを選択するのにコマンドをぐるぐる回すのは　手間というか、面倒くさい。

なにもしないでも敵に遭遇できるアイテムがあったら便利そう。

キャラが攻撃対象を選ぶ時に、
矢印が敵の頭の上に浮いててフワフワくるくるしてて
ほしい。

最終的には、ButtleWarpPointPackと
EnemyInstancePointPackの2つをPrefab化しておいて
ヒエラルキーからは除外し、AssetsフォルダからMng系にアタッチするように変更する予定。
→表示座標が正式に決定してからね

今は、攻撃弾が敵にhitしたと同時に消えてて面白味がないから、改善策を考える
→衝突後パーティクルとかあるといいかも

コマンドの回転速度が一定で面白味がないので、
最初と最後が速いような速度差をつくりたい。

------------------------------------------------
