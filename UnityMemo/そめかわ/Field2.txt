必要な要素

・暗闇
→暗闇リンゴが生る場所

・オアシス
→清らかな水が取得できる場所
　※画像検索して雰囲気大事にする

------------------------------------------------

①Uniを設置して、UniとMainCameraの座標を
　ForestFieldと同じ値にそろえる。

②地面の高さや位置を合わせるために、
　EnvironmentのPosをX:-20 Y:0 Z:20
  とする。

③ForestFieldから[FieldMng][CameraController]
  [ButtleCamera][WarpOut][DontDestroyCanvas]
　[SceneMng][Jack][EventSystem]を
  引っ張ってきてアタッチの設定をする。

④MainCameraに[CameraSample.cs]をアタッチする
　→これでUniにカメラが追従する

⑤戦闘状態に遷移してほしくないから、
　FieldMng.csのtime_+=Time.deltaTime;を
　コメントアウトしておく(77行目付近)

⑥unitychancontroller.csの値を一部修正

⑦あとは、地面に設置するオブジェクトを複製して
　それっぽくする

⑧壁とか岩にコライダーをつける

※RockとかのMeshColliderは全部外して、
　大き目のやつにはCapsuleコライダーとかつける。

※FieldMng.csの63行目でImageが取得できないバグ
→bagImage_ = GameObject.Find("DontDestroyCanvas/Menu/BagImage").GetComponent<Image>();
と記述したら一応大丈夫そうだけど。。。

------------------------------------------------

<オアシスについて>------------------------------

まず、水を何かで囲まないといけない、、
EnvironmentのTerrain_1のやつの、
ScaleYを高くして、PosYを低くすることで尖った
山脈部分だけを地上にだすようにする。

Assets/Town/StandardAssets/Environment/Water/
Water/PrefabsにあるWaterProDaytimeを置いて
unpackした後、座標と大きさを決める。
→これで水を囲めるようになった

あとは周りに草木をはやしていく。

------------------------------------------------

<でこぼこ道でユニが浮いたままになる>-------------
UnitychanController.csのUpdate関数で、
一定値以上の高さにいるときはY座標をマイナスするようにした。

------------------------------------------------

<暗闇作るの忘れてたわ>--------------------------

左上らへんに屋根ついたなんか場所つくった。
りんご上からぶらさげたいなぁって感じ。

下の場所からりんごだけ取り出す
https://assetstore.unity.com/packages/3d/props/food/low-poly-fruit-pickups-98135

ついでに少し当たり判定の壁を追加+修正した。

------------------------------------------------

<砂漠にいそうな敵を探す>------------------------
①https://assetstore.unity.com/packages/3d/characters/animals/insects/animated-low-poly-spider-125114#content

②https://assetstore.unity.com/packages/3d/characters/stone-monster-101433

③https://assetstore.unity.com/packages/3d/characters/3d-monster-bomb-145319

④https://assetstore.unity.com/packages/3d/characters/animals/birds/egypt-pack-eagle-140079


ボス予定
すらねこ？にする。
透明な女猫みたいなの
------------------------------------------------

<地面の色が明るすぎてみづらい>-------------------

FieldMap/Environment/Terrainの
Yellow.3のAlbedoを調整する

元     0.81,0.72,0.36
変更後 0.65,0.58,0.30

------------------------------------------------

<敵を追加する>----------------------------------
①蜘蛛
なんか砂漠でも蜘蛛っていそうだよねってことで

<アニメーションについて>
AnimatorがないからForestFieldの敵のどれかから
Animatorをコピーしてきて[spider]と命名。
ステートにアニメーションを追加していく。

遠距離攻撃型にするならAnimatorのRunがいらないから
idleとattackを直接つなぐ
※idleからattackへの切替をinspectorで早めに
　切り替わるようにする。(HasExitTimeはチェック無)

<Enemy.xls>
とりあえずそれっぽい値を入れとく。
[Field1]というシートを作成。

[Enemy_importer]
"Field1"をsheetNamesに追加する。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Spider]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
とりあえず、カボスと同じエフェクトが出るように
してみる。

<DesertFieldEnemysプレハブ>
1番最初に追加。

<サイズ>
Scaleを2にする。

他のモーションも正常に動作することを確認

------------------------------------------------

<ユニ達が連続で攻撃を受けたときにモーションが
 間に合っていないバグ>--------------------------

モーションを短くする。
Damage->Standing@loop
Standing@loop->Damage
の両方ともinspectorからモーション時間を短くする。

また、Damage->Standing@loopの
HasExitTimeのチェックを外す。
※ジャックも同様に処理を変更する

------------------------------------------------

<蜘蛛が使用するエフェクトを用意する>-------------
現在はカボスと同じエフェクトを使用しているから
新規でエフェクトを用意して蜘蛛専用とする。

また、現在発生させるエフェクトを外部アタッチで
読み込んでいるが、カボスエフェクトしか読み込めないようになっているためその部分の修正を先に行う。

<敵毎に生成エフェクトを分けられるようにする>
Assets/Prefab/MagicEffectフォルダの
KabosuAttackを複製して[SpiderAttack]に名称変更。
[Enemy.xls]
SpiderのWeaponTagObjNameを
[SpiderAttack(Clone)]にする

空のオブジェクトで[EnemyAttackPrefab]を作成。
※このTagもWeaponにする
これに[KabosuAttack]と[SpiderAttack]を子にする。

EnemyAttackPrefabをMagicEffectフォルダに入れて
プレハブ化し、ヒエラルキーから削除。
EnemyInstanceMngの外部アタッチ部分の名称を
[enemyAttackPrefab_]に変更して、そこに今作った
プレハブをアタッチする。

[EnemyInstanceMng.cs]
BeforeAttack関数の遠距離攻撃の弾を生成する所で、enemyAttackPrefab_の子から今回の敵が使用するエフェクトを名前検索で探すようにfor文を追加した。

名前が一致したオブジェクトを生成するときに使用するように変更する。

[CheckAttackHit.cs]
現在はKabosuAttack(Clone)だったら魔法を削除みたい
な書き方をしているが、ここを遠距離攻撃なら削除。
という風に変更する。

削除リストみたいなのを作ったほうが速そう。
enemyEffectDeleteList_変数を作成して、
中に"KabosuAttack(Clone)","SpiderAttack(Clone)"
と入れる。

OnTriggerEnter関数の中の
name=="KabosuAttack(Clone)"としている場所で、
for文でenemyEffectDeleteList_関数を回して
処理をするように書き直す。

※最終的にはExcelにしたほうがよさそうかも。

<蜘蛛に良さげなエフェクト探しの旅>
KY_EffectのWhityBombを使用する。
KabosuAttackと同じように
コライダーやrigidbody、checkattachit.csと
magicmove.csをつけてタグをweaponにする。
sphere部分だけ残して他のオブジェクトは削除する。

これで丸い糸っぽいのができた？かも。

------------------------------------------------

<次の敵じゃ>------------------------------------
[StoneMonster]を入れてみる。

<アニメーションについて>
AnimatorControllerを作成する必要がある。
アニメーターがLegacyだからGenericにして、
CreateFromThisModelにして
StoneMonsterを設定する。

StoneMonsterにAnimatorのコンポーネントを入れて
Controllerに[StoneMonsterAnim]
Avaterに[StoneMonsterAvatar]を設定する。

→IdleとRunはAnimationのLoopにチェックをいれる
これでアニメーション設定は大丈夫そう。
設定しなおしたオブジェクトをプレハブファイルに
入れなおす。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_StoneMonster]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[StoneMonster]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<DesertFieldEnemysプレハブ>
2番目に追加。

モーション確認ok

------------------------------------------------

<つぎつぎ、次の敵>------------------------------

攻撃ターンになったら自爆する系ボム君

<アニメーションについて>
[BombMonsterAnim]として作成し、中にアニメーションを入れていく。
※自爆したあとに動かさないから、
　Attack->Runへの矢印を削除

※deathアニメーションがないから、damageを入れる。
プレハブを作り直して終了。

<Enemy.xls>
自分の攻撃力を、自分のHP+Defenceよりも高く
設定しておいて、一撃で自分のHPが削れるようにする

<モデルにつけるコンポーネント>
本体の名前を[Enemy_BombMonster]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[BombMonster]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる
※爆発する予定だからBoxColliderの大きさをだいぶ
　でかくする。

<DesertFieldEnemysプレハブ>
3番目に追加。

モーションの確認はokだから、キャラに攻撃して
爆発エフェクトがでたら敵を消すようにしたい。

<爆発エフェクト後に敵を削除する>
[CheckAttackHit.cs]
攻撃しているのがBombMonsterだったら、
自分のHP減少処理に入るようにする。

[EnemyInstanceMng.cs]
MoveToInitPos関数のflagを最初にtrueにする条件
として|| enemyList_[num].Item1.HP() <= 0を
追加し、攻撃直後にHPが0以下になった敵は
移動処理に入らないようにする。

------------------------------------------------

<魂的なエフェクトの処理まで終了してから
 戦闘画面をフィールドに戻したい>-----------------

MagicEffectのタグに[Finish]を設定する。

[EnemyInstanceMng.cs]
AllAnimationFin関数で[Finish]タグがあるか確認して
ある場合はreturn falseを返すようにする。

これで最後までエフェクトを再生できるようになる。
------------------------------------------------

<4体目の敵だよ！>-------------------------------
Eagleを実装する

<アニメーションについて>
既存のアニメーターは削除して、他からコピペして
[Eagle]とする。
中身のアニメーションを入れ替える。

IdleButtleのところに[Fly]のモーションをいれて、
Attackのところに[Idle]のモーションをいれる。
→羽ばたき方がゆっくりなFlyがIdleっぽかったから。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Eagle]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Eagle]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<DesertFieldEnemysプレハブ>
4番目に追加。

動作確認ok
------------------------------------------------

<戦闘に命中率を適用する>------------------------

計算的には、Speed値を使う
攻撃する側 / 攻撃される側 * 100 = ％をだす。
ランダム値をつかってその％より小さかったら命中
大きかったらmiss
と判断する。

(例)
攻撃する側のSpeed   6
攻撃される側のSpeed 2

6 / 2 * 100 = 300％
絶対あたる

攻撃する側のSpeed   6
攻撃される側のSpeed 7

6 / 7 * 100 = 85%ぐらい
でも1ステータスが違うだけでここまで下がるのは
良くないと思うから、
実際の数値に+10して95%にしたほうがよさげ

攻撃する側のSpeed   6
攻撃される側のSpeed 8

6 / 8 * 100 = 75%
これも+10して85%かな？

攻撃する側のSpeed   6
攻撃される側のSpeed 9

6 / 9 * 100 = 66%
+10で76%

攻撃する側のSpeed   6
攻撃される側のSpeed 10
70%

だいたい「数値の差が4以上」になると命中しづらい
かも

ただ、プレイヤー側にはボーナス入ってもよさそう。
Luckの値 * 5 を加算するとか

(例)
攻撃する側のSpeed   6
攻撃される側のSpeed 12
60%

攻撃する側のLuck 3
60 + (3 * 5) = 75%

こんな感じでいいかも

(結論)
命中率の計算方法は、
①攻撃する側のSpeed / 攻撃される側のSpeed
②①に*100をして％をだす
③ランダム値が％以下なら命中。

ただし、②の値に
キャラも敵も+10％の補正値を入れる

そしてキャラ側だけに
(自分のLuck * 5)％をプラスする。

100%以上は自動命中

<実際にコードに処理を追加する>
[ButtleMng.cs]
Set/GetSpeedNum関数を作成する。
speedNum_変数を用意する。

Set/GetLuckNum関数を作成する。
luckNum_変数を用意する。

[CharacterMng.cs]
SetDamageNum関数を呼び出しているところと同じ場所
でSetSpeedNum関数とSetLuckNumを呼び出す。

Hpdecrease関数の最初で命中計算をする。
※こっちでは幸運値を考慮しない

[Chara.cs]と[Enemy.cs]
Luck関数を作成する。

[EnemyInstanceMng.cs]
SetDamageNum関数を呼び出しているところと同じ場所
でSetSpeedNum関数とSetLuckNumを呼び出す。

Hpdecrease関数の最初で命中計算をする。

これで命中判定完成。
------------------------------------------------

<回避率について>--------------------------------

[CharacterMng.cs]
HPdecrease関数での処理。

命中判定時にLuckを使った回避判定を追加する。
Luckが10以下の時は10でランダム振って判定し、
10以上なら現在のステータスのLuckをそのまま使用する。

ランダムを振る範囲も0~100以下じゃなくて
「0~100-幸運値」にすることで、範囲を狭めて
成功しやすくする。

回避率は、キャラクター側にのみ実装してキャラの攻撃が当たらないことによるストレスを防ぐことにした

------------------------------------------------

<クリティカル率について>------------------------
クリティカルの特徴
・攻撃自動命中
・攻撃力up(2倍)

クリティカルの計算方法
回避と同じように0~100の上限を狭める
(100 - (10 + buttleMng_.GetLuckNum())とする)
ランダムの10以下を素のクリティカル値にする。
さらにここに幸運の値をそのままプラスする。

クリティカルではないときに、
命中判定と回避判定をするように設定しておく。

キャラと敵、それぞれのHPdecrease関数で判定する。
------------------------------------------------

<HPバーの高さを修正する>------------------------

敵の数が1~4の時にどの敵でもちゃんとHPバーとか
選択矢印が被らないように表示する方法を
考える必要がある。




Eagleの飛ぶ高さ的に、現在のHP表示位置が低い。
Eagleの時だけ、Y軸を+60ぐらいしたほうがよさそう

------------------------------------------------

