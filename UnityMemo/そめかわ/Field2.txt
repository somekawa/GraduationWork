必要な要素

・暗闇
→暗闇リンゴが生る場所

・オアシス
→清らかな水が取得できる場所
　※画像検索して雰囲気大事にする

------------------------------------------------

①Uniを設置して、UniとMainCameraの座標を
　ForestFieldと同じ値にそろえる。

②地面の高さや位置を合わせるために、
　EnvironmentのPosをX:-20 Y:0 Z:20
  とする。

③ForestFieldから[FieldMng][CameraController]
  [ButtleCamera][WarpOut][DontDestroyCanvas]
　[SceneMng][Jack][EventSystem]を
  引っ張ってきてアタッチの設定をする。

④MainCameraに[CameraSample.cs]をアタッチする
　→これでUniにカメラが追従する

⑤戦闘状態に遷移してほしくないから、
　FieldMng.csのtime_+=Time.deltaTime;を
　コメントアウトしておく(77行目付近)

⑥unitychancontroller.csの値を一部修正

⑦あとは、地面に設置するオブジェクトを複製して
　それっぽくする

⑧壁とか岩にコライダーをつける

※RockとかのMeshColliderは全部外して、
　大き目のやつにはCapsuleコライダーとかつける。

※FieldMng.csの63行目でImageが取得できないバグ
→bagImage_ = GameObject.Find("DontDestroyCanvas/Menu/BagImage").GetComponent<Image>();
と記述したら一応大丈夫そうだけど。。。

------------------------------------------------

<オアシスについて>------------------------------

まず、水を何かで囲まないといけない、、
EnvironmentのTerrain_1のやつの、
ScaleYを高くして、PosYを低くすることで尖った
山脈部分だけを地上にだすようにする。

Assets/Town/StandardAssets/Environment/Water/
Water/PrefabsにあるWaterProDaytimeを置いて
unpackした後、座標と大きさを決める。
→これで水を囲めるようになった

あとは周りに草木をはやしていく。

------------------------------------------------

<でこぼこ道でユニが浮いたままになる>-------------
UnitychanController.csのUpdate関数で、
一定値以上の高さにいるときはY座標をマイナスするようにした。

------------------------------------------------

<暗闇作るの忘れてたわ>--------------------------

左上らへんに屋根ついたなんか場所つくった。
りんご上からぶらさげたいなぁって感じ。

下の場所からりんごだけ取り出す
https://assetstore.unity.com/packages/3d/props/food/low-poly-fruit-pickups-98135

ついでに少し当たり判定の壁を追加+修正した。

------------------------------------------------

<砂漠にいそうな敵を探す>------------------------
①https://assetstore.unity.com/packages/3d/characters/animals/insects/animated-low-poly-spider-125114#content

②https://assetstore.unity.com/packages/3d/characters/stone-monster-101433

③https://assetstore.unity.com/packages/3d/characters/3d-monster-bomb-145319

④https://assetstore.unity.com/packages/3d/characters/animals/birds/egypt-pack-eagle-140079


ボス予定
すらねこ？にする。
透明な女猫みたいなの
------------------------------------------------

<地面の色が明るすぎてみづらい>-------------------

FieldMap/Environment/Terrainの
Yellow.3のAlbedoを調整する

元     0.81,0.72,0.36
変更後 0.65,0.58,0.30

------------------------------------------------

<敵を追加する>----------------------------------
①蜘蛛
なんか砂漠でも蜘蛛っていそうだよねってことで

<アニメーションについて>
AnimatorがないからForestFieldの敵のどれかから
Animatorをコピーしてきて[spider]と命名。
ステートにアニメーションを追加していく。

遠距離攻撃型にするならAnimatorのRunがいらないから
idleとattackを直接つなぐ
※idleからattackへの切替をinspectorで早めに
　切り替わるようにする。(HasExitTimeはチェック無)

<Enemy.xls>
とりあえずそれっぽい値を入れとく。
[Field1]というシートを作成。

[Enemy_importer]
"Field1"をsheetNamesに追加する。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Spider]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
とりあえず、カボスと同じエフェクトが出るように
してみる。

<DesertFieldEnemysプレハブ>
1番最初に追加。

<サイズ>
Scaleを2にする。

他のモーションも正常に動作することを確認

------------------------------------------------

<ユニ達が連続で攻撃を受けたときにモーションが
 間に合っていないバグ>--------------------------

モーションを短くする。
Damage->Standing@loop
Standing@loop->Damage
の両方ともinspectorからモーション時間を短くする。

また、Damage->Standing@loopの
HasExitTimeのチェックを外す。
※ジャックも同様に処理を変更する

------------------------------------------------

<蜘蛛が使用するエフェクトを用意する>-------------
現在はカボスと同じエフェクトを使用しているから
新規でエフェクトを用意して蜘蛛専用とする。

また、現在発生させるエフェクトを外部アタッチで
読み込んでいるが、カボスエフェクトしか読み込めないようになっているためその部分の修正を先に行う。

<敵毎に生成エフェクトを分けられるようにする>
Assets/Prefab/MagicEffectフォルダの
KabosuAttackを複製して[SpiderAttack]に名称変更。
[Enemy.xls]
SpiderのWeaponTagObjNameを
[SpiderAttack(Clone)]にする

空のオブジェクトで[EnemyAttackPrefab]を作成。
※このTagもWeaponにする
これに[KabosuAttack]と[SpiderAttack]を子にする。

EnemyAttackPrefabをMagicEffectフォルダに入れて
プレハブ化し、ヒエラルキーから削除。
EnemyInstanceMngの外部アタッチ部分の名称を
[enemyAttackPrefab_]に変更して、そこに今作った
プレハブをアタッチする。

[EnemyInstanceMng.cs]
BeforeAttack関数の遠距離攻撃の弾を生成する所で、enemyAttackPrefab_の子から今回の敵が使用するエフェクトを名前検索で探すようにfor文を追加した。

名前が一致したオブジェクトを生成するときに使用するように変更する。

[CheckAttackHit.cs]
現在はKabosuAttack(Clone)だったら魔法を削除みたい
な書き方をしているが、ここを遠距離攻撃なら削除。
という風に変更する。

削除リストみたいなのを作ったほうが速そう。
enemyEffectDeleteList_変数を作成して、
中に"KabosuAttack(Clone)","SpiderAttack(Clone)"
と入れる。

OnTriggerEnter関数の中の
name=="KabosuAttack(Clone)"としている場所で、
for文でenemyEffectDeleteList_関数を回して
処理をするように書き直す。

※最終的にはExcelにしたほうがよさそうかも。

<蜘蛛に良さげなエフェクト探しの旅>
KY_EffectのWhityBombを使用する。
KabosuAttackと同じように
コライダーやrigidbody、checkattachit.csと
magicmove.csをつけてタグをweaponにする。
sphere部分だけ残して他のオブジェクトは削除する。

これで丸い糸っぽいのができた？かも。

------------------------------------------------

<次の敵じゃ>------------------------------------
[StoneMonster]を入れてみる。

<アニメーションについて>
AnimatorControllerを作成する必要がある。
アニメーターがLegacyだからGenericにして、
CreateFromThisModelにして
StoneMonsterを設定する。

StoneMonsterにAnimatorのコンポーネントを入れて
Controllerに[StoneMonsterAnim]
Avaterに[StoneMonsterAvatar]を設定する。

→IdleとRunはAnimationのLoopにチェックをいれる
これでアニメーション設定は大丈夫そう。
設定しなおしたオブジェクトをプレハブファイルに
入れなおす。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_StoneMonster]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[StoneMonster]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<DesertFieldEnemysプレハブ>
2番目に追加。

モーション確認ok

------------------------------------------------

<つぎつぎ、次の敵>------------------------------

攻撃ターンになったら自爆する系ボム君

<アニメーションについて>
[BombMonsterAnim]として作成し、中にアニメーションを入れていく。
※自爆したあとに動かさないから、
　Attack->Runへの矢印を削除

※deathアニメーションがないから、damageを入れる。
プレハブを作り直して終了。

<Enemy.xls>
自分の攻撃力を、自分のHP+Defenceよりも高く
設定しておいて、一撃で自分のHPが削れるようにする

<モデルにつけるコンポーネント>
本体の名前を[Enemy_BombMonster]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[BombMonster]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる
※爆発する予定だからBoxColliderの大きさをだいぶ
　でかくする。

<DesertFieldEnemysプレハブ>
3番目に追加。

モーションの確認はokだから、キャラに攻撃して
爆発エフェクトがでたら敵を消すようにしたい。

<爆発エフェクト後に敵を削除する>
[CheckAttackHit.cs]
攻撃しているのがBombMonsterだったら、
自分のHP減少処理に入るようにする。

[EnemyInstanceMng.cs]
MoveToInitPos関数のflagを最初にtrueにする条件
として|| enemyList_[num].Item1.HP() <= 0を
追加し、攻撃直後にHPが0以下になった敵は
移動処理に入らないようにする。

------------------------------------------------

<魂的なエフェクトの処理まで終了してから
 戦闘画面をフィールドに戻したい>-----------------

MagicEffectのタグに[Finish]を設定する。

[EnemyInstanceMng.cs]
AllAnimationFin関数で[Finish]タグがあるか確認して
ある場合はreturn falseを返すようにする。

これで最後までエフェクトを再生できるようになる。
------------------------------------------------

<4体目の敵だよ！>-------------------------------
Eagleを実装する

<アニメーションについて>
既存のアニメーターは削除して、他からコピペして
[Eagle]とする。
中身のアニメーションを入れ替える。

IdleButtleのところに[Fly]のモーションをいれて、
Attackのところに[Idle]のモーションをいれる。
→羽ばたき方がゆっくりなFlyがIdleっぽかったから。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Eagle]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Eagle]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<DesertFieldEnemysプレハブ>
4番目に追加。

動作確認ok
------------------------------------------------

<戦闘に命中率を適用する>------------------------

計算的には、Speed値を使う
攻撃する側 / 攻撃される側 * 100 = ％をだす。
ランダム値をつかってその％より小さかったら命中
大きかったらmiss
と判断する。

(例)
攻撃する側のSpeed   6
攻撃される側のSpeed 2

6 / 2 * 100 = 300％
絶対あたる

攻撃する側のSpeed   6
攻撃される側のSpeed 7

6 / 7 * 100 = 85%ぐらい
でも1ステータスが違うだけでここまで下がるのは
良くないと思うから、
実際の数値に+10して95%にしたほうがよさげ

攻撃する側のSpeed   6
攻撃される側のSpeed 8

6 / 8 * 100 = 75%
これも+10して85%かな？

攻撃する側のSpeed   6
攻撃される側のSpeed 9

6 / 9 * 100 = 66%
+10で76%

攻撃する側のSpeed   6
攻撃される側のSpeed 10
70%

だいたい「数値の差が4以上」になると命中しづらい
かも

ただ、プレイヤー側にはボーナス入ってもよさそう。
Luckの値 * 5 を加算するとか

(例)
攻撃する側のSpeed   6
攻撃される側のSpeed 12
60%

攻撃する側のLuck 3
60 + (3 * 5) = 75%

こんな感じでいいかも

(結論)
命中率の計算方法は、
①攻撃する側のSpeed / 攻撃される側のSpeed
②①に*100をして％をだす
③ランダム値が％以下なら命中。

ただし、②の値に
キャラも敵も+10％の補正値を入れる

そしてキャラ側だけに
(自分のLuck * 5)％をプラスする。

100%以上は自動命中

<実際にコードに処理を追加する>
[ButtleMng.cs]
Set/GetSpeedNum関数を作成する。
speedNum_変数を用意する。

Set/GetLuckNum関数を作成する。
luckNum_変数を用意する。

[CharacterMng.cs]
SetDamageNum関数を呼び出しているところと同じ場所
でSetSpeedNum関数とSetLuckNumを呼び出す。

Hpdecrease関数の最初で命中計算をする。
※こっちでは幸運値を考慮しない

[Chara.cs]と[Enemy.cs]
Luck関数を作成する。

[EnemyInstanceMng.cs]
SetDamageNum関数を呼び出しているところと同じ場所
でSetSpeedNum関数とSetLuckNumを呼び出す。

Hpdecrease関数の最初で命中計算をする。

これで命中判定完成。
------------------------------------------------

<回避率について>--------------------------------

[CharacterMng.cs]
HPdecrease関数での処理。

命中判定時にLuckを使った回避判定を追加する。
Luckが10以下の時は10でランダム振って判定し、
10以上なら現在のステータスのLuckをそのまま使用する。

ランダムを振る範囲も0~100以下じゃなくて
「0~100-幸運値」にすることで、範囲を狭めて
成功しやすくする。

回避率は、キャラクター側にのみ実装してキャラの攻撃が当たらないことによるストレスを防ぐことにした

------------------------------------------------

<クリティカル率について>------------------------
クリティカルの特徴
・攻撃自動命中
・攻撃力up(2倍)

クリティカルの計算方法
回避と同じように0~100の上限を狭める
(100 - (10 + buttleMng_.GetLuckNum())とする)
ランダムの10以下を素のクリティカル値にする。
さらにここに幸運の値をそのままプラスする。

クリティカルではないときに、
命中判定と回避判定をするように設定しておく。

キャラと敵、それぞれのHPdecrease関数で判定する。
------------------------------------------------

<BombMonsterについて>---------------------------
速度は1のままで攻撃を必中にしたいからLuckを100に
する。
敵には回避判定をつけないからLuckを100にしても避けられる心配はない。

攻撃力を7にしておいてクリティカルで2倍ダメージだから7*2=14のダメージがキャラ側に入る
(ただし防御点を考えたら少し下がる)
14なら自爆として自分のHPも削り切れる

普通にdamage変数の入れる位置ミスしてた。
クリティカルダメージを通常ダメージで上書きする形で書いてしまってたから修正した。

------------------------------------------------

<戦闘中のキャラアイコンの顔部分を調整する>-------
ButtleUICanvas/UniCharaData/CharaIconFrame
の子として[MaskImage(Image)]を追加する。
whiteFrameMask.pngをImageにアタッチして、
コンポーネントにMaskをアタッチする。

MaskImageの子として[FaceImage(Image)]を追加する
FrameBackPanelは不要になったから削除する。

FaceImageには
事前に用意しておいたUniFaceIconをアタッチする。

大きさが全然うまくいかなかったのでサイズ調整！

[MaskImage]
Scale X:0.8 Y:0.8 Z:1

[UniFaceIcon]
Width:128 Height:99

同様にジャックの顔アイコンを調整していく。
[JackFaceIcon]
Width:112 Height:100

------------------------------------------------

<MPバーも追加する>------------------------------

HPSliderをコピペしてMPSliderという名称にする。
ついでにHPSliderの位置も再調整する。

[Uni(上側のバー)]
HP PosY 170
MP PosY 125

[Jack(下側のバー)]
HP PosY 120
MP PosY 75

どちらも□枠の丸角になってるところにぴったり
くるようにそろえる

[色の調整(MP)]
通常色
R:1 G:0.3 B:0.8

減った部分の色
R:0.5 G:0 B:0.4

[色の調整(HP)]
通常色
R:0 G:0.8 B:0.8

減った部分の色
R:0 G:0.3 B:0.5

このカラーリングは！ペルソナ！！

------------------------------------------------

<HPBar.csを変更する>----------------------------
HP専用じゃなくて、MPの減少処理もできるようにする

まずはScript名を変更する。

HPBar.csから、[HPMPBar.cs]へ
private intでつくっていたmaxHp_とcurrentHp_を
HPとMPのどちらでも使えるように
maxNum_とcurrentNum_に名称を変更する。

また、SetHPBar関数も[SetHPMPBar関数]へと
名を変更する。

[CharacterMng.cs]
現在はHPのSliderしか取得していないから
MPも取得しないといけない。

管理をcharHPMap_変数で行っているので、
最初にcharHPMap_という名前をcharaHPMPMap_に変更

DictionaryのHPMPBarの方をpairにする。
Item1->HP
Item2->MP
とする。

これによってでたエラーをItem1として対処する。

[Chara.cs]
MP関数とMaxMP関数を作成する。

現在はMPを使う処理がないから適当にテストで
削ってみる。okできた。
削るときには、

StartCoroutine(charaHPMPMap_[(CHARACTERNUM)num].Item2.MoveSlideBar(charasList_[num].MP() - 削る値));
という風に書く！

また、敵HP用のHPBarプレハブも設定が必要
ここまで作成したHPSliderをPrefabフォルダのプレハブと交換する。
※EnemyInstanceMngのEnemyHPBarがmissingになるか　らアタッチしなおす。
→敵側の数字が見づらかったから黒にした

------------------------------------------------

<HP/MPバーの近くに、現在数値を表示する>----------
現在数値はHPMPBar.csから取得できたほうが早いので
各Sliderの子として
[CurrentNum(TMP)]をアタッチする。

(共通部分)
黄色枠の大きさは3文字入る程度
※1個つくったらそれをコピペしていく
NewMplus1-Medium
FontStyle 太文字(B)と斜め(I)にチェックをいれる
FontSize  15

(HPの数値)
Pos X:30 Y:-3 Z:0

(MPの数値)
Pos X:30 Y:-3 Z:0

つくってみたらそれぞれの子にするから全部共通だったわ。。。

<現在数値を取得する処理>
<HPMPBar.cs>
private TMPro.TextMeshProUGUI currentNumText_; 
を作成する。

Start関数で[CurrentNum(TMP)]のFindをする。
Start関数とMoveSlideBar関数で
currentNumText_.text = currentNum_.ToString();
を呼ぶようにする。

数値が0以下になったら0で表示するようにしたい。
currentNum_が0以下は全て0になるように処理を追加
しておく。

------------------------------------------------

<敵選択のアイコンを変更する>---------------------
現在は球体にしているのでターゲットマークみたいな
丸いマークにしようと思っている

<表示方法の変更>
各HPの横に最初からButtleTarget.pngをつけておいて
必要に応じてactiveを切り替えるようにしたい。

[HPSliderプレハブ]
[TargetImage(Image)]を子としてアタッチする。
[TargetImage(Image)]
ButtleTarget.pngのサイズは100*100
Pos   X:70 Y:0 Z:0
Width:100 Height:100
Scale X:0.5 Y:0.5 Z:1

[EnemyInstanceMng.cs]
HPSliderを生成したときにEnemySelectObjの子にする

[EnemySelect.cs]
SetActiveを切り替えていた部分は
TargetImageの表示状態を切り替える用にする。

SelectKeyにMAXを用意して、
MAXのときはUpdateをreturnで抜けるようにする
※これがないと、コマンド選択で回転させるだけで
　ターゲットマークが表示されてしまうから
　→SetActive関数でMAXやNONに切り替える
初期設定をMAXにしておく。

また、Update内で常に回転させるようにRotateの
処理を追加する。

Findが大量に発生したからこれを直していく。
数が最初から決められないのでListをつかう。
targetImageObjList_変数を作成しFindを使っていた部分を全てこの変数で処理するように変更する。
最初の登録部分はSetPosList関数でおこなう。

------------------------------------------------

ここまでのUI内容をForestFieldにも適用する
した。


<バトル位置を変更する>--------------------------
[ButtleCamera]
Pos X:4 Y:2.6 Z:27.7

[ButtleWarpPointPack]
Pos X:0 Y:0 Z:28.2

[EnemyInstancePointPack]
Pos X:0 Y:0 Z:31.2

更新するときはDesertFieldごと更新する
------------------------------------------------

<フィールド毎に対応した敵が生成されるようにする>-
[FieldMng.cs]
SceneMng.SetNowScene(SceneMng.SCENE.FIELD0);
をやめて、

SceneMng.SetNowScene((SceneMng.SCENE)UnityEngine.SceneManagement.SceneManager.GetActiveScene().buildIndex);
とする。

また、Start関数でメインカメラをアクティブにする
処理を追加しておく。

[EnemyInstanceMng.cs]
enemyData_にデータを取り出すところで
(int)SceneMng.nowScene - (int)SceneMng.SCENE.FIELD0
とし、対応フィールドの番号を取り出せるようにする

------------------------------------------------

<敵の弱点を設定する>----------------------------
属性を設定する
Weakという項目を追加する。

項目に入れるのはBag_Magic.csの
ELEMENT_KINDのenum数値を入れる。
(例)
炎なら0
水なら2
とかとか。。。

<EnemyList.cs>
<Enemy_importer.cs>
に項目を追加する。

<CharaBase.cs>
<Enemy.cs>
にWeakを追加する。

[EnemyInstanceMng.cs]
HPdecrease関数で自分の弱点属性を確認する
※ここで攻撃側の属性と一致してたらダメージ量を
　倍にするようにしたい

------------------------------------------------

<戦闘の画面上に魔法画像を表示してみる>-----------
攻撃するときに魔法コマンドを選択したとき、
まずは画面上に設定している魔法画像が表示される
ようにする。
画像情報はItemBagMng.csに入っている。
※ItemBagMng.csはDontDestroyCanvasのItemBagMng
  にアタッチされている。

[CharacterMng.cs]
itemBagMng_変数をpublicで作成して、
外部アタッチでDontDestroyCanvasのItemBagMngを
入れる。
(private変数でfindしようとしたらエラー出た)

[ItemBagMng.cs]
GetImageTest関数を作成して
中でSpriteをreturnするように処理をいれる
※まずはmagic0のほうだけ

<表示先を準備する>
ButtleUICanvasの子として
[SetMagicObj(空のオブジェクト)]を追加する。
更にその子として
[Magic_0(Image)]を追加する。
それを複製して_3までつくる。

[SetMagicObj(空のオブジェクト)]
Pos X:0 Y:-400 Z:0

[Magic_0]
Pos X:0   Y:130 Z:0
[Magic_1]
Pos X:110 Y:-15 Z:0
[Magic_2]
Pos X:-110Y:15 Z:0
[Magic_3]
Pos X:0   Y:-95 Z:0

※これでSetMagicObjを中心で、コマンドと同様に
　回転させられる。

[CharacterMng.cs]
magicImage_変数をImageの配列で作成する。
最大設定数は4のため、配列で4としておく。
for文で回して、FindでSetMagicObjの子のImageを入れる。

あとは、魔法コマンドのところで
magicImage_[0].sprite = itemBagMng_.GetImageTest((int)nowTurnChar_);
とする。

これでMagic_0のところには魔法画像が入れられた。
同じ画像をとりあえず3まで全て設定する

<魔法コマンドが選択されるまでSetMagicObjを
 非表示にしておく>
setMagicObj_変数を作成してfindしておく。
設定した後は魔法コマンドを選択するまで
SetActive(false)にしておく。

switch文のMAGICのところでSetActive(true)とする。

<魔法コマンドが選択されているとき>
コマンドを回す処理はそのままにして、
魔法も選択できるように回転させたい
※コマンドは回せるけどAttackとかGuardとかは
　選べないようにしたい

setMagicObj_.activeSelfをみて、
falseならコマンド選択へ
trueなら使用する魔法選択へわけるようにする

SetMagicObjにImageRotateをアタッチしておき、
最初はenableをfalseにしておく。
そしてswitch文のMAGICのところでenableをtrueにする
これで画像を一緒に回転させられるようになる。
※あとはコマンド順をMagic_番号と同様に扱えれば
　いい
！注意点として、魔法コマンド位置をATTACKとみるか
　ら、SetMagicObjについているImageRotateの
　nowCommandを参考にしないといけない。というとこ

現在魔法コマンドのときに、
GetNowCommand - 1の値を取得して
それでChara.csのGetMagic(新規作成予定関数)から
引っ張りだしてきたら良さそう。

<Magicの情報取り出し部分を作成する>
[CharaBase.cs]
Magic0～4と個別のintになってるところを配列にする
objNum==0のif文の中で配列の初期化をする

[ItemBagMng.cs][Chara.cs][MenuActive.cs]
[SaveCSV.cs]
配列に直してエラーが出ているところを修正する。

[CharacterMng.cs]
charasList_[(int)nowTurnChar_].GetMagicNum(tmp);
と記述して情報がとれるか確認する。
→0とかしか入らないからよくわからない。

<データをロードしたときに、画像情報が入るように
 しないといけない>
今はステータス画面を開くまでequipMagic_変数に
画像情報が入らないからステータス画面を開かないで
始めた戦闘時にエラーがでる。
これをロードしたときのも画像情報が入るように修正
してもらう。


------------------------------------------------

<魔法コマンドから通常コマンドに戻る処理の作成>---
[CharacterMng.cs]
switch文のMAGICのところにselectFlg_での判定を追加する。falseだった時に前キャラの行動が終わっていたら画像を表示して回転させられるようにしておく。

Tキー押下&&selectFlg_がtrueのときに呼ばれるif文の中にsetMagicObj_がactive状態のときにはfalseに切替て回転のenableもfalseにするように条件を追加する。

ただこれだと、土台になる回転画像も非表示にされちゃうからImageRotate.csのSetRotaFlg関数を修正する必要がある

これだけでは非表示は直らなかった。
親であるCommandオブジェクト部分の表示/非表示の
切替をButtleMngでselectFlg_の状態をみて
管理しているからだ。
→ImageRotate.csのSetRotaFlg関数で全部管理した方
　が都合がよさそうだから変更する。

transform.parent.gameObject.SetActive(active);
としてCommand部分が切り替えれるようにする。

-----------------------------------------------

<防御コマンドで変なアクションが発生するバグ>-----

Defence関数内でアニメーションを呼び出しちゃってる
からこうなる。
引数でboolをいれてtrue,falseを設定できるようにしておこう。

[CharacterMng.cs]
防御数値が使用前に0に戻されてる。
原因は、防御コマンド後にすぐIDLEへ行き、
ジャックの次にユニに回されてそこで0に戻している
から。
→防御コマンド以外をクリックしたときに行動中の
　キャラの防御力upを0にするように処理を移動させる

------------------------------------------------

<魔法画像の取得方法を変更>----------------------
GetImageTest関数の場所を、
[ItemBagMng.cs]から[Chara.cs]に変更する。

[Chara.cs]
内容はset_Magic[num]が0なら装備無しだから
nullをreturnし、
それ以外ならItemImageMng.csからspriteMapを呼び出して画像をreturnする。

また、CheckMagicNum関数を作成してMagicの指定配列部分を返すようにする。0未満4以上だったらfalseを返して範囲外エラーとする。

[CharacterMng.cs]
nullを検出したら画像部分を透過する
ように設定する。

CheckMagicNum関数は画像描画のときにif文でtrue/falseを確認するようにしておく。

<ロード時にdataに情報を取得できるようにする>
MenuActive.csにBag_Magic.csのfind処理をかいて
DataLoad関数内にBag_Magic.csのDataLoad関数呼び出すようにした。

------------------------------------------------

<魔法情報でいろいろ>----------------------------
キャラが装備している魔法情報を取得するように処理を入れてみる。

<magicData.csvを書き換える>
元データ
Number,Name,Power,Rate,Head,Element,Tail,Sub1,Sub2,Sub3
0,Error,-1,-1,-1,-1,-1,-1,-1,-1
1,複数回水大,100,5,1,3,2,0,0,0
2,単体補助極大,100,5,0,1,3,0,0,0

変更後データ
Number,Name,Power,Rate,Head,Element,Tail,Sub1,Sub2,Sub3
0,Error,-1,-1,-1,-1,-1,-1,-1,-1
1,単体炎小,15,5,0,2,2,0,0,0

[CharacterMng.cs]
CheckMagicNum関数でtrueだった時に
GetMagicNumから情報をとってくるようにする。
→無事に情報を取得することはできた

魔法の情報をいろいろ取り出して使うのに、
CharacterMng.csでやってたら肥大化してしまう。
→新しい別のScriptを作成する。
※関数オブジェクト的なのにする

新規Scriptで[CharaUseMagic.cs]を作成。
非アタッチのスクリプトとする。

[CharacterMng.cs]
private CharaUseMagic useMagic_;
を作成してStart関数内でnewする。
で、使用する魔法を決定したときに
CharaUseMagic.csのCheckUseMagic関数を呼び出すようにする。

攻撃対象の決定時にはswitch文のMAGICの
if(!selectFlg_)のelse側に入るからそれで
攻撃対象が取れるはず。

[CharaUseMagic.cs]
CheckUseMagic関数で使用する魔法の情報を受け取ったら、まずはその魔法が
「単体」か「複数回」か「全体」かを見る。
switch文で分けるようにする。

①単体だったとき
敵を指定する処理をする必要がある。
GameObjectのFindをつかって、
EnemySelect,ImageRotate,SetMagicObjの処理を
入れる。

②複数回だったとき
敵選択マークを、敵全員表示にしたい
※ただし攻撃は誰に何回あたるかはわからない状態

AllSetActive関数を呼び出す。

[EnemySelect.cs]
AllSetActive関数をつくったほうがいい。
回復のときは用に敵選択マーク消すこともありそうだから。

AllSetActive関数
引数のフラグをみて敵選択マークを全て表示/非表示
を切り替えられるようにする。

③全体だったとき
敵選択マークを、敵全員表示にしたい
AllSetActive関数を呼び出す。

<全部の敵選択マークを表示時にバグ発生中>
・円が1つしか回転しない
→EnemySelect.csのselectNum_が1つしか設定できな
　い仕組みにしているから。

[EnemySelect.cs]
攻撃が単体なのか全体or複数なのかをboolで分けるようにして、全体or複数なら全ての敵選択マークが
回転するようにする。
private bool allSelectFlg_;を作成。
切替をSetActive関数でfalse,
SetAllActive関数でtrueとしておく。

Update関数でallSelectFlg_の状態をみて、
trueならfor文でtargetImageObjList_のRotateを回す
falseの方には今までの処理を全部突っ込んどく。

これで複数or全体のときには全ての敵選択マークが
回転するようになった。左右キー操作は無効にした。

<使用する魔法が回復かその他かを判断する>
[CharaUseMagic.cs]
CheckUseMagic関数でヘッド情報を見る前にしたほうが
よかったわ。
element情報を見て、回復が0だから0かそれ以外かで
if文を使って判断する。

①回復系
敵選択マークを非表示にして、それ以外のコマンド系も非表示にしておく。
※とりあえずこれだけ

②攻撃系
上の方に書いてるヘッドワードの種類分けをこっちに
つっこむ

<攻撃対象の情報を渡す>
CharaUseMagic.csの返り値を使って、
CharacterMng.csに攻撃対象の情報を渡すようにする。

EnemySelect.csのGetSelectNum関数を呼び出すだけで
単体でも複数でも全体でも攻撃対象を渡せるようにしたい。

[EnemySelect.cs]
GetSelectNum関数で配列を返すようにする。

allSelectFlg_の状態を見て
falseなら今まで通りselectNum_+3つ空白を返す。
trueなら「複数」ならランダムで選んだ4つの番号配列
「全体」なら0,1,2,3で空白部分があるなら空白ありの
配列番号を返すようにする。

複数か全体かを判断するために
randFlg_を新規で作成する。SetAllActive関数に引数を増やす。

[CharacterMng.cs]
通常攻撃の処理をしているところは単体しか攻撃ないので
weaponTagObj[i].
GetComponent<CheckAttackHit>().
SetTargetNum
(buttleEnemySelect_.GetSelectNum()[0] + 1);
とする。

<魔法の威力や属性の受け渡し、消費MPの処理を行う>
[CheckUseMagic.cs]
攻撃時の処理をつくる。
①威力をButtleMng.csに渡す
GameObject.Find("ButtleMng").GetComponent<ButtleMng>().SetDamageNum(magicData.power);
とする。

②属性をButtleMng.csに渡す
ButtleMng.csにGet/SetElement関数を作成しておき、
GameObject.Find("ButtleMng").GetComponent<ButtleMng>().SetElement(magicData.element);
とする。

※ついでに速度と幸運をCharacterMng.csのelse処理で
　渡すように書いておく。

③キャラ毎にもっているMPを減少させる
新しい関数をつくって返り値として減少させる
MPを返すようにする。
→MPdecrease関数

[CharacterMng.cs]
StartCoroutine(charaHPMPMap_[nowTurnChar_].Item2.MoveSlideBar
 (charasList_[(int)nowTurnChar_].MP() - useMagic_.MPdecrease()));
と、
charasList_[(int)nowTurnChar_].SetMP(charasList_[(int)nowTurnChar_].MP() - useMagic_.MPdecrease());
という処理をelse側に追加する。

[Chara.cs]
SetMP関数を追加する。

<攻撃対象の決定>
switch文のMAGICのif(!selectFlg_)のelse側処理を
書いていく。
buttleEnemySelect_.GetSelectNum();を呼ぶだけで
intの要素数4の配列が返ってくるからそれを見て攻撃
を発生させる。


<ここからしばらくは単体炎の魔法の話>
まずはエフェクトを用意する。
単体炎として、KY_effectsのframeBallを使う。
<frameBallの設定>
複製してResourcesフォルダに入れる
※新規でMagicPrefabsというフォルダをResourcesの中に作成して、そのなかにframeBallのプレハブを入れる

タグをWeaponにして、
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
MagicMove.csとCheckAttackHit.csを付ける

このframeBallを、炎単体時にResourcesフォルダから
呼び出して再生すればよい。はず。。。
→改良するときは魔法設定の時点でResourcesから
　取り出して準備しとく感じにしたい。
　※毎回Resourcesから探したくないから

<キャラを攻撃状態に遷移させる>
[EnemySelect.cs]
GetSelectEnemyPos関数の引数にintを用意して、
指定した敵の座標がとれるようにする。

[CharacterMng.cs]
MagicAttack関数を作成してMAGICのelse側で呼び出す
ようにする。

MagicAttack関数の中でCharaUseMagic.csの
MagicEffect関数を呼び出す。
引数で敵座標とキャラ座標と敵番号を受け取る。
処理内容はCharacterMng.csの
AttackStart関数と似てる。

とりあえずいまは固定でframeBallが呼ばれるようにする。
[CheckAttackHit.cs]
削除条件にframeBall(Clone)も追加しておく。

frameBallが
明るすぎて砂漠だと見えない！！！
→frameBallのTintColorのα値を1.0にしたら多少は
　ましになった。

<固定でframeBallにしているところを修正する>
プレハブ名と「炎」「小」を一致させる必要がある
「炎」「小」の部分を数字として扱って、
プレハブ名も数字にしてしまえばいけるかも。

(例)
「炎」-> 2
「小」-> 0
だから、「frameBall」という名前を「2-0」にする。
これなら番号で判断がつく！
※注意として_アンダーバーではなく、
　-ハイフンだよ

数字に直してCharaUseMagic.csのMagicEffect関数の
処理を書きなおす。
→魔法が敵に当たって敵が消滅するところまで確認！

<1回魔法を使用したら次のキャラor敵の行動に移す>
MAGICでanim_をNONにしておいて、
MagicAttack関数の最後の部分でIDLEにする。

ジャックがアニメーションをしないで戻ってくるバグ
→原因はdata.csvのJackのアニメーション部分が0に
　なっていたから。1に修正しとく。

敵のExcel情報の弱点属性番号を修正する。
炎が2
水が3

<複数と全体も確認する>
<他の魔法も作成する>
明日からがんばろ

------------------------------------------------

<2体目を倒そうとしたらバグ>---------------------
敵のHPBarを削除しているのが原因

[EnemyInstanceMng.cs]
HPdecrease関数で、
Destroy
(GameObject.Find(enemyList_[num].Item2.name));
をしているのがダメっぽい。

ここではSetActiveを切り替えるだけにしておいて、
あとから削除しよう。
DeleteEnemy関数に削除処理をついかしとく。

対処終了。
------------------------------------------------

<敵が自爆した後に戦闘終了にならない>-------------
CharacterMng.csのIDLEでやってる
lastEnemytoAttackFlg_ = !buttleEnemySelect_.ResetSelectPoint();
が呼ばれてないのかも。

<対処法>
[ButtleMng.cs]
SetMoveTurn関数で
lastEnemyFlg_ = characterMng_.GetLastEnemyToAttackFlg();
という処理を入れるようにして、行動対象が入れ替わる毎に、敵の状態を調べるようにする。
そしてユニ達キャラ側に行動が回ったときに
lastEnemyFlg_がtrueなら戦闘終了処理に入るように
する。

対処終了。
------------------------------------------------

<ボスを作成する>--------------------------------

<強制戦闘処理>
フィールド右奥に強制戦闘の壁を設置する。
ButtleWallの子の番号を[4-1]にする
(クエスト番号 - 配置番号だから)
[4-1]
Pos       X:20.5 Y:0  Z:46.5
Rotation  X:0    Y:90 Z:0
Scale     X:18   Y:10 Z:1
→壁に当たって戦闘になるところまではできた

<データ作成>
名前を[WaterMonster]とする
WaterMonster,6,60,5,10,1,4,8,4,1,200,150,1.5	WaterMonster,2
これでreimportしとく。

<実際のモンスター確認>
使用するのは猫耳ありのコートありバージョン
それ以外のSceneは今のうちから消しとく。

<アニメーションについて>
既存のアニメーターは削除して、他からコピペして
[WaterMonster]とする。
中身のアニメーションを入れ替える。

<モデルにつけるコンポーネント>
本体の名前を[Boss_4]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[WaterMonster]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<強制戦闘時に出現するように設定する>
[4-1]にアタッチしているForcedButtle.csの
EventEnemyにいま作成したWaterMonsterを入れる。

攻撃後に戻る位置がおかしい？
宙に浮く
[EnemyInstanceMng.cs]
MoveToInitPos関数で戻る座標を設定しているところが
Y軸が0.5fになってて空中へ戻るようになっていた。
→y軸を0にした値を使うようにへんこう

処理終了。

------------------------------------------------

<戦闘中にメニューが開けるバグ発見>---------------
[MenuActive.cs]
Tabの許可をするのに、
現在がバトル中であるか確認してバトル中でなければ
開けるようにする。
修正終了。
------------------------------------------------

<ボス撃破時に水のワードをドロップするようにする>-
Enemy.xlsのDropに[ワード「水(エレメント)」]
と追加しておく。
ドロップ処理は峯担当です。

------------------------------------------------

<ボス前の会話必要かも>--------------------------
フィールドに入ったときにジャックとの会話をはさむようにしたい。

体が水でできたモンスターが現れるという情報
エレメントワードを取り込んだ可能性が高い
倒そう！みたいな。

<Chapter.xls>
Chapter13を追加。
会話内容をとりあえず書く。

<Chapter_importer>
"13"を追加する。

<FieldMng.cs>
進行度が13のときにはchapter13の会話を発生させる

<砂漠っぽい画像を追加する>
会話時の背景画像として使用する。
AssetStreamingフォルダに[Desert.png]として追加

Chapter.xlsにも背景画像部分にDesertと入れる

------------------------------------------------

<魔法処理の作成パート2>-------------------------
[複数単体小]をつくる。
使用するのは[2-0]のやつ
データは
1,複数炎小,15,10,1,2,0,0,0,0

[CharaUseMagic.cs]
MagicEffect関数がこのままだとうまくいかない。
Weaponタグで探したときに、frareBallが全て
2-0(Clone)という名称だから、SetTargetNumで全て
同じ敵しか狙えなくなる。
→タグで比較したあとに名称を変更したほうがいい
※名称を変更するとCheckAttackHit.cs側で削除
　判定ができなくなるからそこの修正も必要

名称を[2-0(Clone)-生成順の番号]とかにしたい。
MagicEffect関数の引数を増やして数字をとってくる。

[CheckAttackHit.cs]
直値で"2-0(Clone)"と書いてるところを何とかしたい

// キャラの魔法エフェクトの削除
private string charaMagicStr_ = "";
を用意して、Set関数もつくる。

CharaUseMagic.cs側で
weaponTagObj[i].GetComponent<CheckAttackHit>().SetCharaMagicStr(weaponTagObj[i].name);
として削除対象とする。

これでいけそう。

<すでに倒した敵に攻撃が当たるときにエラーがでる>
非表示にするからGameObject.Findで見つけられなく
なっているから。
→ダメージ判定の前に、HPが0を下回っていたら
　処理を抜けるようにしよう

[EnemyInstanceMng.cs]
HPdecrease関数の最初で、
// すでにHPが0を下回っていたら処理を抜ける(魔法攻　 撃連続ヒット用のガード処理)
if (enemyList_[num].Item1.HP() <= 0)
{
    return;
}
という処理を付け加える。
これでガード処理ができた。

<敵が同時に死亡したときに戦闘終了状態にならない>
ButtleMng.csのSetMoveTurn関数で書いてる
GetLastEnemyToAttackFlgがうまく更新されてない？
更新のタイミングが、敵の消滅前になっているから

(対処法)
[CharacterMng.cs]
IDLEに切り替わると敵の死亡処理の判定を行うので、間を開けるようにコルーチンで調節する
MagicAttack関数の中で
StartCoroutine(ChangeIDLETiming());
を呼び出すようにする。

ChangeIDLETiming関数
テストとして5秒間待ってから
anim_をIDLEに切り替えるようにする

これで敵の死亡処理までの時間を空ける事ができる。

<複数回攻撃の時は、魔法の生成に時間を空ける>
同じ敵を狙う弾同士が被っちゃって見えなくなるから
どうにかしたい。

[CharaUseMagic.cs]
structでMagicAttackInfoを用意する。
また魔法生成用のリストも用意する
リスト内容は(bool,MagicAttackInfo)とする。

InstanceMagicInfo関数を作成して、
引数で魔法の発動元や発動先の情報を受け取って
リストに設定する。
→この関数はCharacterMng.csから呼び出す

コルーチンを作成して、リストのboolが全てtrueに
なるまでwhile文を回すようにしておく。
発動時間になったら発動処理をいれてリストのboolを
trueにする
→一度trueになった魔法は発動しないようにif文を
　つけておく
→このコルーチンもCharacterMng.csから呼び出す

これで複数回攻撃の魔法生成を時間差で発動するようにできた。

------------------------------------------------

<魔法処理の作成パート3>-------------------------
[全体単体小]をつくる。
データは
1,全体炎小,15,15,2,2,0,0,0,0

全体魔法は、できれば全部同時に発生させたい。
[CharaUseMagic.cs]
headNum_変数を作成して、CheckUseMagic関数で
値を保存するようにしておく。

InstanceMagicInfo関数でheadNum_が1だったら
instanceTime = instanceNum * 0.2f;とし、
それ以外の全体や単体なら0.0fとなるように処理を
分ける。

これで同時に発生させることができた。

------------------------------------------------

<CharaUseMagic.csにInit関数を作成する>----------

CheckUseMagic関数でFindを使ってテストしていた部分をInitにまとめて事前取得するように変更する。

Init関数の呼び出しはCharacterMng.csで行う
→ButtleSetCallOnce関数内で呼び出す

------------------------------------------------

<「複数回」の攻撃回数をランダムにする>-----------

2～4回攻撃にしたい。
[EnemySelect.cs]
GetSelectNum関数で、複数回の処理をしている場所に
int randAttackNum = Random.Range(2, 5);
を追加する。
→2以上5未満の値がランダムででる

この値を利用してfor文を回すようにする。

------------------------------------------------

<炎以外の魔法の[小]を作成していく>---------------
水魔法について
水柱を打ち上げるやつを使う
サンプルは下記のサイトからダウンロードした↓
https://ktk-kumamoto.hatenablog.com/entry/2018/02/27/150229#google_vignette

eff_splash_sampleフォルダをインポートした。

[小]の感じを出すために威力を控えめに調節しなおして[3-0]と命名してResourcesフォルダに入れる。

[3-0]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を13にしておく。

データは
1,単体水小,15,7,0,3,0,0,0,0

魔法を生成したときにRotationのX軸が-90度になるようにしないといけない。
今はインスタンスの時に
Quaternion.identityを使っているから-90度にならない感じがする。

obj.transform.rotationをidentityのところにいれるようにして、プレハブ自体の回転を基に生成するように変更する。

単体での確認完了。

1,複数水小,15,10,1,3,0,0,0,0
複数での確認完了。

1,全体水小,15,15,2,3,0,0,0,0
全体での確認完了。

ここまでで、水の小は完成。

土でいいのが見つからなかったから先に風をやろう↓
https://ktk-kumamoto.hatenablog.com/entry/2018/01/18/222653

インポートしたら[eff_wind_sample]フォルダが増えるからsplashフォルダと合わせて[Effect]フォルダにいれる。

<風小魔法>
データは
1,単体風小,15,7,0,5,0,0,0,0
大きさ調整は必要そうだからやって、
魔法の設定をしていく。
[5-0]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を10にしておく。

単体風小の確認完了。

1,複数風小,15,10,1,5,0,0,0,0
複数風小の確認完了。

1,全体風小,15,15,2,5,0,0,0,0
全体風小の確認完了。

これで風小魔法は終了。

<土小魔法>
https://ktk-kumamoto.hatenablog.com/entry/2018/02/01/214331
上記のやつが氷なのでこれを岩っぽくアレンジしたい

インポートするとeff_icewall_sampleフォルダが作成されるので、Effectフォルダに移動させた後、
名前を[eff_rock]とする。

色変更をお願いしてからsolid.pngを使うように修正
あとは他のparticle色も土色っぽく変更した。

プレハブをunpackにしておいて名前を[4-0]とする。
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を10にしておく。

データは
1,単体土小,15,5,0,4,0,0,0,0

この土魔法の場合、アニメーションの再生が完了して
から削除するようにしたほうがよさそう。

[CheckAttackHit.cs]
このScriptがアタッチされているオブジェクトの
先頭の文字が[4](=エレメントが土)のときは、
Destroyをアニメーション終了まで待機する。としたい

ハイフンで文字を区切ったときに[4]が先頭数字なら、
Destroyは呼ばないようにする。
→アニメーション終了時間になれば、MagicMove.csの
　Update関数で消してくれるから。

その代わり、敵にぶつかったときにそれ以上移動しないようにMagicMove.csのPowerを0にしたい。

[MagicMove.cs]
MoveStop関数を用意して、
CheckAttackHit.csの土魔法だったときに呼び出すようにする。

関数が呼ばれたらmoveStopFlg_をtrueにして、
FixedUpdate関数でflgがtrueなら

rigid.velocity = Vector3.zero;
rigid.angularVelocity = Vector3.zero;
を呼び出すようにした。
→ユニちゃんの慣性止めるやつと同じ

これで岩を止められる！

単体土小確認完了。

1,複数土小,15,10,1,4,0,0,0,0
複数土小確認完了。

1,全体土小,15,15,2,4,0,0,0,0
全体土小確認完了。

------------------------------------------------

※EffectFreeの中身が全部ピンクになってるから
　入れなおしたほうがいいかも
　→そもそも使わない可能性ある？かも

<ボスを倒したら達成報告ができるようにしたい>-----

討伐対象につけるScriptを新規で作成する
→KnockDownEnemy.cs

KnockDownEnemy.csをWaterMonsterのところにつける
(Weaponタグがついているところ)

このScriptをアタッチしている対象が非表示になったらクエスト達成状態かを確認する処理をいれたい。
→OnDisable関数というのでできそう。

※今後、ボス系の討伐クエストクリア処理には
　このScriptを使う。

<ボスの名前を変更する>
カボスを[Field0Boss_4]にして、
水猫ちゃんを[Field1Boss_4]にする
→特に意味はないけどわかりやすくするため。

<ギルドで依頼を受けるところからデバッグをする>
HouseInteriorMng.csでエラーがでる。
menuRect_がnullになる。
→原因は、会話シーンからギルドに戻ってきて
　DontDestroyCanvasのMenuが非表示状態になるから
　取得できなくなってる

[HouseInteriorMng.cs]
ExitButton関数の中で、バッグの表示処理を

var tmp =
GameObject.Find("DontDestroyCanvas").
GetComponent<RectTransform>();

for(int i = 0; i < tmp.childCount; i++)
{
  if(tmp.GetChild(i).gameObject.name == "Menu")
  {
     tmp.GetChil(i).gameObject.SetActive(true);
     break;
  }
}
としてする必要がある。

DontDestroyCanvas自体は非表示になっていないから取得ができ、その子供を検索して非表示状態のMenuをFindし、表示に切り替えるようにする。
めんどくさい書き方だけどしょうがない。

<シーン遷移する前のシーン情報を使ってMenuのオブジェクトを表示/非表示切替用としていたのを修正>
MenuActive.csで行っていたMenuオブジェクトの非表示処理をSceneMng.csで行うようにした。
これによりnowSceneが切り替わった後で表示設定ができるようになったためエラーを修正できた。

------------------------------------------------

<達成報告後に会話をはさんで、それ以降はオアシス
 を表示状態にする>------------------------------

達成報告後にChapter14で会話を入れてそこで
進行度を15にする。

FieldMng.csで進行度が15以上で
現在のマップがFiled1(=DesertField)なら、
FindでOasisオブジェクトを探して表示状態に変更する

[FieldMng.cs]
if((SceneMng.nowScene == SceneMng.SCENE.FIELD1) && EventMng.GetChapterNum() >= 15)
{
  全てのFieldMapオブジェクトをtrueにする
  var tmp =
  GameObject.Find("FieldMap").transform;
  for (int i = 0; i < tmp.childCount; i++)
  {
     tmp.GetChild(i).gameObject.SetActive(true);
  }
}

<達成報告後会話を作成する>
Chpter.xlsにChapter14を追加する。
[Chapter_importer]
"14"を追加。reimportする。

[Guild.cs]
GuildQuestEvent関数で
報告タイミングのswitch文にcase 14
questNum == 4ならChapter14の会話を発生させる
ように処理を追加する。

これで会話を発生させられるようになった。

------------------------------------------------

<中威力の魔法を作成する>------------------------

<火>
データは
1,単体火中,15,18,0,2,1,0,0,0

エフェクトのプレハブ名は[2-1]とする。

[2-1]
まず、そもそものサイズを大きくしたい。
→ParticleSystemのStartSizeを[3]にする。
※コライダーのサイズは変えない

見づらい対策としてDurationを0.2にする。

KY_Effectフォルダにある[ErekiSmoke]をとりだして
円状に広がるようにする
→ちょっとバチバチした感じの火の玉ができた
これで完成とする。

単体魔法確認完了。

1,複数火中,30,25,1,2,1,0,0,0
複数魔法確認完了。

1,全体火中,30,30,2,2,1,0,0,0
全体魔法確認完了。

<水>
データは
1,単体水中,15,18,0,3,1,0,0,0

エフェクトのプレハブ名は[3-1]とする。

今、水小に使っているのを中にして
水小の方をアクアエッジっぽくしたい
平べったいやつテイルズの。
ShapeをCircleにしてそれっぽく変更して確認完了。

水中も昨日確認したやつのままだから[3-1]にして終了

1ヶ所だけ変更！
splash_subのGravityModifierを[0]にする
→重力の影響を受けないようにした(小中両方とも)

<土>
データは
1,単体土中,15,18,0,4,1,0,0,0

単純に大きくするだけでよさそう。
[4-1]
ScaleをXYZ全て3にする。
BoxColliderまで大きくなってしまうので、
BoxColliderのXYZは全て0.5にする。

単体土中の確認完了。

1,複数土中,20,25,1,4,1,0,0,0
複数の確認完了。

1,全体土中,25,30,2,4,1,0,0,0
全体の確認完了。

<風>
データは
1,単体風中,15,18,0,5,1,0,0,0

KY_effectsのGreenCoreを使う。
複製して[5-1]にする。
[5-1]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を10にしておく。

葉っぱを大きくするためにKYdustBの
StartSizeを0.5にする
また広がる半径も狭くするためにStartLifetimeも0.5


色が薄くて見えねぇ
→Shaderを、[LegacyShaders/Particles/AlphaBlended]にしたら
見えやすくなった。
元は[LegacyShaders/Particles/Additive]
みたいなやつ

あとはこれも土のやつと同じようにぶつかってもすぐ
消えないようにする。
[CheckAttackHit.cs]
アニメーション終了まで待機するif文条件に
風魔法の中もor条件として追加してきた。

アニメーション終了の終了条件を先に満たしてしまうので爆発エフェクトが発動しないことになってしまった。だから5-1のSubEmitterにKYexplosionを追加して
常に爆発+葉っぱになるようにした。

葉っぱの色を白にしてShaderを元のAdditiveにした。
(爆発色が緑だから)

単体の確認完了。

1,複数風中,20,25,1,5,1,0,0,0
複数の確認完了。

1,全体風中,25,30,2,5,1,0,0,0
全体の確認完了。

Shaderのやつ炎にも修正として使えそう！
→使ってみたら黒黒こげ焦げになったので却下

------------------------------------------------

<大威力の魔法を作成する>------------------------
小中とは違って、でっかい魔法をドーーンかな
でも極大もあるから少しは改善の余地を残しとくべ

<火>
KY_effectsのfireShotを使う。
(極大はHovlStudioの中のfireにする)
複製して[2-2]とする。

データは
1,単体火大,35,28,0,2,2,0,0,0

[2-2]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

なぜか一瞬で消える。。
2-2のSubEmittersをCollisionのframesにしておいて
火種が当たったらframesの延焼がでるようにした。

Collisionについて
LifetimeLossを0にする
MinKillSpeedを0にする
RadiusScaleを1.5にする

また、framesの方のStartSizeも1.5にする。
あとTransformのRotationのX軸を90にしておく。

大威力以上はアニメーション終了まで待機するように
CheckAttackHit.csに書いておく。

最初から敵の頭上にエフェクトを出すようにしたい。
[CharaUseMagic]
大威力系の攻撃魔法は、最初から敵の頭上に来るようにインスタンスさせる。

InstanceMagicCoroutine関数の中で、
(int.Parse(magicPrefabNum_.Split('-')[1]) == 2)
というif文を追加して、2ならば威力が大だから
adjustPosをenePosで入れるようにする。

当たり判定が発生しない。
BoxColliderが上空に静止したまま。
[2-2]の発生位置がY軸で5だから
BoxColliderのCenterのZ軸を5にする。
これで最初から地上の敵位置にBoxColliderを設置できるようになった。
→当たり判定されてもアニメーション終了まで待機だ　から問題ない

単体の確認完了。

1,複数火大,35,35,1,2,2,0,0,0
複数の確認完了。

1,全体火大,35,45,2,2,2,0,0,0
全体の確認完了。

<水>
データは
1,単体水大,35,28,0,3,2,0,0,0

もともとの規模のeff_splashを複製して[3-2]にする
[3-2]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

そのままの勢いだと隣の敵まで水かかっちゃうから
ちょっとだけ威力弱めないと・・・
全体的に規模を1/2にしてok。

単体の確認完了。

1,複数水大,35,35,1,3,2,0,0,0
複数の確認完了。

1,全体水大,35,45,2,3,2,0,0,0
全体の確認完了。

<土>
データは
1,単体土大,35,28,0,4,2,0,0,0
上から岩ゴロゴロみたいな？

新しくParticleSystemを作成して、
上から下へ降らせたいから
RotationのXを90にする。

岩の形にしたいのでRendererの
RenderModeをMeshにして[Rock_6]をいれた。

マテリアルはIceのやつ(Iceって書いてるけど中身岩)
あとは発生位置をCone型にしておいて範囲を狭める。

複数生成されるようにEmissionを若干調節
また岩の大きさもすこしランダム性をだして
StartSizeを0.25～0.5にした。

地面にぶつかったときに欠片を飛ばすように
Ice_breakを子にしておき、
CollisionとSubEmittersを有効にする。
→SubEmittersにIcs_breakを入れる。
だいたいこんなもん？

[4-2]
Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

BoxColliderは、高さを5にしてるからZ軸のCenterを
5にしておく。
※ちょっと攻撃タイミングとHP処理がずれちゃう

単体の確認完了。

1,複数土大,35,35,1,4,2,0,0,0
複数の確認完了。

1,全体土大,35,45,2,4,2,0,0,0
全体の確認完了。

<風>
https://ktk-kumamoto.hatenablog.com/entry/2014/10/13/101719
上記のサイトにある竜巻を使うことにする。

https://github.com/ktkkumamoto/UnityEffectSample
上記のgithubバージョン(他のエフェクトも多数あり)

Effectフォルダの中に[eff_tornado]を作成して
その中にインポートしたものをいれる。

データは
1,単体風大,35,28,0,5,2,0,0,0

[5-2]
ループ再生になっているので時間を区切るようにする
Durationを2にして、再生時間を2秒とする。

また、回転速度が遅かったのでStartSpeedを3～5に
変更した。

Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

単体の確認完了。

1,複数風大,35,35,1,5,2,0,0,0
複数の確認完了。

1,全体風大,35,45,2,5,2,0,0,0
全体の確認完了。

------------------------------------------------

<極大威力の魔法を作成する>-----------------------

[CheckAttackHis.cs]
極大威力のときもアニメーション終了まで待機させる。
[CharaUseMagic.cs]
敵の位置に発生させるようにする。

<火>
データは
1,単体火極大,100,45,0,2,3,0,0,0

EffectフォルダのHovlStudioにある[RotatorPS1]の
プレハブをつかう。

複製して[2-3]とする。

[2-3]
炎の玉がぐるぐる回る時間が長いから短縮したい。
→[Magic fire pro orange]
  ・StartLifetime 6.35->5
  ・Simulation Speed 1->3 
  [FireWhite]
  ・Simulation Speed 1->3

あとはすべてのループ再生を切る。

さすがに大きさがでかすぎた。
あと最初の発生位置が外過ぎて見えない
[Magic fire pro orange]
StartSpeedを-2にしたらオシャレになった。
隣の敵に被るからどうしようかなぁという感じ。
ShapeのRadiusを6->3にする
これで半径がちょうどいいかも

Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
※もともとついていたものを利用する
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

単体の確認完了。

1,複数火極大,100,60,1,2,3,0,0,0

もうすこし再生時間を短くしたほうがよさそう
[Magic fire pro orange]
  ・Simulation Speed 3->4
  [FireWhite]
  ・Simulation Speed 3->4

複数の確認完了。

1,全体火極大,35,75,2,2,3,0,0,0
全体の確認完了。

<水>
なんかいい感じのないかなぁ
大が滝みたいになってるから
タイダルウェイブみたいなぐるぐる渦潮まきみたいなのできないかなぁ。
→ハリケーンを平べったくしたらいけそう！

風大魔法と同じgitからハリケーン2をインポートする
そして[3-3]とする。

データは
1,単体水極大,100,45,0,3,3,0,0,0

どうやったら平べったくできるか探し見る

[3-3]
・RotationのX軸を-90->0にする
・StartSpeed 1～2->0にする
・Rotation over Lifetime の
　Angular Velocity -1000->200にする
・Shapeにチェックをいれる
　・Sphere
　　Radius 0.0001
    Arc 0
・RendererのMeshにmesh_WaterPlaneをいれる
　※mesh_WaterPlaneは、噴水の水で使われているやつ
・MaterialとしてEff_shock1をいれるようにする

た、高さがでない。。。
・Velocity over Lifetimeにチェックをいれる
　・LinearのYに1といれる

あとはStartColorの調整でα値を0.2にする。

Shockとringの調整もする。
両方ともRotationのX軸を-90する

ringのStartSizeを 3～4->7～8とする
ShockのStartSizeを 0.5～0.6->0.5～1とする

smoke1のShapeを
・Angle 30->70
・Radius 0.11->1
とする

最後にループ再生のチェックを外す
意外と再生時間が長いから調整しなおす
・全てのDurationを5->2にする。

Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

単体の確認完了。

1,複数水極大,100,60,1,3,3,0,0,0
複数の確認完了。

1,全体水極大,35,75,2,3,3,0,0,0
全体の確認完了。

<土>
Unityの公式のEffectからMagicEffectsフォルダだけを
Effectフォルダに入れて、EarthShatterというプレハブを使うようにする。(Ice系は削除する)

データは
1,単体土極大,100,45,0,4,3,0,0,0

[4-3]
エフェクトを見た感じ、進むにつれて岩が小さくなってるから逆に大きくなっていくように変更したい。

[RockSpoke]
StartSizeがグラフみたいなやつで制御されてて
だんだん小さくなるようになっているのを
だんだん大きくなるように線の幅を変更した。

ループ再生のチェックをはずす。

右に進んでいくようなエフェクトだから、
向きを変えたほうがよさそう。
・RotationのYを0にする。

Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

PositionのZを-5にして
敵座標から少し離れた場所からエフェクト再生されるようにする。
BoxColliderも広めにしておく

再生したときに画面奥まで行き過ぎているから
もうすこし手前で終わらせたい
→やりかたがわからん！

単体の確認完了。

1,複数土極大,100,60,1,4,3,0,0,0

全体的にもう少し消える速度を速くしたほうがいい
複数の確認完了。

1,全体土極大,35,75,2,4,3,0,0,0
全体の確認完了。

<風>
トルネードよりつよい風ってなんやろ。。。

データは
1,単体風極大,100,45,0,5,3,0,0,0

[5-3]
eff_wind_burstから改良していく。
丸いのをつけくわえたいから[5-1]にある
[KYexplosion]をとりだしてくっつける

そこにさらに毎度のようにお世話になってるgitから
Wind1をインポートしてきて入れる。

何かいい感じに派手になった！かも

ループ再生のチェックを外す。

Weaponタグをつける
BoxColliderを付ける(IsTriggerにチェック)
Rigidbodyを付ける(UseGravityチェックはずす)
CheckAttackHit.csを付ける
MagicMove.csはPowerの引数を0にしておく。

ちょっと大きすぎる？いやでもこれぐらいでいい？

単体の確認完了。

1,複数風極大,100,60,1,5,3,0,0,0
複数の確認完了。

1,全体風極大,35,75,2,5,3,0,0,0
全体の確認完了。

------------------------------------------------

<HP/MPのスライドバーがマウスで増減できちゃう>----
HP/MPSliderのInteractableのチェックを外す！
これで外部からスライダーが動かせなくなる
PrefabのHPSliderも忘れずに変更してあげる。

------------------------------------------------

<戦闘UIコマンドの画像を変更する>-----------------
ButtleUICanvasのCommand/Imageに子としてImageを4つ追加して、それぞれに画像をいれる。

見づらいから一時的にSetMagicObjを非表示にしておく

Pictureフォルダにパワポで使った
剣、盾、鞄、杖
をいれてそれぞれの名前をImageObjectの名前と同じにする。

画像が大きすぎるのでだいたい縦か横を100にして
ペイント3Dでサイズ調整しなおす

剣が細すぎてよく見えないから違う画像を探す
イラストACで違うやつを拾ってきた。
https://www.ac-illust.com/main/detail.php?id=22123721&word=%E6%B0%B7%E3%81%AE%E5%89%A3%E3%80%80%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3%E3%80%80%E7%B7%9A%E3%81%82%E3%82%8A&searchId=4196424066

回転させたときに、画像が正式な向きで回ってくるようにRotationを調節する必要がある。

Command
 Attack 0,  0  ,0
 Magic  0,  180,0
 Item   0,  0  ,90
 Guard  180,0  ,0

魔法を使用しようとしているときに、マテリア画像を
表示する際はコマンド画像を非表示になるようにする

[CharacterMng.cs]
private GameObject[] buttleCommandImage_ =
new GameObject[4];
という変数を追加する。

Start関数で
for(int i = 0; i < commandImage.childCount; i++)
{
  // コマンド画像4種類を取得
  buttleCommandImage_[i] = 　commandImage.GetChild(i).gameObject;
}
としてコマンド画像のGameObjectを取得しておく。

あとは、setMagicObjのSetActiveが
trueのときにfalse
falseのときにtrue
となるようにfor文を2か所に追加するだけ。

追加場所忘れてた！
AnimationChange関数のIDLEのときにも入れないと、
魔法攻撃あとのキャラが行動するときに出てこなくなる

・新規画像4枚と、コマンド部分を一時保存ファイルで
　更新すること！あとScriptも忘れずに

------------------------------------------------

<戦闘中、メニューが非表示になってない>-------------

[SceneMng.cs]
MenuSetActiveFalse関数を引数ありの
MenuSetActive関数に変更して、
true/falseを呼び出し先から決定できるようにした。

[FieldMng.cs]
ChangeMode関数のなかでSEARCHでtrue
BUTTLEでfalseになるようにSceneMngのMenuSetActive
を呼び出すようにする。

これで戦闘時はメニューがでなくて
探索中はでるように変更できた。

-------------------------------------------------

<魔法装備してないときに魔法決定するとエラーでる>---

[CharacterMng.cs]
Buttle関数の魔法コマンド選択時に、
回転中は魔法情報を取得できないようにする条件に加えて、GetMagicNumのnumberが0より大きくないと
魔法処理が続行できないようにしておく。

これでエラーがでないように対処できた。

-------------------------------------------------

<敵の弱点属性だったときにダメを2倍にする処理追加>--

[EnemyInstanceMng.cs]
HPdecrease関数の中でダメージ値の算出の前に
攻撃側の属性と自分の弱点属性が一致してたらダメージ量を2倍にするようにif文で確認してから
damage *= 2;を行う。

[CharacterMng.cs]
通常攻撃のときに、前のキャラの属性が残っていたら
ダメージが2倍になってしまうので
Attackコマンド選択時にanim_ == BEFOREのとき
buttleMng_.SetElement(-1);を入れるようにする。

-------------------------------------------------

<魔法の攻撃威力にキャラの魔法威力を加算する>-------

[CharaUseMagic.cs]
CheckUseMagic関数の引数に、キャラの魔法攻撃力を取得するようにする。(MagicPower関数)

// 攻撃威力をButtleMng.csに渡す
buttleMng_.SetDamageNum
(magicData.power + charaMagicPower);
とする。

[CharaBase.cs]
Magic関数を、返り値intのMagicPower関数に変更する。

[Chara.cs][Enemy.cs]
Magic関数を、返り値intのMagicPower関数に変更する。

[CharacterMng.cs]
引数部分を増やして、
useMagic_.CheckUseMagic(charasList_[(int)nowTurnChar_].GetMagicNum(tmp), charasList_[(int)nowTurnChar_].MagicPower());
と書く。

これで魔法威力+魔法攻撃力の値を使って攻撃できるようになった

-------------------------------------------------

<MPが足りないときは発動できないようにする>---------

[CharacterMng.cs]
private int mpDecrease_ = 0;変数を追加する。

mpDecrease_ = useMagic_.MPdecrease(charasList_[(int)nowTurnChar_].GetMagicNum(tmp));
としておき、

現在のMP量と、発動に必要なMP量を比較して
足りなければmpDecrease_は0に戻して処理を抜ける。

足りるときには魔法を発動して、MagicAttack関数で
減少処理をした後に0に戻す。

[CharaUseMagic.cs]
MPdecrease関数の引数に
Bag_Magic.MagicData magicDataをいれて、
return magicData.rateを返す。

使用しているのはCharacterMng.csの
mpDecrease_ = useMagic_.MPdecrease(charasList_[(int)nowTurnChar_].GetMagicNum(tmp));
という部分。

これでMP不足なら魔法を使えないようにできた。

-------------------------------------------------

<討伐系クエストもどういう風に討伐した判定にするか考えないと>

<Field4つくろ>
