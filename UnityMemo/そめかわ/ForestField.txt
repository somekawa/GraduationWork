最初のブレークポイントが置けるようになるまで

①VisualStudioInstollerでUnityのツールが
　入っているか確認する

②Edit>Preferences>Generalの、
　Code Optimization On SetUpの項目が
　Debugになっているか確認する

③Edit>Preferences>External Toolsの、
　External Script EditorにVisualStudioのやつが
　設定されているか確認する

④VisualStudio側で、
　デバッグ>Unityデバッガーのアタッチを押して、
　出てくるかを確認して押下する

この4つでだいたいおわるはず

------------------------------------------------
<Animationの切替>
[Wait->Run]
isRunのフラグがtrueのとき、とする
[Run->Wait]
isRunのフラグがfalseのとき、とする

<お目目をぱちくりさせる方法>
Unityちゃんに、AutoBlinkforSD.csをアタッチする
引数の、Ref_faceという場所には「_face」を入れる

アニメーションで参考にしたサイト↓---------------

FaceUpdate.csの、「Invalid Layer Index」の警告についての対処法
https://thinkit.co.jp/story/2014/11/06/5372?page=0%2C1

コライダーの大きさと、キャラクターコントローラーを使った移動制御について
https://goodlucknetlife.com/unity-how-to-charactorcontroller/

特に、アニメーションの切替方法について
https://www.eda-inc.jp/unitychan/

------------------------------------------------

<五芒星のイラスト>
https://www.ac-illust.com/main/detail.php?id=1890670&word=%E4%BA%94%E8%8A%92%E6%98%9F%E9%AD%94%E6%B3%95%E9%99%A3#
※イラストACから拝借


<キャラの方向転換について>
参照したもの↓
https://www.hanachiru-blog.com/entry/2019/02/20/183552

transform.rotation = Quaternion.LookRotation(movedir);
と書くことで、ボタン押下時にmovedirに値が入るから
移動させたい方向というのが決められる

<他のモーションアセットを、unityちゃんにつける>
参照したもの↓
https://unity-shoshinsha.biz/archives/987

https://obenkyolab.com/?p=2112

AnimaterにしっかりStateを追加して設定すれば
動いてくれました。
※Has Exit Timeにチェックを付ける/付けないは
ちゃんと考えたほうがいい
(例)Wait->Attackについては、
Waitのアニメーションが終わってからAttackに移動するとボタン押下時に即座に反応してくれないと困るから、チェックは外して合ったほうがいい
逆に、Attack->Waitは、
Attackのアニメーションが最後まで再生されてから
Waitに戻ってほしいので、チェックがついていたほうがいい

<Unityちゃんに武器をもたせる>-------------------
参照したもの↓
https://unity-shoshinsha.biz/archives/987

武器アセットをいれて、上記のサイト通りに右手の子供として設定。そのあとにCharacter1_RightHandのTransform値を武器にコピペしたらいけそう
後はちょっとした座標調整と、サイズの変更

武器の    X      Y     Z
Position 0.06  -0.2   0.04
Rotation -10    0     180
Scale    0.5    0.5   0.5

-----------------------------------------------

<武器を振るモーションの後>----------------------
少しずつ座標がずれているから、ずれないようにしないといけない

参照したもの↓
https://indie-du.com/entry/2016/05/14/095612

UnityちゃんについてるAnimatorのApplyRootMotionのチェックをはずしたら座標がずれなくなった

ただそうすると、床をすり抜けて落下していくようになった。UnityちゃんにつけてるRigidBodyのUseGravityのチェックをはずしたら落下はしなくなったけど、根本的な解決にはなってなさそう。。。

<CharactorControllを使わないでキャラ操作>
参照したもの↓
https://gametukurikata.com/program/rigidbodyandcollider

CharactorControllをRemoveして、
RigidBodyとCapsuleColliderをつける。
値は上記のサイトをマネする。

一部違う所だけ抜粋↓
CapsuleColliderのCenterは、
(X)0,(Y)0.5,(Z)0にする
Radiusは0.5で、Heightは1にする

以上で、UseGravityを入れてもすり抜けないし、
コライダー同士で接触しておかしくなることもない。

-----------------------------------------------

<Apply Root Motionについての追加知識>-----------
参照したもの↓
https://light11.hatenadiary.com/entry/2019/04/18/003100

特定のMotionのみチェックを外した状態にする。
ということも可能らしい。

------------------------------------------------

<MainCameraをUnityちゃんに追従させる>-----------
参照したもの↓
https://xr-hub.com/archives/7057
なぜか、MainCameraをunityちゃんの子オブジェクトに
する方法は全部失敗した。
CameraSample.csの方法でやった
-----------------------------------------------

<MainCameraとButtleCameraを切り替える>----------
参照したもの↓
https://xr-hub.com/archives/6038
この記事の中では、MainとSubで切替の説明をしている

MainCameraの文字のMainとCameraの間に空白があるのを消したほうがバグを生まないですむ。

CameraControllerという空のオブジェクトを用意しておいて、そこに新規Scriptで[CameraMng]をつくって
アタッチするようにしたらいい。
[CameraMng]の内容は上記のURLに記載されている。

制作するゲームはランダムな値でエンカウントして、
エンカウントしたらカメラを切り替わるようにしたい
------------------------------------------------

<MainCameraにはUnityちゃんの武器を映さない>------
まず、新規で[Weapon]というLayerを追加する。
次にUnityちゃんの右手の子供にした[Staff]のLayerに
[Weapon]を設定する。

MainCameraのインスペクター内にCameraがあって
そこにCullingMaskがある。
最初の設定では[Everything]になって全てのレイヤーを映すようにしているが、ここから[Weapon]を除外。
その結果、MainCamera上には映らなくなる。

ButtleCameraは[Everything]のままなので武器も映る

※ついでに書いとくと、unityちゃんは、武器以外
　[Player]というLayerを新規で用意して付けている
------------------------------------------------

<Unityちゃんの通常モードと戦闘モードを分ける>----
新規でButtleUnitychanControllerを作成し、
ButtleCameraがONのときのみUpdate処理を続行し、
SPACEキーを押下すると杖を振るモーションを行う。

ButtleUnitychanControllerはUnityちゃんにアタッチした。

ついでに、バトルカメラもunityちゃんに追従するようにButtleCameraにもCameraSample.csをアタッチした

他キャラと一緒に戦う仕組みならunityちゃん専用の攻撃Scriptではなく、ちゃんと親をつくって、
ポリモーフィズムにしたほうがいい。
汎用性を高めること！

(例)攻撃ボタンを押す(親クラス)→敵選択(親クラス)→攻撃モーションとダメージ計算をする(子クラス)

いまのうちからキャラを複製して検証したほうがいい
------------------------------------------------

<ButtleMngで全てのキャラのアクションを操作する>--
キャラ1体1体にButtleUnitychanControllerをつけるのは馬鹿だな。と思ったので、修正。

ヒエラルキーに空のオブジェクトをつくって、
ButtleMngと命名。同じくScriptを新規作成して、
そちらにもButtleMng.csと命名。新規Scriptを空のオブジェクトにアタッチする。

使用するにあたって、CharListにキャラオブジェクトを登録する必要がある。Script内にキャラ名のenumが
あるため、それと同じ順番でキャラオブジェクトをアタッチしないといけない。

それを利用してcharMap_を作成。
charMapは、キーをenum,値をキャラオブジェクトにしている。
foreachで回して、構造体に登録していく方針にした。

構造体を使うことで、キャラ1体1体の情報を差別化できる。

攻撃モーションの途中で、次のキャラの操作に移行してしまい。モーションが途切れるバグがあったため、

構造体にisMoveとanimTimeを追加して、モーションに
間をつくるようにした。
ただし、Scriptにも記載しているが、キャラによってモーションの間を調整する必要があるかもしれない。
その場合は、maxAnimTime等を外部データからもってこれるようにしたほうが効果的だと思う。

以上の実装方法により、キャラクター毎にコントローラースクリプトを用意する必要がなくなった。

------------------------------------------------



これより下は、0831パッケージに入っていない所。

<バトルUIの回転するUIの作り方>------------------
参照したもの↓
https://scrapbox.io/remi-tech/Unity%E3%81%A7%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%9F%E8%A7%92%E5%BA%A6%E3%81%BE%E3%81%A7%E5%9B%9E%E3%81%97%E3%81%A6%E6%AD%A2%E3%82%81%E3%82%8B%E6%96%B9%E6%B3%95

まず、ButtleCanvasをヒエラルキーに作成して、
中にImageを追加する。UIにしたい画像のTexture Type
をSprite(2D and UI)にしてから、Imageにアタッチ

Imageには新規ScriptでImageRotate.csを作成して、
アタッチする。
このスクリプト内で回転処理を行っていく。

回転処理については上記の参照サイトと全く同じ。

①キー入力によって回転させたい角度を決める
②①をクォータニオンに直す
③画像の現在のクォータニオンを調べる
④Quaternion.Angleという関数を使い、②と③の角度
　の差を求める
⑤④の差が一定値以下なら回転終了し、
　規定値を満たしていなかったら回転を続行する。

まだActiveの切替とかしてないからバトル中以外でも
出てきちゃうけど、明日からまた修正頑張ろう。

FieldMngをつくって、戦闘と通常を切り替えられるようにします。
CameraMngでAキー操作でカメラ切替にしているところ
から修正。
enumつくって参照できるようにしてあげる。

毎回戦闘モードの最初が同じコマンドを上に出すようにしないといけないから、ImageRotateにResetRotateという関数を追加。呼び出し先は、ButtleMngです。
関数の中で、0,0,0の初期値に戻るようにした。
また、そのさいにはちゃんとtargetRotate_も0.0fに
初期化しないと、バグが発生する。

-----------------------------------------------

<FieldMngでMODEの管理をする>--------------------
MODEというのは、探索モード/戦闘モード/メニュー
とかの、フィールド上で遷移するもの。

今は、時間経過で戦闘モードになるようにしてテスト
している。

空のオブジェクトを作成して、FieldMngと命名。
それに新規Scriptをアタッチして、その名前も
FieldMng.csにした。

FieldMng.cs内ではさっき書いた通り、時間経過で遷移するようにswitch文を書いている。

MODEが切り替わる事でCameraMng内のカメラ切替や、
ButtleMng内の攻撃モーション操作ができるようにならないといけないから、static変数でnowModeをつくり、
どのクラスからでもFieldMng.nowModeで現在の状態を
見れるようにした。

また、ButtleUICanvasについては、ButtleMngで
表示/非表示を管理するために、ButtleMng.csにpublic変数を追加して、アタッチできる場所を用意した。
missingに注意すること！！

これからも「複数クラスからの参照」があり、
「唯一の変数」で良いならstaticにしたほうがいい。
情報も持ち越せるだろうしね。

------------------------------------------------

<MODEがButtleなら、UnitychanControllerをoffに>--

UnitychanController.csに、MODEがSEARCHなら動く
ようにしたらいいね。それ以外ならreturnさせれば早い。

MODEが切り替わる時に走っていると、走りモーション
が終わらなくなる為、returnの前に、is_Runをfaseに
する処理を入れておく。

また、戦闘モードで行動する順を毎回守る為に、
returnの前に、nowTurnChar_ = CharcterNum.UNI;
を入れる。

町の中でもSEARCHにしておけばいいかな？

------------------------------------------------

<戦闘用ワープポイント>--------------------------
実際のゲームフィールドでは、ひらけた空間を1ヶ所は
用意しておき、そこに戦闘では一時的にワープさせる
→ゲームフィールド毎に、戦闘用ポイントを設置する

あとはモードが切り替わったときにキャラの向きと位置の所定位置をきめとく。

ButtleMngでキャラを取得してるから、場所と向きを
予め設定できる何かを用意しておく。

<テストでポイントを作ってみる>
以下、バトルワープポイントのことをBWPと記載する。

キャラが2体なので、2つ設置する必要がある。
まず、BWPをまとめる空のオブジェクトを作成して、
ButtleWarpPointPackと命名。(座標0,0,0にする)
その後、それの子供に2つCubeで、BWP0,BWP1を作成。
(必要がない、BoxColliderをremoveしておく。)

ButtleMng.csにバトルワープポイントの取得を書く。
そのために、public変数で、BWPPackをアタッチできる所をつくる。
マップ毎にSceneを分けるのであれば、この方法で問題ない…はず。

BWPPackの子の座標をStart関数内で別の変数に保存する。
戦闘モードに切り替わるときに、その座標をキャラに入れてあげたらよい。
キャラの向きは、実際のマップをつくってみないとわからないが、全て進行方向を、統一する必要がある。

メモリーリークを防ぐ書き方の参考↓
https://madnesslabo.net/utage/?page_id=11109#i-17

基本的に、Sceneを丸ごと削除したらメモリーリークの
発生は起きにくい。(削除＝アンロード)
ただ、Sceneを跨いでも残る情報(シングルトンとかMng系の何か)とかがあると、
参照次第ではメモリーリークになるかもしれないからDestroyのあとにnullを代入する注意が必要。

------------------------------------------------

<戦闘用ワープポイントでのキャラの向き>-----------

戦闘用UIの回転方法と類似している。はず。
①buttleWarpPointsRotate_という配列変数を用意する
②buttleWarpPointsPos_と同じタイミングでStart関数でワープポイントの回転角をクォータニオンで取得
③戦闘モードになったとき、キャラクターの回転角に
②のクォータニオンを代入するだけ。

BWPの箱を回転させれば、その向きにキャラも変更できるはず。できました。
------------------------------------------------

<敵とのエンカウントまでの色変化の作り方>---------
テストとして、普通の3DオブジェクトにEncountColorという新規Scriptで作成したものをアタッチして行った。

参照したもの↓
https://teratail.com/questions/302182

今回は、255とかのbyte単位で変化させるのを使用した

色合いの変化を
青→青緑→緑→黄色→オレンジ→赤
と変化させた。

まず、青の値を減算して緑の値を加算する
加算：green * (time_ / toButtleTime_)
減算：255 - (blue * (time_ / toButtleTime_))

time_ / toButtleTime_は、
(現在値 / エンカウント発生時間)なので
0～1の値にできる。
これに255を乗算するとその時間に適した値を出せる。
減算したい時はさらに先頭に255 - をつけると良い。

time_ / toButtleTime_が0.5fを超えたら
redStartFlg_をtrueにして、赤の加算を始める。
このとき、青の減算を早めて、緑も減算を行う。

これで、色の変化は完成した。

次に、time_ / toButtleTime_の計算をFieldMng.cs
で行い、EncountColor.csに引っ張ってくる方法を考える。

------------------------------------------------

<EncountColor.csがFieldMng.csの値を参照する>----

EncountColor.csで変数追加して、
(private FieldMng fieldMng_;)

Start関数で名前検索をかけて、中のコンポーネントの
FieldMngを取得する。

fieldMng_ =　GameObject.Find("FieldMng").
　　　　　　  GetComponent<FieldMng>();

あとは、Update関数で毎回取得して、
float time = fieldMng_.GetNowEncountTime();

いままで、(time_ / toButtleTime_)と書いて計算式を書いていたところをtimeに変更する。

最後に、戦闘が終了したら、また青からスタートするように戻す方法を考えないととと・・・

nowModeがMODE.BUTTLEなら計算をせずreturnにして
値を初期化する。

------------------------------------------------

<[Field]をバトルカメラから除外する>-

新規でレイヤーを作成[Field]
MainCameraのCullingMaskでは、[Field]に
チェックをつける。

ButtleCameraのCullingMaskでは、[Field]に
チェックをつけない。

他にも映したくないものが増えてきたら[Field]に
レイヤーを設定すればいい

------------------------------------------------

<FieldUICanvasを作成して、画像の色を変更させる>--

素材を入手したときのアナウンスとかも入れられるように、新規にヒエラルキーにFieldUICanvasを作った。

レイヤーはFieldに設定し、さっきまで色変化のテストにつかっていたものを修正していく。

①FieldUICanvas内にImageを作成。
　テストでつくったwhite.pngを入れる。
　Colorをクリックすると、色相環がでてくるが、
　色相環の右下に[RGB0-255]とか書いてるやつがある　これを[RGB0-1.0]に変更しておく。

②EncountColor.csではマテリアルだったところを
  Imageにしたり変更を行う
　特に注意する点は、①で0～1.0にしたため、

image_.color = 
new Color(r/255.0f , g/255.0f , b/255.0f, 1.0f);

こんなかんじで、255.0fで割る必要がある。

------------------------------------------------

<UI要素はCulling Maskできないと書かれてて>-------

FieldUICanvasを追加したものの、なぜかレイヤー分けしてもバトルカメラにエンカウント目安UIでてきたので
調べたところ。
Culling Maskができないとか書かれてた。

よって、FieldUICanvasを非表示にする方法を考えることになった。

他の普通のオブジェクトは[Field]でカメラ分けできると思うから、レイヤー自体は残しておきます。

ButtleMng.csのUpdate関数の最初のif文に、
戦闘モードじゃなかったらbuttleUICanvasをfalseに
するってところがあるから、このタイミングで
FieldUICanvasはtrueになっている必要がある。

よって、ButtleMngのpublic変数を増やして、
FieldUICanvasをアタッチできるようにしたら早い。

FieldUICanvasをfalseに戻すほうもちゃんと書いとく

これで、戦闘モード中はカメラに映らないように修正ができた。
-----------------------------------------------

<EncountColor.csの改良>------------------------
同じような計算を複数回行っているため、別関数に
計算内容をまとめて、フラグや値で処理を分けて、
計算結果を関数の返り値にするようにした。
(ColorValueCalculation関数のことです)
-----------------------------------------------

<キャラが歩いているときだけエンカウント時間加算>-
今は止まっているときでも時間が加算されているので
FieldMng.csを修正して、歩いているときだけ。に
変更していく。

[歩いている＝座標移動している]だから、
UnitychanController.csでフラグを立てて、
FieldMngで参照できるようにしたらいいかな？？

UnitychanControllerもマネージャー的なオブジェクトに近いから、今回はfindで検索しよう。

FieldMng.csにprivate変数でplayer_を追加して
findで名前検索。
Update関数でplayer_.GetMoveFlag()を呼び出す。

GetMoveFlag()というのは、UnitychanController.cs
で新規に作成した関数で、GetBoolの状態を取得する。

------------------------------------------------

<Findとプロトタイプ宣言からのインスペクター指定>-

別のオブジェクトについているスクリプトを見たい時
①find検索
②findTag検索
③public Gameobjectとしてプロトタイプ宣言して、　Inspectorから指定する

がある。

それぞれのメリットとデメリット↓
https://marunouchi-tech.i-studio.co.jp/2266/

まとめ部分だけ載せておくと、
a.マネージャー的なオブジェクトはStartの時にFind
b.表示非表示を繰り返すようなものはInspector上から　指定して使う
c.Insulatorから指定するのは便利だが、大量のオブジ　ェクトを確保しようとするとプロトタイプ宣言の箇　所がとても多くなる。
　そこは親オブジェクトだけInspector上から取得し、　子オブジェクト等は親オブジェクトから取得する。

つまり、表示非表示管理をしないものは基本findを
start関数で行うといいのかもしれない

------------------------------------------------

<コマンドの回転に区別をつける>-------------------
まずは、攻撃コマンドとそれ以外にわけてみる。

回転してたらわからなくなったからメモ
右回転と左回転を比べる。

右　　 左
0  と +-360は一緒 
90 と -270 は一緒
180と -180 は一緒
270と -90  は一緒

左　+　360 = 右!!!

マイナス値なら+360で計算したらうまくいった

Quaternion.Angleを使っているif文内に処理を
追加しました。

------------------------------------------------

<ButtleMng.csにコマンド情報を渡す>--------------
すでにこれまでの実装の経緯で、ButtleMng.csの引数にButtleUICanvasがいて、buttleCommandUI_という
変数にImageRotate.csの情報がある。

アタックモーションになっているときに、
if(buttleCommandUI_.GetNowCommand() == 　　ImageRotate.COMMAND.ATTACK)

というのでif文を追加したらうまく選択ができていた

GetNowCommandという関数はImageRotate.csに新規で
追加しました。

他のスクリプトでpublicのenumと==の判定をしたいときは、今回みたいなif文の書き方をしたらいいみたい

-----------------------------------------------

<unityちゃんの通常攻撃>-------------------------

KY_effectsというアセットのエフェクトで作成する。

参照したもの↓
https://gametukurikata.com/program/shockwave

KY_effects > MagicEffectsPackFree > prefab
の中の、ErekiBall2を複製して「UniAttack」と命名。
(オリジナルは念のためとっとくようにする)

①一度、ヒエラルキーにおいてアンパッケージ化する

②UniAttackの親オブジェクトにSphereColliderを
　つける。IsTriggerにチェックをつける
　RigidBodyを追加し、UseGravityのチェックを外す

③ButtleMng.csにAttackStart()という上記のサイト　の関数を追加して、②をアタッチできるようにする

④新規Scriptで、「MagicMove.cs」を作成
　内容は、上記のサイトのShockwaveMoveスクリプトを
　持ってくる。一部判定でいらない部分があるので
　削除もおこなう

⑤UniAttackに、MagicMove.csをアタッチ

⑥再びPrefab化する

⑦ButtleMngというオブジェクトについている　　ButtleMng.csにProjectファイルのprefabから直接　ドラッグ&ドロップする
　(ヒエラルキーに置いてたUniAttackは消してよし)

UniAttackが自然消滅しないから、Start関数に、
Destroy(this.gameObject,5);
みたいに指定した時間が過ぎたら消えるようにしとく

でもたぶん最終的には敵に当たったら消えるからいらないとは思う。


<発動させたキャラの位置から弾がでるようにする>
よくよく考えたら、ちゃんと座標指定ができてなかった。

ButtleMng.csのAttackStart()という関数で弾の発生位置を調整してインスタンスしているから、キャラの戦闘開始時の座標を保存して、それを使用する必要がある。

a.戦闘開始時のそれぞれのキャラ座標を保存する
①CharcterSettingの構造体に、buttlePosという変数　を追加する

②Update関数内で、setCallOnce_がfalseの時に
　foreach文で戦闘用座標と回転角度を代入している所　がある為、そこに
charSetting[(int)character.Key].buttlePos = character.Value.gameObject.transform.position;
　と追加する。
　おそらく、非戦闘時にメニュー画面でキャラの立　　ち位置を交換とかしても、戦闘開始時に必ずここの　処理が呼ばれるので、エフェクト発生位置の目安に　できる。

b.AttackStart関数でエフェクトの座標を調整する
　今行動ターンが来ているキャラだとわかるように      AttackStart((int)nowTurnChar_);という風に
　引数を持たせる。
　
　あとは、関数内で
　var adjustPos = 
　new Vector3(charSetting[charNum].buttlePos.x, 　　　　charSetting[charNum].buttlePos.y + 0.5f, 　　　　charSetting[charNum].buttlePos.z);
　とすれば完成ですね。

-----------------------------------------------

<通常攻撃が敵に当たるか確認する>----------------

まずはテストの敵を用意する。
①Cubeを出して配置
→BoxColliderのIsTriggerはチェックなしでok
→Rigidbodyの追加をし、UseGravityはチェックなし
②新規Tag  →Enemy
　①にEnemyというタグをつける
③MagicMove.csに判定があるので、敵に当たると
　弾と敵が消えるのを確認する
------------------------------------------------

<攻撃弾連打できちゃうバグ>----------------------
Spaceキーを押下したら～のif文の中で、
isMoveをtrueにしている箇所がある。
そこを、

if(!charSetting[(int)nowTurnChar_].isMove)
{
   AttackStart((int)nowTurnChar_);
   charSetting[(int)nowTurnChar_].isMove = true;
}

とすることで、連打しても1キャラにつき1攻撃エフェクトしか発生させないようにできる。

------------------------------------------------

<ButtleMng.csの肥大化軽減方法について>----------
ButtleMngは、あくまで戦闘中全般をまとめるのが目的なのに、今はキャラクターの内容に偏っている。
そのため、新規にCharacterMngをつくって、
戦闘中/探索中の両方のキャラ状態を管理できるスクリプトを用意したほうが良い。

空のオブジェクトを作成して、[CharacterMng]と命名
新規Scriptを作成して、[CharacterMng.cs]と命名
空のオブジェクトに新規Scriptをアタッチする。

ButtleMng.csでは、CharacterMng.csの
Buttle関数とButtleSetCallOnce関数を呼び出している

*重要*
それぞれにアタッチするものも増減があったため
記載しておく

→の左辺が引数、右辺がヒエラルキーのやつ
<ButtleMng>
・ButtleUICanvas → ButtleUICanvas
・FieldUICanvas  → FieldUICanvas 

<CharacterMng>
・ButtleUICanvas→ButtleUICanvas
・CharList：2
Element0 → SD_unitychan_humanoid0
Element1 → SD_unitychan_humanoid1
・ButtleWarpPointPack → ButtleWarpPointPack
・UniAttackPrefab_    → UniAttack

------------------------------------------------

<攻撃コマンド以外のコマンドを仮実装する>---------
CharacterMng.csに、攻撃コマンド以外のコマンドを
仮実装していく。

Buttle関数のスペースキーを押したの処理にswitch文を入れておく。
コマンド別にデバッグログが出力されるようにしとく

いまはこれで十分だろう。
------------------------------------------------

<敵の生成ポイントをつくる>----------------------

出現ポイントを用意しておいて、そこにインスタンスされるようにしたい。

ヒエラルキーの階層としては、

敵のワープポイント管理親
　→1体の時の親
　　→実際の座標にするBox(1)
　→2体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　→3体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　　→実際の座標にするBox(3)
　→4体の時の親
　　→実際の座標にするBox(1)
　　→実際の座標にするBox(2)
　　→実際の座標にするBox(3)
　　→実際の座標にするBox(4)

こんな感じかしら？

------------------------------------------------

<まずは、中央に1体出せるようにしよう>------------
[敵のワープポイント管理親]として、[EnemyInstancePointPack]という空のオブジェクトを作成

[→1体の時の親]として、EnemyInstancePointPackの
子供に[1]という空のオブジェクトを作成
(ここを番号にすることによって、
　名前をint型で取得できるようになる)

[→実際の座標にするBox(1)]として[1]の子供に
また、[1]というCubeを作成
BoxColliderをRemoveして、座標(x:0,y:0.5,z:3.5)に
設置する。

※EnemyCubeはEnemyMaterialで赤を用意してアタッチ
　その後、Prefab化してヒエラルキーから除外する。

空のオブジェクトを作成し[EnemyInstanceMng]と命名
新規Scriptを作成し、[EnemyInstanceMng.cs]と命名
空のオブジェクトに新規Scriptをアタッチする。

EnemyInstanceMngのEnemyInstancePointPackという
引数に、ヒエラルキーのEnemyInstancePointPackを
アタッチする。

<EnemyInstanceMng.csの中身>
Start関数で2重foreach分を回す。
子と孫で順番に回したあとに、enemyPosSetMap_という変数にインスタンスしたい座標について保存する。
詳細はスクリプトを読んでね。

テストとして、public変数を追加して、Enemyとする
先ほどPrefab化したEnemyCube(Assets-Prefab-Enemy)
をEnemyInstanceMngのEnemyCubeという引数にアタッチする。

あとはEnemyCubeのインスタンスタイミングの調整と、
実際のインスタンス処理を行えば完成かな？

①インスタンスタイミング
ButtleMng.csのUpdate関数内にある
if(!setCallOnce_)の中にEnemyInstanceMng.csが
呼び出せればよい。
まずは、ButtleMng.csにFindでEnemyInstanceMngを
取得した変数を用意しておく。

②実際のインスタンス処理
これはEnemyInstanceMng.csでやる内容
EnemyInstance(int mapNum)というpublic関数を
用意したため、そこを見てね。
あとは、この関数を①の呼び出し予定位置で呼べば終わり。

------------------------------------------------

<敵が2,3,4体でるバージョンもつくろう>------------

EnemyInstancePointPackに[2][3][4]もつくろう
設定方法は上記と同じ。
確認するときは、ButtleMng.csで呼んでいるEnemyInstance関数の引数値を変更してね。

※デバッグ用に、ButtleMngのインスペクターからいじ　れるようにしときます。
　→debugEnemyNumという引数をButtleMngに追加

-----------------------------------------------

<UniAttackプレハブの修正>-----------------------

RigidBodyのRadius→0.5
に変更する

------------------------------------------------

<敵の方向に向かって攻撃が飛ぶようにする>---------

テストとして、敵の数が1の場合で行う。

CharacterMng.csにAttackStart関数があり、ここで
弾の飛ぶ方向が設定されている。
そのため、ここに敵の座標を渡せたら良い。

EnemyInstanceMng.csにGetEnemyPosという関数を追加して、敵の座標を持ってくることはできたが、
UNI→問題なく当てられる
DEMO→違う方向に飛ぶ
方向の設定が、キャラの立ち位置によってうまくいっていない

参照したもの↓
https://teratail.com/questions/201882
ベストアンサーでは、座標位置を正規化している。
これを「対象敵 - 行動中のキャラ」にすることで
実装する事が出来た。

------------------------------------------------

<キャラが攻撃する敵を選べるようにする>-----------

(処理の流れ)
攻撃コマンド押下→敵を選択する矢印的なのを操作→
SPACEキー押下→攻撃モーション

敵選択も、コマンドを回転させるやつと同じボタンでいいと思う。

※攻撃cancelボタンも必要(コマンド選択へ戻す)

・・・どうやってつくろう＞＜

(案)
CharacterMng.csでSpaceキーを押したときに、
矢印のクラスへenemyInstanceMng_のpos情報を渡して、矢印のクラスで敵選択の操作をする。
再びSPACEキーを押されたら選択した敵の座標が矢印のクラスからCharacterMng.csにreturnされるようにして、そのreturnされた座標に対して攻撃を飛ばすようにする。
※cancelボタンが押されてもreturn -1;とかにして、
　CharacterMng.csに戻されるようにする。

------------------------------------------------

<上記の(案)を使って、敵選択を実装する>-----------

まずは、CharacterMng.cのStart関数で、敵の出現座標を全てEnemyInstanceMng.csから受け取っておく。

矢印のクラスへenemyInstanceMng_のpos情報を渡す際に敵の出現座標を全て渡すのは効率が悪いので、
ButtleMng.cs側で敵の出現数を決定した後、
CharacterMng.csに新規で用意したSetEnemyNum関数に
値を設定するようにした。
(enemyNum_という変数に保存しておく)

これで矢印のクラスpos情報を渡すときは、
enemyInstancePos_[enemyNum_]とすれば必要な座標だけ渡すことができる。はず。

あとは、テストとして矢印の代わりにSphereを用意して[EnemySelectObj]と命名。Collider外す。
そこに新規Scriptの[EnemySelect.cs]をアタッチ。

[EnemySelectObj]は、ButtleUICanvasの子供にしておく。

CharacterMng.csにはもともとbuttleUICanvasをアタッチしていたので、private変数でEnemySelect.csを
取得できるようにする。

EnemySelect.cs側にSetPosList関数を用意して、
CharacterMng.csのSetEnemyNum関数内で呼び出す。

SetPosList関数ではY座標を高くしないといけないため
参照したもの↓
https://among-ev.hatenadiary.org/entry/20100925/1285412730
上記のサイトを参考に調整した。

次は、キー操作で矢印の位置が移動するようにする。
EnemySelect.csのUpdate関数に条件付きで位置移動を
させれば完成。
※InstancePointを全て左から順にするようにヒエラル　キーを設定しなおす

<ATTACKを選択する前から矢印がでてるバグ>
CharacterMng.csでselectFlg_という変数を作り、
ATTACK時に切り替えられるようにしておく。
また、矢印の表示/非表示をCameraMng.cs側で
設定できるように、SetActiveという関数を追加した。


EnemySelect.csにGetSelectEnemyPosを追加して、
最終的に選択した敵の座標をCharacterMng.csの
AttackStart関数に情報を引っ張ってこれるようにした

<敵選択中にコマンドがくるくるしちゃうバグ>
ImageRotate.csにrotaFlg_という変数を追加してSetRotaFlgという関数も追加。
CharacterMng.cs側で設定できるようにしたため、
buttleCommandUI_.SetRotaFlg(!selectFlg);という
処理をButtle関数のATTACKのcase文内に追加した。

<選択した敵にぶつかるまえに違う敵に当たり、
 弾が消滅してしまうバグ>
MgicMove.csのOnTriggerEnter関数で当たり判定をするとき、選択した敵以外ならDestroyしないようにする

CharacterMng.csのAttackStart関数で生成されるから
ここに、選択した敵かの判別ができるようにしたい
MagicMove.csにSetTargetNum関数を作り、
CharacterMng.cs側から選択した敵の番号を設定できるようにした。

次に、EnemyInstanceMng.csのEnemyInstance関数で
生成した敵の名前を[EnemyCube]から変更し、
生成順で番号にした。詳細は下のサイト

EnemyCubeに名前を付ける
参照したもの↓
https://teratail.com/questions/44869

あとはMagicMove.csの当たり判定時にif文を追加して
当たった敵と選択していた敵の番号が一致しているかを見てDestroyするかしないかを決めるようにした。

------------------------------------------------

<Destroyした敵の座標の上に矢印がでるバグ>--------

Destroyされた敵の座標部分はとばすようにしたい。

EnemySelece.csでつくっているposList_をタプルに変更して、座標情報とbool情報を持たせるようにした。

boolの方はSetPosList関数の中で座標情報分Addした
後に、全てtrueにしてposList_に代入する。

そして、GetSelectNum関数でreturn selectNum_の前に該当するposList_のboolをfalseにする。
(リストから削除すると要素が上に詰められて番号が異なるバグがでるため使わないようにした。)

あとは、Update関数でselectNumが加算or減算される時に、「falseになっている座標は飛ばす」ようにしたい
while文でつくった。

EnemySelect.csにMoveSelectKeyという関数を新規で作成して、そこで飛ばす処理を書いた。

最奥の敵と最手前の敵を倒した時に、while文だけでは
その敵の位置に矢印を置かないようにする。という処理が実装できなかった。
(while文を抜ける条件と被るから)
その為、tmpFlgやforeach文を追加してつくった。

UP処理の方では、foreach文を逆回しする必要があるので、posList_.Item2.Reverse();等を書いている。
ただし、逆回しにしたまま処理を終わらないように、
最後にもまたposList_.Item2.Reverse();を書いておくこと！

<Destroy後にSPACEキー押下したら、消された所から
 矢印がスタートしてしまうバグ>
HキーやJキーで切り替える範囲を狭めることは上記の処理で完成したが、消した直後にまたSPACEキーで選択するときは消えた敵のいた頭上からスタートしてしまう。

EnemySelect.csにResetSelectPointという関数を新規で用意し、MoveSelectKey関数のDOWN処理にあるforeach部分と同じ処理をいれる。
※まったく同じ処理なので、むしろResetSelectPoint　関数の内容を、MoveSelectKey関数のDOWN処理に呼ぶ　ようにした。
これをCharacterMng.csのStartAttack関数のGetSelectNum関数を読んだあとに入れ込む。

これで矢印のスタート位置をリセットできるようになった。

------------------------------------------------

<キャラが攻撃対象の方を向くようにする>-----------

参照したもの↓
https://code.hildsoft.com/entry/2017/07/06/060658

CharacterMng.csのStartAttack関数に、
charMap_[nowTurnChar_].transform.localRotation = Quaternion.LookRotation
(enePos - charSetting[charNum].buttlePos);
という一文を追加した。

これにより、方向を変える事ができるようになった。
------------------------------------------------

<2回目以降敵と遭遇するとEnemyCubeが宙に浮いてる>-

バグですね。
原因は、矢印用にy軸にoffsetかけた座標が使われてしまっているから。

座標のコピーがうまくいっていないんだと思う。

(対処法)
CharacterMng.csのSetEnemyNumで、今までは
buttleEnemySelect_.SetPosList
(enemyInstancePos_[enemyNum_]);という風に
直接敵の初期座標を引数に入れていたが、

これをコピーされるように
List<Vector3> tmpInsPos = 
new List<Vector3>(enemyInstancePos_[enemyNum_]);

buttleEnemySelect_.SetPosList(tmpInsPos);

上記のように一時変数に入れたものを引数に入れるようにしたら、きちんとコピーされるようになって、
矢印のy座標が2回目以降使われなくなった。

------------------------------------------------

<敵選択中に、コマンド選択に戻れるようにする>-----

つくるのをすっかり忘れていた…。

EnemySelect.csにReturnSelectCommand関数を作成して、返り値をboolにしておく。
特定のキー(いまはTキー)を押下されたときにreturnで
falseを返すようにし、それをCharacterMng.cs側で確認できるようにして、falseなら、selectFlg_をfalse
になるようにしておく。
※そのときにはImageRota.csのSetRotaFlgをtrueに
　するのを忘れずに！

これでコマンド選択に戻れるようになった。
------------------------------------------------

<キャラ毎のデータ管理について考える>-------------
現状は、CharacterMng.csに攻撃処理とかまとめて
しまっているから良くない。
これからキャラ毎にステータスとかも発生するから、
今のうちに直していく必要がある。

参照したもの↓
https://gametukurikata.com/csharp/csharpinheritance

(自分なりの解釈)
インターフェース：多重継承可能。
様々なクラスに使いたいものをまとめる。
(例)Attack,Damage,HPとかとか…
例に書いたものは、キャラも敵も使うよね！ってやつ

抽象クラス：多重継承ができない。
同じ性質のクラスに使いたいものをまとめる。
(例)LevelUp関連,Weapon関連,Defenceとかとか…
例に書いたものは、キャラに必要だけど敵にはいらないよね！ってやつ

(改善手順)
①Chara.csを作る
　これは、最終的にCharacterMng.csでインスタンス
　されるクラスになる

②インターフェースをつくる
　Scriptでつくるみたいで、普通のスクリプトの
　書き方とは違うみたい。詳細は上記のサイトで！

③抽象クラスをつくる
　CharaBase.csみたいなのを用意して、
　Chara.csの下準備をするクラス

④①に、②と③を継承する

⑤Chara.csに必要となる内容を書いていく

それでは、詳細を書きながら実装していきます。

------------------------------------------------

<インタフェースの作成>--------------------------
InterfaceButtle.csという名前で作成する。
内容の書き方は上記のサイト通り。
現状思いつく限りでは、Attack,Damage,HPぐらい…。
------------------------------------------------

<抽象クラスの作成>------------------------------
CharaBase.csという名前で作成する。
内容の書き方は上記のサイト通り。

抽象関数として、
LevelUp,Weapon,Defence,Magic,Itemというのを用意
------------------------------------------------

<Chara.csの作成>-------------------------------
いよいよ、各キャラへインスタンスするスクリプトを
作成する。Chara.csという名前で作成する。

※抽象クラスをインタフェースより先に継承元として
　記述しないとエラーがでるみたい

つくっているうちにまたよくわからなくなってきた。

…あとはこのChara.csをCharacterMng.csで
インスタンスすればいい、のか？
サイトではMakeCharacter.csを別で用意してるみたい
だけど、そこをCharacetrMng,csで置き換えて考えていきます。

------------------------------------------------

<CharacterMng.csでChara.csをインスタンスする>---
※CharcterNumのenumをpublicにして、
CharaBase.csとChara.csにCharacterNumを使った変数とか引数を追加しました。

キャラ毎の情報をChara.csから取得する方式にする為
CharacterMng.csに、List<Chara> charasList_ を
用意して、Start関数のforeach文で.Addするようにした。.Addと同時にChara.csを各キャラにインスタンスする。その為、引数にオブジェクト名,番号,Animator
を入れられるように工夫した。

あとは、いままで
charSetting[(int)キャラ番号]とかでやっていたのを
charasList_[(int)キャラ番号].(Chara.cs側の関数)
というような書き方に直していくだけ。結構変わったところが多いので、よく見直しておいたほうがいい。

ついでに、必要だったのでヒエラルキーのキャラ名も
変更した。
unitychan0→Uni
unitychan1→Demo

Chara.csの中のコンストラクタ部分で、
Excelの情報を読み込む感じにしたらいいと思う。
該当データを名前でシート検索して取得する。

------------------------------------------------

<FaceUpdate.csでエラーや警告がでていたバグ>------
どうやら、自作アニメーターを使っている際に、unityちゃん公式のアニメーターにはあった[face]というレイヤーが無い事が原因だったみたい。

アニメーターをつくりなおすことで解決できた。
方法としては、まず、公式のアニメーターをCtrl+Dで
コピーしてAnimationフォルダに移動させる。
Animatorの中から、不使用のモーション等を消して、
フラグを再設定する。
あとは名前をUnitychanAnimatorに変更しなおしたらそれをキャラにアタッチする。
これで対応できました。
困ったら、公式のを一度コピーしてやり直すのが大切やね！
------------------------------------------------

<Excelからキャラデータの読み込み>---------------
キャラ毎にシートをわけてやろう。
準備の仕方は、canversationdata.txtの方に書いて
あるので、確認しながらやろう。

テストでシートを2枚用意して、[CharaUni]と[CharaDemo]とする。

Character.xlsで保存して、Unity側ではCharacterListという名前でimport処理をする。
エラーのでているパスを修正して、
.assetをつくってResourcesファイルに移動させる。

PopList.csを更に修正して、ジェネリック化を進めました。

あとは、CharaBase.csでデータを読み込みたいから
TextPopPrefabをアタッチしたい
→Resourcesファイルからの読み込みに変えよう。
現在、TextPopのプレハブは、普通のプレハブファイルに入れているが、これを移動させる。
これにより、TextMng.csでの読み込み方も変わった。

*名称変更*
TextPop.prefab→DataPop.prefab

CharaBase.csで追加した処理
DataPopPrefab_ = Resources.Load("DataPop") as GameObject;

var popCharacter_ = DataPopPrefab_.GetComponent<PopList>().GetData<CharacterList>(PopList.ListData.CHARACTER,0,name);

popCharacterでデータが読み込まれているのを確認できたから、あとはCharacterSettingの項目を増やして
該当するデータを当てはめていくだけ。

Chara.csでデバッグログで試しに数値を出してみるとうまくいった。

※Excel読み込みの際に空白行まで読み込まれてしまったときがあった。その際は、行自体を右クリックから削除を選択する事で、消すことができた。
------------------------------------------------

<キャラデータの書き出し>------------------------
知識0です。調べよ。

参照したもの↓
https://teratail.com/questions/134584

.csv形式にはなってしまうが、十分かな？

キャラステータスに関しては、初回の読み込みは
Excelの.xls形式だが、セーブ/ロードに関しては
.csvのほうが読み込み速度と書き込み速度を考えるといいかもしれない。

敵とかアイテムは普通にExcelだなって感じ。
→保存するわけではないから。
使い分けが大事。

データの書き出しテストをChara.csに残しておくのでまたセーブとかロード機能を追加するときには確認しておく事。

------------------------------------------------

<戦闘コマンドに枠をつける>----------------------

一番上に来ているコマンドに大枠をつけるようにしたい。ButtleUICanvasにFrameという名前でImageを追加
そこに枠として使う画像をアタッチする。
(frame_command.png)を大枠として使用中。

また、テスト画像だからいいの.pngも画像差し替え。
(frame_allCommand.png)を使用するように変更。

全体的にコマンドサイズを大きくしました。
[Frame]
Pos X:1.2 Y:-91 Z:0
Scale X:1.5 Y:1.5 Z:1

[Image]
Pos X:0 Y:-230 Z:0
Scale X:4 Y:4 Z:1

------------------------------------------------

<CameraMng.csの変更点に伴い、CameraControllerに
 アタッチ箇所ができた>--------------------------

ヒエラルキーのCameraControllerについている
CameraMng.csのアタッチ箇所について。
MainCamera →MainCamera
SubCamera  →ButtleCamera
をつけるようにすること！

------------------------------------------------

<CameraMng.csでUpdate関数を通さずにカメラ切替>--

Update関数の多用が処理速度に影響を及ぼすので、
削減できるところを探していく。
とくにCameraMng.csのカメラ切替は外部からSet関数を呼んで切替したほうがUpdate関数を通すより効率がよさそう。

SetChangeCameraという関数をCameraMng.csに新規で用意しておき、GoThroughCheck.csやFieldMng.csで
呼び出すようにした。これによりUpdate関数が不必要になり、削減に成功した。

------------------------------------------------

<キャラの移動速度に差を設ける>-------------------
現在、街での移動速度を速めているが、これがフィールド移動でも同じ速度だと速すぎるので、処理を追加して速度差をつける。

FieldMng.csに新規でpublic static charaRunSpeed
という変数を用意して、switch文の中でそれぞれ速度を設定する。

それをUnitychanController.csの中でボタン押下時に
移動速度を入れているところに変数を呼び出していれるようにすればいい。
// 上キー or 下キー
movedir.z =
Input.GetAxis("Vertical") * FieldMng.charaRunSpeed;

みたいな感じで書くようにした。
これにより、MODE毎でキャラ速度の調整ができるようになった。

------------------------------------------------

<CharacterMng.csのUpdate関数を削除>-------------

もともとこのスクリプトのUpdate内容が、バトル開始時の行動キャラを設定してるだけだったので、
ButtleSetCallOnce関数の最初に
nowTurnChar_ = CharcterNum.UNI;
を書くだけでよかった。
なんでUpdate関数なんて使ってたんや・・・。

-----------------------------------------------

<敵を全て倒したら、カメラを戻して移動可能にする>-

EnemySelect.csのResetSelectPointの返り値をboolに
して、敵が0体ならforeach文の下にくるのでfalseを
返すようにする。

あとは、CharacterMng.csのAttackStart関数で
ResetSelectPoint関数を呼び出している所でif文を入れてfalseなら、nowModeをSEARCHにするように書く。

ただし、これだと敵に攻撃を始めた瞬間にMODEが切り替わってしまうので対処が必要。

<敵を倒した後に切り替わるように修正する>
(方針)
CharacterMng.csのAttackStart関数では戦闘終了フラグを立てるだけにしておいて、
ButtleMng.csで上記のフラグを参照して
フラグがtrueなら定期的にタグで敵の数を調べるようにする

(実装)
CharacterMng.csにlastEnemytoAttackFlg_という
変数を追加し、AttackStart関数の中で
ResetSelectPoint関数の返り値の内容によって
フラグが切り替わるように処理を書く。
※戦闘のはじめに毎回初期化されるように、　　ButtleSetCallOnce関数ではfalseにする
そして、GetLastEnemyToAttackFlgという関数を用意しておく。

ButtleMng.csのUpdate関数内で、
GetLastEnemyToAttackFlg関数を呼び出し、
trueの時に"Enemy"というタグが付いたオブジェクトを
探すようにし、該当しない時にnowModeをSEARCHに
するように記述する。

敵の処理を追加したらまた修正が必要になるが、
仮作成は完了した。
------------------------------------------------

<戦闘モードから探索モードに戻って、また戦闘に
 入ると行動キャラがずれるバグ>-------------------

(原因)
CharacterMng.csのButtle関数のelse側にある
ChangeNextChara関数の状態がバトルが終わった後
初期化されないから。

(対処法)
Chara.csに、SetTurnInitという関数を用意し、
フラグや値を初期値にして入れておく。
それをCharacterMng.csのButtleSetCallOnce関数の
foreach文内で呼び出し、値を初期化すればよい。

------------------------------------------------

<戦闘で敵の数が変わるとエラーがでる>-------------
(原因)
EnemySelect.csのselectNum_を戦闘開始時に初期化
していなかったから。

(対処法)
SetPosList関数内で、矢印の初期位置を設定している
ところに一緒にいれて
selectNum_ = 0;としておく。

------------------------------------------------

<逃走コマンドを防御コマンドに変更>---------------
ImageRotate.csにあるenum COMMANDの
ESCAPEをBARRIERに変更した。
これにより、CharacterMng.csのswitch文も一部変更
が行われた。

------------------------------------------------

<敵選択中は、コマンドを消す>---------------------
ImageRotate.csのSetRotaFlg関数に
this.gameObject.SetActive(flag);という処理を
追加する。

ヒエラルキーのButtleUICanvasを修正する。
空のオブジェクトで子に[Command]と追加し、
それの子に[Frame]と[Image]を入れる。

もともとbuttleCommandUI_変数と命名していたものを
[buttleCommandRotate_]に変更する。
※CharacterMng.csとButtleMng.csで設定変更

CharacterMng.csでは、
新規に[buttleCommandUI_]変数をつくって
[Command]をFindするようにしておく。
あとは、[buttleCommandRotate_]と同じタイミングで
SetActiveを切り替えるように処理を書き加えれば修正できる。
※CharacterMng.csで表示管理するのが気に食わない
　から変更するかも

------------------------------------------------

<にげるボタンとコマンド選択へ戻るボタンの案内>---
案内の文章がでるように処理を追加していく。
ヒエラルキーのButtleUICanvasの中に
[AnoounceImage(Image)]と
[AnnounceText(TextMeshPro)]を
追加する。

[AnnounceText(TextMeshPro)]は
フォントを[komorebi-gothic]に変更する。

2つの案内は、表示位置を変えずに文字だけ変えるようにする。

CharacterMng.csにTMPro.TextMeshProUGUI
buttleAnounceText_変数を用意して、
Start関数で 
buttleAnounceText_ = buttleUICanvas.transform.Find("AnnounceText").GetComponent<TMPro.TextMeshProUGUI>();
という風に読み取りをする。
あとは、この文字を状態に合わせて変更する。

buttleAnounceText_.textの内容を、
ButtleSetCallOnce関数やButtle関数で呼びだすようにする。

[AnnounceImage]
Pos X:300 Y:-165 Z:0
Width:260 Height:68
Image画像は[frame_name.png]を使用

[AnnounceText]
Pos X:350 Y:-170 Z:0
Width:200 Height:50
テキスト内容はCharacterMng.csで状況によって変更

※readonlyの文字を入れる配列をつくって、
　直接文字入力していたところを変数に置き換えた。

-----------------------------------------------

<逃げるコマンドの実装>--------------------------
戦闘時に、左シフトキーを押したら戦闘から逃げられるようにする。

CharacterMng.csのButtle関数内で処理を追加する。
// 戦闘から逃げる
if(!selectFlg_ && Input.GetKeyDown(KeyCode.LeftShift))
{
    // 敵オブジェクトを削除する(タグ検索)
    foreach (GameObject obj in     GameObject.FindGameObjectsWithTag("Enemy"))
    {
        Destroy(obj);
    }
 FieldMng.nowMode = FieldMng.MODE.SEARCH;
            Debug.Log("Uniは逃げ出した");
}

上記のように、タグで敵を検索して残っている敵を
削除する必要がある。

-----------------------------------------------

<RectTransformの変更>--------------------------
アンカープリセットを設定しておくと、
画面サイズが変わったときにも画像位置がずれないですむから。ちゃんとしようね。

[Command]→下中央
[FieldUICanvasのImage]→右下
[AnnounceImage]→右下
[AnnounceText]→右下

-----------------------------------------------

<フィールドを作成する>--------------------------
LowPolyEnvironmentPackを使って作成する。
中にDemoSceneが3つあったので、その3番目を丸コピ
してきたあとに、terrainだけ削除して作り直す。

terrainのデータに[unitydataField]と命名して
Field-Mapフォルダ内に入れておく。

まずはterrainのサイズを100*100に修正して、
PosをX:-50 Y:0 Z:-25
にする。

[1つ目の地面]
　Assets-Field-Map-ADG_Textures-ground_vol1-
  ground6にある[ground6_Diffuse.tga]にする
[2つ目の地面]
　Assets-Field-Map-ADG_Textures-ground_vol1-
  ground1にある[ground1_Diffuse.tga]

※それぞれ、同じファイル内にあるNormalMapも入れる

<変更した画像のサイズが1024*1024なので小さくする>
画像サイズが大きすぎると容量が大きくなる。
なので、対策が必要

テクスチャをクリックすると、
Defaultという項目の中に[MaxSize]というのがある
これが1024→32にしてApplyボタンを押すと小さく
できる。しかし画質が荒くなる。
ここは見栄えで考えること

①→32に変更
②→64に変更

Terrainに草を追加する
街に使用していたのと同じものを使用する
[GrassLow]と[GrassTall]

岩2つと落ちてる木の枝1つに個別でコライダーつけた

メモ：
①MainCameraのposとrotation変更あり
Pos  X:0  Y:3 Z:1
Rota X:30 Y:0 Z:0

②ButtleCameraのposとrotation変更あり
Pos  X:4  Y:2 Z:7.5
Rota X:15 Y:-60 Z:0

③Uniの初期座標変更あり
Pos  X:0  Y:0 Z:4

④ButtleWarpPointPack初期座標変更あり
Pos  X:0  Y:0 Z:8

⑤EnemyInstancePointPack初期座標変更あり
Pos  X:0  Y:0 Z:11
-----------------------------------------------

<SceneMngを作成する>---------------------------
参照したもの↓
https://gametukurikata.com/program/data

新規Scriptで[SceneMng.cs]をつくってこれにアタッチ

[SceneMng.cs]に
publicのenumで、SCENEというのを作成して
TOWN,FIELD,MAXを用意する。
staticのnowScene変数を用意して、外部から切替られるようにしておく。

<FieldMng.csでの処理を移植してくる>
キャラの移動速度の設定をSceneMng.cs側でやるように
変更する。
これに伴い、UnitychanController.csも
 * SceneMng.charaRunSpeedに変更する

SceneMng.csにSetNowScene関数を作成して、
これを外部で呼んで現在のシーンを切り替えるようにする。

towndataにTownMngオブジェクトを作って
TownMng.csを新規作成する

TownMng.csとFieldMng.csのStart関数内で
SetNowScene関数を呼び出すようにした。

また、SceneLoadUnLoad関数も作ったから
これでシーンの切替ができる

※キャラクター初期座標設定にも使えるかも
　
------------------------------------------------

<コマンドの表示非表示管理をButtleMng.csに統一>--
CharacterMng.cs側にGetSelectFlg関数を用意し、
ButtleMng.csでbuttleCommandUI_変数を用意した後に
Update関数内でフラグ状態を受け取ってSetActiveを
設定するように変更。

※ついでに、ImageRotateはCharacterMng.cs側で
　完全に管理するようにButtleMng.csから移植した

------------------------------------------------

<戦闘終了後に、歩いていたところまで戻す>---------
CharacterMng.csに新規でkeepFieldPos_変数を作成し
ButtleSetCallOnce関数で座標を一時保存する。

その後、
①戦闘から逃げたとき
②敵を全て倒した時
に一時保存していた座標を入れてあげるようにする。

①についてはButtle関数内で戦闘から逃げるという
処理のなかに
charMap_[CharcterNum.UNI].gameObject.transform.position = keepFieldPos_;
という一文を追加する

②についてはpublicでSetCharaFieldPos関数を用意し
ButtleMng.csのFieldMng.nowModeをSEARCHに変更している下の行で呼びだすようにする。

これで①,②の場合にキャラを移動していた位置まで
戻してあげる事が出来た
------------------------------------------------

<戦闘前にキャラがスーーッと移動してしまう>-------
参照したもの↓
https://teratail.com/questions/105824

(原因)
RigidBodyの慣性が働いていたから

(対処法)
上記のサイトに書いてある通り、
ピタッと止めたい位置に
rigid.velocity = Vector3.zero;
rigid.angularVelocity = Vector3.zero;
という処理を入れる。

今回は、UnitychanController.csのUpdate関数にある
if(FieldMng.nowMode != FieldMng.MODE.SEARCH)
の中に記述するのが正しい。

これでスーーと移動するのを止められた。

------------------------------------------------

<キャラがアニメーション中に敵選択矢印が出るバグ>-
SPACEキー連打時に敵選択矢印が出せてしまう。

CharacterMng.csに新規にoldTurnChar_という変数を
作成した。

また、Chara.csにpublicでGetIsMove関数を作成した

これを使ってButtle関数のswitch文内に
自分の行動の前の人がアニメーションを終了している
かを調べるif文を追加した。

終了している場合だけselectFlg_をtrueにするように
修正した。

これによりSPACEキーを連打しても敵選択矢印が
でてくるのを防ぐことができた。

------------------------------------------------

<フィールドで探索中にキー押下でメニュー画面切替>-
探索中に指定キーの押下でメニュー画面が出るように
設定する。

FieldMng.csのUpdate関数にあるswitch文に
MODE.MENUのcase文を追加する。

(テスト)
同じUpdate関数内でTABキーを押した時に
nowModeをMENUにしてみる。
→成功

次に、メニュー画面用のCanvasを用意する。
ヒエラルキーに[MenuUICanvas(Canvas)]を作成する。
今作成した[MenuUICanvas]に[BackPanel(Panel)]を
子として作成。
[BackPanel(Panel)]
色→黒
透過度→0.5

ただし、このままではFieldUICanvasがMenuUICanvasの上に来てしまう
→[MenuUICanvas]のCanvas設定にあるSortOrderを
  [1]にすることで解決

再びFieldMng.csの処理の追加に戻る。
public変数でmenuUICanvasを作り、ヒエラルキー上のFieldMngに外部からmenuUICanvasをアタッチできるようにする。

あとは、Start関数でmenuUICanvasのSetActiveを
falseにしておき、TABキーを押下時にtrueにする。
※trueにするのはswitch文内

※将来的にBackPanelは撤去して、
　ちゃんとメニュー背景画像を用意する

------------------------------------------------

<FieldMng.csのUpdate関数を修正する>-------------

Switch文が毎フレーム呼ばれる意味をあんまり感じないので修正する。ボタン押下と、時間の加算との処理だけ毎フレーム呼ばれるようにしておきたい。

変数でoldModeを作成して、前回のModeと不一致の時に
ChangeMode関数を呼び出すようにした。
ChangeMode関数では、Switch文処理を入れている。

このままでは時間加算処理がうまくいかないため、
Update関数内にSEARCHモード中にTABキーを押したら
MenuUICanvasを表示させるif文内に、時間加算処理も
まとめていれてあげる。

------------------------------------------------

<メニュー画面にセーブとステータス確認ボタン配置>-
MenuUICanvasに[SaveButton(Button)]と[StatusButton(Button)]を用意する。

ボタン押下時の処理をつくるために、[MenuMng.cs]を作り、[MenuUICanvas]にアタッチする

[MenuMng.cs]にはOnClickStatus関数と、OnClickSave
関数を用意した。

[SaveButton(Button)]と[StatusButton(Button)]の
OnClick()の＋ボタンを押して、[MenuUICanvas]を
引っ張って中にいれる。
NoFunctionのタブからMenuMng.csを選択して、
それぞれ用意した関数を中にいれたら終了。

------------------------------------------------

<MenuMng.csでキャラステータスを表示するにあたり、 情報の作成と引っ張り方を修正していく>-----------

(設計予定)
SceneMngでキャラ情報を初期作成して、
CharacterMngとMenuMngに情報引っ張る
情報の更新があったらSceneMngに渡す。

<CharacterMng.csとSceneMng.cs修正>
①SceneMngは、空のオブジェクトとしてヒエラルキー
　に配置し、アタッチでキャラクターを入れる。
  Awake関数でシーンを跨いでも消えないものにする。
→いままでCharacterMngにしていたアタッチ

②SceneMng.csのAwake内でcharMap_とcharasList_の
　設定をして、Get関数をそれぞれreturnできるように
　用意し、CharacterMng.csのStart関数で呼び出す
　仕組みに変更

これで、いままで通りのキャラ操作状態に戻る。

------------------------------------------------

<ステータスボタンでキャラステータスを表示する>---
情報はSceneMng.csから引っ張ってくるようにする。
①Chara.csにGetCharaSetting関数を作り、
　returnでset_を返す
②SceneMng.csにGetCharasSettings関数を作り、
　returnでcharasList_[num].GetCharaSetting()と
　する
③MenuMng.csで②を呼び出し、引数に読み込みたい
　キャラの番号を入れたらよい

つぎに、画面上に取得した情報を表示させる。
[MenuUICanvas]に[StatusInfo(TextMeshPro)]を
追加する。
※フォントは木漏れ日ゴシックにする！

MenuMng.csにprivate変数でstatusInfo_を作成し、
Start関数でFindを使いテキスト部分を取得しておく。

OnClickStatus関数で
SceneMng.GetCharasSettings((int)SceneMng.CharcterNum.UNI);というSceneMng.cs側の関数を呼び出し、情報をもらってきたらstringにその情報をまとめて表示する文字を作る。
※今はUNIの情報を指定して取り出すようにしている

あとはstatusInfo_.textにstringを代入するだけ。

------------------------------------------------

<メニュー画面のボタン表示/非表示を制御する>------
今のままでは、ボタンを押してもずっとボタンが残り続けてしまうので、修正していく。

[StatusButton]と[SaveButton]の親として、
[Buttons]という空のオブジェクトを用意する。

MenuMng.csにprivate変数でbuttons_を用意し、
Start関数でFind取得しておく。
あとはこのbuttons_をOnClickStatus関数でSetActiveをfalseにし、

キャンセルボタンでtrueにする。

------------------------------------------------

<メニュー画面にキャンセルボタンを作成>-----------
Buttonsの中には含めない[CancelButton(Button)]
を新規につくる。

キャンセルボタンは、
・ステータス画面内ならボタン選択に戻る
・ボタン選択画面ならフィールド画面に戻る
というように、場合によって用途を分ける。

OnClickCancel関数を作成し、[CancelButton]に
アタッチする。
OnClickCancel関数ではbuttons_のアクティブ状態で
if文の処理を行う。
※フィールドに戻すときはFieldMng.csのSEARCHの
　switch文でMenuUICanvasを非表示に切り替える

------------------------------------------------

<セーブボタン押下でステータスをCSV形式で保存>----
MenuMng.csに
using System.IO;
を追加して、OnClickSave関数でデータの書き込み
テストを追加した。
※現在は、設定上Assetsフォルダの直下に
　[saveData.csv]というテキストが作成される

------------------------------------------------

<SceneMng.csのキャラ情報がSceneを跨ぐとMissingになるバグ>---------------------------------------

(原因)
キャラのオブジェクト情報がうまく持ち越せていない
→「オブジェクト」というのがたぶんポイント

(対処法)
各SceneにSceneMngは配置しておき、シングルトンで
複数回生成されるのを防ぐ。

そして、Missingになるキャラのオブジェクト情報は
必ず持ち越す必要があるものではなかったため、
Scene毎にcharMap_とcharasList_をnullじゃないときは削除して、再設定しなおすように処理を修正した。
※ここでいう再設定とは、SceneMng.csの引数である
　オブジェクトのこと

<シングルトンのやりかた>
シングルトンにしたいクラスに
public static 該当スクリプト名 singleton;
という変数を用意して、
Awake関数内で、
if (singleton == null)
{
 //シーンを跨いでも消えないオブジェクトに設定する
    DontDestroyOnLoad(gameObject);
    singleton = this;
}
else
{
 //既にGameStartスクリプトがあれば
   このシーンの同じゲームオブジェクトを削除
    Destroy(gameObject);
}
という処理を行えばよい。

------------------------------------------------

<Sceneのアンロードについて>---------------------
アンロード処理が明示的に必要なのは、
シーンを複数同時に開いているときのみみたいだった
※警告がでていたので調べてみた

今回の場合は複数同時立ち上げではないため
普通にLoad処理のみで良さそうだった。

------------------------------------------------

<キャラステータス値を別スクリプトで管理する>-----
(SceneMng.csで管理できない理由)
オブジェクト情報がMissingになり、キャラデータの
保存がうまくいかない。
※キャラ生成はできるけど、中のデータがない感じ

(対処法)
CharaData.csという新規Scriptを作成し、
SceneMng.csで毎回キャラデータが初期化されてしまう
前に、データを避難させられるようにする。
そして、初期化の値が入った後に正式な引継ぎデータを代入するように処理を書く。

(具体的な方法)
①CharaData.csにSetCharaDataとGetCharaData関数
　を用意しておく

②SceneMng.csで、singletonがnullのときは
　初回登録なのでSetCharaDataに初期値を入れる

③②の2回目以降はChara.csにSetCharaSetting関数
　を用意しておき、CharaData.GetCharaData関数の
　値を引き渡すようにする

④SceneMng.csのロード処理時に遷移する前に
　CharaData.SetCharaData関数を呼び出し、
　ステータス値を避難させておく
　※これのおかげでSceneが切り替わった後に
　また同じ値が引き継げるようになる

※今は直値でUniのステータス値しか引き継げないけど
　ここを他のキャラも含められるようにする

-----------------------------------------------

<戦闘中のキャラアイコン枠を作成>----------------
素材サイト↓
https://azukichi.net/frame_elegant.html

ButtlUICanvasの子に[CharaStatusFrame(Image)]
を作成し、
[CharaStatusFrame(Image)]の子に
[FrameBackPanel(Panel)]をアタッチする。

[CharaStatusFrame(Image)]には
[ButtleCharaFrame]をアタッチして、
画質を[128]まで落とす。
→画像のDefaultにあるMaxSizeの話

[FrameBackPanel(Panel)]は
ImageTypeをSlicedにしておき、
FillCenterにチェックありで、PixelsPerUnlitMultipilerを[0.15]にする。

[CharaStatusFrame(Image)]の設定
AncerPoint 左下
Pos   X:100 Y:40  Z:0
Scale X:1.5 Y:0.7 Z:1
画質[128]

次に
ButtlUICanvasの子に[CharaIconFrame(Image)]
を作成し、[CharaIconFrame(Image)]の子に
[FrameBackPanel(Panel)]をアタッチする。

[CharaIconFrame(Image)]には
[frame_command]をアタッチする。

[CharaIconFrame(Image)]の設定
AncerPoint 左下
Pos   X:40  Y:40  Z:0
Scale X:0.8 Y:0.8 Z:1

これで、あとは[CharaIconFrame(Image)]の中に
キャラの画像を入れれば良い。
※[CharaIconFrame(Image)]につけているBackPanelは
　最終的にキャラ画像と丸っと入れ替える予定。

------------------------------------------------

<街からフィールド入り、戦闘になるとアニメーターで エラーがでる>----------------------------------

(原因)
SceneMng.csで
charasList_[0].SetCharaSetting(CharaData.GetCharaData());
と書いているときにアニメーターを代入してnullに
なってしまっていた。
→アニメーターは引継ぎデータに含めてないから

(対処法)
Chara.csのSetCharaSetting関数で
アニメーターだけ設定しないように修正

------------------------------------------------

<文字フォントとフォントサイズ変更>---------------
ButtleUICanvasのAnnouceTextのTextMeshProを
フォント　　　[NewMplus-1-Medium]
フォントサイズ[18]
とする。
------------------------------------------------

<ButtleCamera画角変更>--------------------------

Position  X:4  Y:2.6 Z:7.5
Rotation  X:25 Y:-60 Z:0

------------------------------------------------

<ジャックとDemoを入れ替える>--------------------

*重要*
①ジャックのScaleを[1.2]にする
②AnimatorのApplyRootMotionのチェックをはずす

プレハブをヒエラルキーにおきunpack
AnimatorのControllerが入っていないので
ひとまずUnitychanAnimatorを入れとく。

Demoと同じScriptをアタッチする
※_faceはjack_faceがあったのでそれを使う。

SceneMngの外部アタッチでCharaObjListの
Element1を、DemoからJackに変更する。
※全てのSceneMngを置いているシーンで入れ替える

また、SceneMng.csのキャラクターの種類を
DEMO→JACKに変更する。

ExcelのChara.xlsのCharaDemoをCharaJackに変えて、
Character_importer.csのCharaDemoをCharaJackに
する。そしてreimport。

ここまででUniとおんなじモーションをするようには
なった。次は武器持たせてモーション変更をさせる。

------------------------------------------------

<ジャックに武器を持たせる(右片手斧)>-------------

使用する武器
Assets/Blink/Art/Weapons/LowPoly/FreeRPGWeapons
にある、Axes/Axe1h.fbx

右手の位置とか設定の仕方は、
https://unity-shoshinsha.biz/archives/987
を参考にしてやる。

[Axe1h]
Layer:Weapon
Position  X:0.03  Y:0.05 Z:-0.035
Rotation  X:180   Y:0    Z:0
Scale     X:1     Y:1    Z:1

使用マテリアル
Axe_1H_Epic

------------------------------------------------

<ジャックのモーションを作成する>-----------------

<攻撃モーション>
使用するモーション
Asset/ExplosiveLLC/WarriorPackBundle2FREE/
KnightWarriorMecanimAnimationPack/Animations

※使用するAnimations以外のフォルダは
　全部消しました

三角タブを開いた中にある、[三△]のアイコンのやつ

①UnitychanAnimator.controllerを複製して、
　JackAnimator.controllerとする。

②Animator編集画面を開いて、それぞれの項目の
　Motionだけ変更していく

<変更点>Motionのみ使用するモーションのやつに変更
Standiong@loop → Idle
Attack         → Attack1
Running@loop   → Run

③①をジャックのAnimatorControllerに設定する


エラーで、
[AnimationEvent 'Hit' on animation 'Attack1' has no receiver! Are you missing a component?]
というのがでるから直す。

参考サイト↓
https://obenkyolab.com/?p=2112

AnimationのInspectorからEventを削除しないとダメ

①攻撃モーションのやつを複製して、
  [Jack@Attack1]という名前にする

②Attack1のEditを押してEventsを開く

③真ん中らへんに棒が入ってるのを右クリックして
　Deleteする

④Applyをおして、このAttack1をAnimatorのAttackに
　設定する

ついでにRunのEventsもDeleteしてAnimator入れ替え
[Jack@Run]を作成する

------------------------------------------------

<ジャックの攻撃について考える>-------------------

ジャックの場合は、
Run→Attack1→BackStep
となるから、ユニのようにいきなりattackを出せない

<CharacterMng.cs>

Chara.csのAttack関数を呼ぶ前に、
移動させる処理が必要

(方針)
移動させる処理のほうにキャラの位置と敵の位置の
取得、それからキャラの向きを変える処理を移して
AttackStart関数は攻撃のみにしたほうがいい。

AttackStart関数でUNIの攻撃かJACKの攻撃かを
if文でわけるようにする。

(実装)
BeforeAttack関数を新規で作成し、
このなかに
①キャラの位置取得
②敵の位置の取得
③キャラの向きを変える処理
を入れる。
①と②はprivate変数を作ってそのなかに代入する

さらに、ジャックであれば、敵に向かって走る処理を
いれる

<敵に向かって走る処理>
指定座標とかをするのならVector3.Distanceを使うといいらしい。
参考サイト↓
https://teratail.com/questions/93794

オブジェクトのいろいろな移動方法↓
https://3dcg-school.pro/unity-object-move-beginner/#MoveTowards

まずはInterfaceButtle.csに
(Vector3, bool) RunMove(float time,Vector3 myPos, Vector3 targetPos);
を追加する。

次にChara.csにRunMove関数の内部処理を書く。
引数で時間と現在キャラ座標と目標的座標をもらって
Vector3.Distanceで目的地までとの差分をみて、
差があるときはLerp関数で距離を詰めるようにする。

ただし、Chara.csからキャラ座標はいじれないため
returnで値を返すだけにする。

最後にBeforeAttack関数でジャックの
行動ターンなら新規でつくったコルーチンの
MoveToEnemyPosを呼び出すようにする。
※このMoveToEnemyPosの中でRunMoveを呼び出してる。

あとは移動時のRunモーションの後に、
攻撃モーションが来るようにする。

<Run->Attackの流れをつくる>
<CharacterMng.cs>
runToAttackChageFlg_変数を作成し、
これがtrueになったら攻撃モーションへ移行する。
という処理を書いていく。

途中だいぶいろいろ処理の置き場所を変えました…

<Chara.cs>
ChangeNextChara関数の中の順番をちょこちょこ変更

あとはRunMoveのdistanceのif文で
0.0fと比較すると敵と衝突してふわふわ飛んでくから
1.5fぐらいにしとくべし。

そろそろanimTimeMaxをExcelから読み込めるように
したほうがよさげ

<攻撃後の処理>
無料版にバックステップなんてありませんでした。
ジャンプで帰ってくる感じにしようかなぁ。

なんかもう処理をいろいろ修正した。
一番大きい変化はANIMATIONenumを作成して、
これの順番でキャラがアニメーションするようにした
処理としてはだいぶ読みやすくなったと思う。

※Attackから戻るところアニメーションが
　まだできてないから土日で終わらせる

------------------------------------------------

<ジャックのAfterAttackにジャンプを追加する>------

ジャンプMotionは
KnightWarriorのJumpを使用する。
コピペして[Jack@Jump]に変更し、Eventsを削除する。
※もともとEvents設定なかったからそのままでおｋ

Animatorに[Jamp][Land]を追加して、
Attack->Jump->Land->Standingとなるようにつなぐ。
※AttackからStandingの繋ぎを消す

Attack->Jump->Land->Standingの部分の
ConditionsにisAttackがfalseになったときと設定する
(合ってるかわからん)

また、Attack->JumpのHasExitTimeのチェックを
外しておく。

Attack後の硬直をどうしたら直せるのか。
(原因)
現状だとanimTimeが2.0f以上にならないとkey_isAttackがfalseにならないから、
falseへ変わらないとジャンプ処理に入らないからね…

(対処法)
animTimeMaxをExcel読み込みにしよう

------------------------------------------------

<Character.xlsの修正と追加を行う>---------------

<削除する項目>
・Constitution
・Power

<追加項目>
・AnimMax
→攻撃モーションの終了時間を入れる

それぞれの攻撃モーション時間
ユニ　　：40フレームだから、0.67
ジャック：30フレームだから、0.50
→0.5にしたらモーションの余韻がなくてあれだから
　1.0にしよう

<CharacterList.cs>
public int Constitutionと
public int Powerを削除して、
public float AnimMaxを追加する

<CharaBase.cs>
setting_の項目にあるConstitutionとPowerを削除して、AnimMaxを追加する

<Chara.cs>
SetCharaSetting関数の
ConstitutionとPowerを削除して、AnimMaxを追加する

ChangeNextChara関数のset_.animTime < 2.0fを
set_.animTime < set_.AnimMaxに変更する。

<MenuActive.cs>
ConstitutionとPowerを削除
※AnimMaxは追加しない

<Character_importer.cs>
ConstitutionとPowerを削除して、AnimMaxを追加する
※GetCellの番号を変えるのを忘れずに

あとは.xlsをreimportする。

------------------------------------------------

<スペースキー連打したら攻撃モーションがバグる>---

(原因)
攻撃モーションへ移行する条件式の不足

(対処法)
CharacterMng.csのButtle関数でcase ATTACKの際、
selectFlg_がfalseでanim_を切り替えるには、
そもそも現在IDLEもしくはNONであるか確認する。
NONが必要なのは、コマンド選択へ戻った後再度処理が
できなくなるのを防ぐため。

そして、
selectFlg_がtrueでBeforeAttack関数を呼び出すとき
には、そもそも現在BEFOREであるか確認するように
if文を追加した。

------------------------------------------------

<Jackの武器に当たり判定を付ける>-----------------

右手につけたAxe1hに、BoxColliderをつける。

IsTrigger:チェックあり
Center   :X:0    Y:0.4  Z:0
Size     :X:0.35 Y:0.35 Z:0.05 

新規タグで[Weapon]を用意して、
斧と杖と、杖から発生する魔法(UniAttack)につける。
→UniAttackはプレハブフォルダ内にある

新規Scriptで、[CheckAttackHit.cs]を作成して
斧とUniAttackにアタッチする。

中ではMagicMove.csで行っていた当たり判定の確認と
SetTargetNum関数を入れた。
→MagicMove.csから同じ処理は削除した。

あとは、CharacterMng.csのAttackStart関数で
[Weapon]タグで検索してCheckAttackHit.csを取得し
SetTargetNum関数の設定を呼び出すようにする。


ついでに、ジャックが最後の敵を倒した時に探索画面に戻るタイミングがおかしかったため、

lastEnemytoAttackFlg_ = 
!buttleEnemySelect_.ResetSelectPoint();
この処理をAttackStart関数からAnimationChangeの
IDLEの中へ移した。
→これで、自分の定位置に戻ってから戦闘終了に
　できる。

------------------------------------------------

<戦闘時、キャラステータス表示場所のサイズを調整>-

画面サイズ的に再調整が必要になった。

[CharaStatusFrame]
Pos   X:230 Y:55 Z:0
Scale X:4   Y:1  Z:1

[CharaIconFrame]
Pos   X:60  Y:60   Z:0
Scale X:1.2 Y:1.2  Z:1

------------------------------------------------

<HP処理を追加する>------------------------------

学校で作成したプレハブとScriptをそれぞれのフォルダにいれる。

プレハブの[Slider]をButtleUICanvasにおいて
unpackし、プレハブフォルダから削除する
→名前を[HPSlider]に変更

[Uni]と[Jack]に[HPBar.cs]をアタッチして、
Sliderという引数には[HPSlider]をアタッチする。

[HPSlider]
Pos   X:300 Y:70 Z:0
Scale X:1.2 Y:2  Z:1

Eキー押下時にHPが減っていくテストを行った。

次に、最大HPとか現在のHPをキャラ毎のやつに置き換える必要がある
キャラに関しては、1つのHPバーを使いまわししたい。

現在行動中のキャラのHPにしたいから、
CharacterMng.csから現在行動中のキャラが誰なのかの
情報を引っ張ってくる必要がある。
いや、むしろHPBar.csをCharacterMng.csから呼び出して、nowchara != oldcharaのときに値設定するように
何か関数呼び出したほうがよさそう。

というか、[HPBar.cs]って、キャンバスに置いた
[HPBar]にアタッチしたほうが良くないか？？

<アタッチ箇所を変える>
HPBar.csを各キャラにつけていたのを外し、
ButtleUICanvas内のHPBarにアタッチする。
外部アタッチが必要なくなるからpublic変数をprivate変数にする。(Start関数でGetComponentへ)

CharacterMng.cs側からHPBar.csを呼び出すようにする
外部アタッチ方式で呼び出すようにしたほうがいい
→Findで探すと敵HPバーも見つけてしまいそうだから

<CharacterMng.cs>
public変数でcharaHPBarを作成。
ButtleSetCallOnce関数で、HPBar.csのSetHPBar関数
を呼び出す。

次にButtle関数内でダメージ処理を呼び出すように変更する。(もとはHPBar.csのUpdateにあったもの)

maxHPがわからないのが良くないから、Chara.csとCharaBase.csとInterfaceButtle.csに処理を追加する

<CharaBase.cs>
CharacterSettingにmaxHPとmaxMPの項目を追加し、
設定ではHPとMPを入れるようにする。

<InterfaceButtle.cs>
とりあえずMaxHP関数を追加する

<Chara.cs>
MaxHP関数を作成して、return set_.maxHP;とする

あとは、maxHPの設定ができるようにHPBar.csと
CharacterMng.csを修正して、
キャラクターが切り替わったときにもSetHPBar関数を
呼び出すようにする。
※SetHPBarでスライドバーへの反映を忘れないように

※DontDestroyCanvasのBagImageでパラメータの場所
　が見えなくなってるので、α値を0にしています

------------------------------------------------

<敵のインスタンス位置を再調整する>---------------

EnemyInstancePointPackの更新が必要になる

<3体のとき>
１　X:-3.5
２　X:-1
３　X:1.5

<4体のとき>
１　X:-4
２　X:-1.5
３　X:0
４　X:2

------------------------------------------------

<敵のHPバーの管理を行う>------------------------

敵のHPバーは、敵の頭上に置きたいからインスタンス方式でやる。

HPSliderをプレハブ化する。
→プレハブのままButtleUICanvasにも置いて、
　EnemyInstanceMng.csで外部アタッチ方式でプレハブ　を入れよう。そうしよう。

<EnemyInstanceMng.cs>
public変数でenemyHPBarを作成し、
EnemyInstance関数で敵のインスタンスと同時に
その頭上にHPバーをインスタンスするように設定。
→SetHPBarの数値は適当に・・・

インスタンスしたときにButtleUICanvasの子に
なるようにしよう。

EnemyInstance関数の引数にCanvas parentCanvas追加
呼び出し元のButtleMng.csでButtleUICanvasを設定し
Instantiate(enemyHPBar, pos, Quaternion.identity, parentCanvas.transform);
とする。
※ただし、これだと座標が全然敵の頭上にこないから
　調整が必要

<表示位置調整>
各表示位置を予め決めておいたほうがいいかも

<1体のとき>
X:1000 Y:530

<2体のとき>
X:870  Y:560
X:1030 Y:530

<3体のとき>
X:780  Y:570
X:940  Y:540
X:1150 Y:510

<4体のとき>
X:760  Y:580
X:830  Y:540
X:1000 Y:520
X:1170 Y:470

EnemyInstanceMng.csのStart関数でHPバー表示位置を
決定する

※ボスのHPは中央上部にするとか
敵の高さに合わせてHPバーのY軸は調整が必要に
なりそう

------------------------------------------------

<Enemy用のScriptをつくる>-----------------------

EnemyBase.csとEnemy.csが必要になってくる。
※基本のつくりはCharaBase.csとChara.cs参考

というか、CharaBaseって別にキャラだけじゃなくて
Enemyのベースとしても使えるよね。
※CharaBaseの引数にしてたCHARACTERNUMを削除
　それと入れ替えに、キャラなら0,敵なら1と入力
　するintを追加する。
　→データを取りに行くときのクラス型の指定分け用

名称変更してEnemyでも使えるようにしよ。
(とりあえず今はCharaBaseのまま使うよー)

<Enemy.cs(新規作成)>
基底クラスをCharaBaseとInterfaceButtleにして
必要な関数を一気に作成する(エラーでるからわかる)
※関数の中身はとりあえず適当に書いとく

EnemyInstanceMng.csでEnemyを呼び出す処理を書く
①enemyList_変数を作成する(charaList_と同様)
②EnemyInstance関数内で①をAddする
　→アニメーター情報がないからnullにしとく

Excel読み込み用に、敵の名前が必要になる。
番号でいろいろ指定してるところはあんまり
いじりたくないなぁ…
[番号_名前]みたいにして、使うときは"_"の前後で
わけようかな。
※これなら同じ敵が複数でも対応できるし
　→setting_.name = param.Name + "_" +name;
    という風にした。

<敵のExcelを作成する>
基本はキャラと同じで、+経験値と素材ドロップの
項目が必要になる。

新規で[Enemy.xls]を作成する。
フィールド毎にシートを分けたほうがいいから、
シート名はフィールド番号にする。
その後、import処理とエラーの対処をする。

Resourcesファイルに新規でEnemyDataファイルを作成して、Enemy_importer.csのexportPathの設定をする

PopLostにもEnemyを加える。

[EnemyInstanceMng.cs]
Enemy情報をリストに該当フィールド丸ごと入れたほうがいい。そこから取り出す感じにする。
→enemyData_変数を作成し、nullのときに
　書きこむようにする。

敵個別情報をCharaBase.csに持っていくために、
Enemy.csでは引数にEnemyList.Paramを追加する。
(Chara.csにはnullをいれる)

enemyList_.Add(new Enemy(enemy.name,1,null,enemyData_.param[0]));
という感じで書く。

フィールド単位で読み込んでおいて、一度保存した内容を使いまわす感じ。

------------------------------------------------

<キャラの攻撃で敵のHPが減るようにしたい>---------

そもそもまず、敵とHPバーを関連付ける必要がある。
→enemyList_をEnemyとHPBarのペアにする。
それに伴ってEnemyInstance関数も少し修正

いま敵オブジェクトを削除しているCheckAttackHit.cs
でHP減少処理をする。
※OnTriggerEnterの中に減少コルーチンを呼び出すと
　1フレームしか入らなくてうまくいかない。

CheckAttackHit.cs内でEnemyInstanceMng.csの関数を呼び出してそこでHPBar.csのコルーチンを呼び出す。
HPdecrease関数

そのままHPdecrease関数で敵オブジェクトとHPバーの
削除も行う

------------------------------------------------

<倒しきれてない敵が選択不可能になる>-------------

EnemySelect.csのGetSelectNum関数で
フラグをfalseにしているから。

ResetSelectPoint関数で、enemyList_を引っ張ってきてHPが0以下、かつ、まだフラグがtrueならfalseにする処理をいれる。

ここに入れる事で、敵を全て倒した時に探索画面に
戻る処理も続けて入るから楽になる。

------------------------------------------------

<ジャックの攻撃判定が2回起こる>------------------

当たり判定コライダーをON/OFF切り替わるようにする

攻撃Hit直後 → enable(false)
CheckAttackHit.csのOnTriggerEnter関数の中

攻撃直前    → enable(true)
CharacterMng.csのAttackStart関数の中

------------------------------------------------

<敵が複数体の時に、交互に攻撃して倒すと
 矢印が倒したはずの場所に出現する>---------------

(原因)
敵を倒した際の矢印フラグがうまくいってない
呼び出し順がわるい

矢印の再設定→HP減少処理の順になってるから
HP0の敵の場所にも矢印でてきちゃう

(対処法)
処理順を、HPの減少処理→矢印の再設定
になるようにする。

EnemyInstanceMng.csにpublic変数で外部アタッチ式のEnemySelectObjを用意する。
※表示/非表示の変更が多いものは外部アタッチと
　学んだからね

あとはHPdecrease関数内でResetSelectPoint関数を
呼び出すだけ。

------------------------------------------------

<敵をカボスにする>------------------------------
PictureにKabosu.pngを追加する。
マテリアルに貼り付けて敵として利用したいから、

sphereを[Enemy_Kabosu]と命名して、
Tagを[Enemy]にしてShaderをLegacyShaders/Diffuse
にする。
SphereColliderとRigidbodyをつけとく。

Kabosu.matというマテリアルを作成してShaderを
LegacyShader/Diffuseにする。Selectの所に
Kabosu.pngをいれてからEnemy_Kabosuにアタッチする

あとは、EnemyInstanceMngのEnemyCubeを
Enemy_Kabosuをアタッチするように変更する

EnemyCubeという名前も合わないからEnemyTestとした

------------------------------------------------

<宝箱の設置>------------------------------------

仮置きとしてCubeを[TreasureBox]とする。
→処理方法はさきちゃんの素材拾いと同じに

※クエスト１を受注中のみ設置されるようにする
宝箱をField0に設置して、
中からワード[炎]と、[ギルドテスト合格証]を入手

------------------------------------------------

<フィールドの歩き方を説明する>-------------------

chapterNumが8でForestFieldにきたら
ジャックと会話を挟む。

エンカウント率や素材取得方法をまとめた画像を用意する。

------------------------------------------------

<Chapter8の作成>--------------------------------
森の背景画像と、フィールド説明画像が必要になる。
(Forest.png  , FieldInfo.png)

Chapter.xlsにChapter8のシートを作成。
会話文を入れて、Chapter_importer.csに"8"を
追加する。そしてreimport

<森の背景画像>
使用画像
https://www.ac-illust.com/main/detail.php?id=2346343&word=%E6%A3%AE%E3%81%AE%E5%A5%A5

<イベントの設定>
FieldMng.csのStart関数に、
// イベントが発生するか確認する
if (EventMng.GetChapterNum() == 8)
{
  EventMng.SetChapterNum(8, 　SceneMng.SCENE.CONVERSATION);
}
を追加する。


<説明画像>
画像サイズを取得して貼り付け先のobjのサイズを変更するようにしたい

TextMng.csのCreateSprite関数に、
// 貼り付け先の画像サイズ変更
objectImageRect_.sizeDelta = new Vector2(texture.width, texture.height);
という処理を追加

※objectImageRect変数は、Start関数で
objectImageRect_ = ConversationCanvas.transform.Find("ObjectImage").GetComponent<RectTransform>();
という風にfindしている

------------------------------------------------

<チュートリアル戦闘>----------------------------

画像で用意して、戦い方を説明するようにしたい。
※いつでも確認できますみたいな。

------------------------------------------------

<戦闘中にユニの移動キーを押すと走るアニメーション
 になるバグ>------------------------------------

(原因)
UnitychanController.csのUpdate関数で戦闘中でも
キーが押されたらアニメーション切り替わるままに
なっているから。

(対処法)
Update関数の最初にSEARCHじゃないならreturnする
ように書いておく。

------------------------------------------------

<行動をspeed順にする>---------------------------
ButtleMng.csで行動順を管理するようにしたい。

<キャラのスピード値を引っ張ってくる>
①InterfaceButtle.csにint Speed();と
　string Name();追加する
②Chara.csにpublic int Speed()と
　public string Name()を実装する
③CharacterMng.csにCharaTurnSpeed関数を実装して
　引数にint num 返り値として
  名前と行動速度を返す
④ButtleMng.csで値とどのキャラかがわかるように
　目印をつけてListで値を保存する。
　→戦闘開始時に設定される項目にmoveTurnList_.Add
    の処理を入れる。

<敵のスピード値を引っ張ってくる>
①Chara.csに追加したのと同様の関数をEnemy.csに
　用意する
②EnemyInstanceMng.csにEnemyTurnSpeed関数を
　作成して、名前と行動速度を返す
  ※キャラの③と内容は同じ
③ButtleMng.csで敵の数分for文を回してキャラの④
　と同様の処理を行う。

※数値でソートするために、行動順,名前の順番で
　Addしないとだめだわ

ソートしたときに昇順になるから、
値が大きいほうを先に行動させるためにReverseして
降順に直す。

<実際の行動のところを処理する>
プレイヤーの行動と敵の行動を管理できるようにする

①ButtleMng.csにprivate int moveTurnCntを
　用意して、SetMoveTurn関数を用意。
　そのなかで値の加算を行う
　※各自行動が終わったらこの関数を呼び出す仕組み

②キャラが行動終わったときの処理
　CharacterMng.csのAnimatonChange関数にある
　case IDLEのところでbuttleMng_.SetMoveTurn関数
　を呼び出すようにする。
　※buttleMng_変数はFindするようにした。

③敵が行動終わったときの処理
　buttleMng_変数はFindするようにした。
　EnemyInstanceMng.csのAttack関数でSetMoveTurnを
　呼び出すようにする。

　※倒した敵は行動順から抜かないといけない
　→Attack関数でHP見てログ内容変更するようにした

<キャラが死亡中も行動順を飛ばしたい>
①CharacterMng.csのANIMATIONのenumにDEATHを追加　AnimationChangeにcase DEATHを入れとく。
　→中でIDLEになるように設定

②Buttle関数内にあるテストダメージ処理にHPが0以下
　になったらanim_ = ANIMATION.DEATHになるように
　する(HPの数値も0ぴったりにする)

③case文のIDLE内に、次のキャラにしたときにHPが
　0以下になっていたらanim_ = ANIMATION.DEATHを
　設定する

<次のキャラのHPバーも0になるバグ>
(原因)
コルーチンが原因ぽい。
0にしきるまえに次のキャラの行動に移ってた。

(対処法)
0になってから次のキャラの行動に移行するように修正
しないといけない。
コルーチンの終了判定をとったほうがいいのかも
→フラグでできた

①HPBar.csにcolFlg_変数を作成し、
　MoveSliderBar関数のwhile文ではtrueにしておき、
　抜けたところでfalseにする。

②GetColFlg関数を作成しておき、CharacterMng.csの
　Buttle関数でanim_==DEATHのときに呼び出す。
　trueならまだ減少処理中だからreturnし、
　falseならanim_=IDLEとする。
　※switch文のDEATHの内容が不必要になったから
　　コメントアウトしとく

------------------------------------------------

<ダメージ算出>----------------------------------
現在は固定値でダメージを出しているので、
これを[攻撃力-防御力]で計算されるように変更する。

<キャラから敵へのダメージ>
ButtleMng.cs経由で値を渡したほうがよさそう。

[キャラの攻撃力を渡す方法]
InterfaceButtle.csのDamage関数の返り値をintへ。
ButtleMng.csにSetDamageNum関数を作成しておき、
CharacterMng.csのcase文のATTACKで呼び出す。

[敵のダメージ処理]
EnemyInstanceMng.csのHPdecrease関数で処理する。
ButtleMng.csのGetDamageNum関数を引っ張ってきて、
自分のDefence-キャラからのダメージ値を計算する
※Defence関数の返り値をintに直す
→防御力が上回って減算の結果がマイナス値だったら
　0にするようにガード処理入れとく
あとは、固定値でダメージ入れてたところを変更
するだけ

[敵の攻撃力を渡す方法]
EnemyInstanceMng.csのAttack関数で
buttleMng_.SetDamageNum
(enemyList_[num].Item1.Damage());
を呼び出す。

[キャラのダメージ処理]
いまは当たった瞬間というのがないから手動で値を
貰う処理でテストする。

Buttle関数のテスト用ダメージ処理の中で、
敵と同じくダメージ値の算出を行い、
削るHP部分を修正したら終了。
→ちょっとHP減少処理のデバッグしづらくなったから
　注意

※カボス君の攻撃力低すぎたわ。値修正する
　6にしとこ

------------------------------------------------

<防御コマンドの実装>----------------------------

防御の時には自分の次のターンまで防御力を1.5倍に
する。
①Chara.csにbarrierNum_変数を用意する。
②Defence関数をreturn set_.Defence+barrierNum_へ
③SetBarrierNum関数を用意しとく
　※数値入力なしなら引数の値を0にするようにしとく
④CharacterMng.csのButtle関数で防御コマンド選択時
　に③を呼び出すようにしとく
　→引数は防御力/2
⑤AnimationChange関数で③の引数なしを呼び出す
　→引数なしなら0になるから防御解除ができる
⑥防御コマンド実行後は次のキャラor敵に行動が回る
　ように、anim_にIDLE,oldAnim_にNONを設定する。

確認しづらいけど、たぶん実装完了している。

------------------------------------------------

<敵の行動について>------------------------------
とりあえずカボスでも魔法の弾とばしてもらう。
テストでユニの通暁攻撃弾を複製して用意し、
[KabosuAttack]というプレハブにする。

CharacterMng.csに置いているenum ANIMATIONは
キャラも敵も共通で使うので、CharaBase.csにpublic
でおくように変更する。
CharacterMng.csとEnemyInstanceMng.csには
using static CharaBase;を記載する。

[EnemyInstanceMng.cs]
[SerializeField]で、
private GameObject kabosuAttackPrefab_;を追加し
Buttle関数やAnimationChange関数等を用意する。
(引数付きにして敵の番号を入れる)

Buttle関数内ではanim_がNONのときにはBEFOREにして
BeforeAttack関数を呼び出せるようにする。

BeforeAttack関数では、
①自分の位置を取得
②ランダムで選んだキャラの位置を取得
③体をむける
ところまでとりあえずやる。
→走る処理とかは、走る必要がある敵かどうか判別
　できるようにしたほうがいいかも。Excel読み込みで
　もしくは、アニメーション時間みたらわかるかもな

①について、
enemyPosSetMap_変数を利用できそう。
新規でmapNum_変数を追加して、敵のインスタンス数を
保存できるようにした。
②について、
SceneMng.charasList_[xx].GetButtlePos();で
取得できそう。
③について、
新規でenemyMap_変数を作成して、インスタンス時に
番号とGameObjectそのものを保存するようにした。
※最後にanim_をANIMATION.ATTACKにする。

次に、実際の攻撃処理をする
AttackStart関数を用意して、攻撃の弾を出すように
する。弾の方向計算やプレハブのインスタンスをする
→名前をKabosuAttack(Clone)とする
キャラ番号はCHARACTERNUMのenumでわかる。

[CheckAttackHit.cs]
OnTriggerEnter関数に
else if(col.CompareTag("Player"))を追加する。
HPの減少処理を書く必要がある。
GameObject.Fin("CharacterMng").
GetComponent<CharacterMng>().
HPdecrease(targetNum_);
とする。

[CharacterMng.cs]
HPdecrease関数を追加。
引数に入れられた番号のキャラのHPを減らす。
※処理内容はもともとButtle関数に書いていたものを
　転記した。

<当たり判定が発生しない>
UniとJackにPlayerというタグをつけるのを忘れてた

<敵の攻撃の次に他の敵が攻撃できるようにする>
AfterAttack関数を用意しておいて、中でIDLEに切替。
IDLE時のcase文に                buttleMng_.SetMoveTurn();
を入れておく。
ターン切替処理の後にanim_をNONにしておく。

攻撃モーションが終了しているかの確認関数が必要。
Enemy.csにChangeNextChara関数の中身を作成
→キャラと同じでよい。
あとはButtle関数で
if (anim_ == ANIMATION.ATTACK &&
　　enemyList_[num].Item1.ChangeNextChara())
{
    anim_ = ANIMATION.AFTER;
}
として、anim_をAFTERへ切り替えられるようにする。
※Enemy.xlsのKabosuのAnimMaxを0.67にする。

<魔法の弾の発生位置が敵より後ろになるバグ>
キャラとエフェクトの発生方向が逆だから、
forwardの加算/減算に気を付ける
→Z軸はマイナスしないとだめ

<攻撃対象をランダムにする>
ランダムについての解説サイト↓
https://xr-hub.com/archives/10747

[EnemyInstanceMng.cs]
Start関数で、      
Random.InitState(System.DateTime.Now.Millisecond);
としておき、現在の時間でランダムの種をつくる。
あとは、BeforeAttack関数でキャラをランダム取得
させるだけ。

<自分の弾が自分に当たるバグ>
CheckAttackHit.csで、
Enemyとの当たり判定でKabosuAttack(Clone)と
当たったらreturnするようにし、
同様にPlayerとの当たり判定でUniAttack(Clone)と
当たったらreturnするようにする。

<死亡した敵が攻撃しようとしてバグ>
GameObjectそのものが消えているから座標とか
取ろうとしたらnullでエラーがでる。
BeforeAttack関数で、
if(enemyMap_[num + 1] == null)
{
    // 死亡しているからDestroyされている
    anim_ = ANIMATION.IDLE;
    return;
}
というのを最初に追加する。

<2回目の戦闘で、敵が4回ぐらい攻撃してくるバグ>
ButtleMng.csのmoveTurnList_変数が初期化されて
いなかったから。
setCallOnceがfalseのとき、最初に
・moveTurnList.Clear();
・moveTurnCnt_ = 0;
・damageNum_ = 0;
を入れておく。


ダメージ数値がどこで取得できるかさきちゃんに
つたえないといけない
------------------------------------------------

<敵撃破時のエフェクト>--------------------------
学校でダウンロードして持って帰ってきた
[Hovl Studio]というファイルに入っているエフェクト
を使って、敵の魂出ました的な表現にしようと考え中
※新規で[Effect]ファイルを作成してその中に入れる

緑色の光を出現させたいから[Magicfire0]を使う。
プレハブのまま外部アタッチさせようかなぁ。

出現タイミングは、敵の削除直前がいいので、
EnemyInstanceMng.csのHPdecrease関数で処理する。

エフェクト発生/削除の参考サイト↓
https://your-3d.com/unity-particle-script-1/#toc5

[EnemyInstanceMng.cs]
private GameObject soulEffect_;
という新規変数を作成する
→Assets/Effect/HovlStudio/Procedualfire/Prefabs
　の、Magicfire0を外部アタッチする

HPdecrease関数の敵削除の直前に、
// エフェクトの生成
Instantiate(soulEffect_, 
enemyMap_[num + 1].transform.position, Quaternion.identity);
と追加する。

新規Scriptとして[SelfEffectDestroy.cs]を作成。
内容はサイトのSelfDestroy.csのものを丸々いれる。
→Magicfire0のプレハブの中にこのScriptを入れる。

※注意点として、エフェクトがループ再生になってい　たら、ループ解除しておくこと。

<だんだん小さく、上にあがるようにする>
より魂ぽくするために、Scaleを小さくして
Y座標を上に加算していきたい

[SelfEffectDestroy.cs]
Destroy処理をしない場合はスケールと座標を調整する
ように処理を書く。
※スケールはマイナス値に行かないようにif文で
　条件をつけておくこと
　→マイナス値にいくと爆発するようなボォォンって
　　なるからね

[MagicFire0の変更点]
ヒエラルキーの、Velocity over Lifetimeの
Linear Y:1.5->0.5に変更

------------------------------------------------

<敵の弾がキャラをすり抜ける時がある>-------------

原因がまだよくわからない

EnemyInstanceMng.csのAttackStart関数で
adjustPosの計算にxとyは+forward.xと.yをしてたのを
削除したらなおった。。。？
座標がずれていたのかもしれない。
まだ確認が必要

[Uni]
RigidbodyのConstraintsにある
FreezeRotation XYZにチェックをいれる

[Jack]
RigidbodyのConstraintsにある
FreezeRotation XYZにチェックをいれる

もしかして、前の弾の目的地が次の弾の攻撃対象が
他のキャラだったときに座標がそれてる？
AnimMaxの時間いじったほうがいいかも
カボスのAnimMaxを0.67->2.0に変更

------------------------------------------------

<キャラ全滅時に画面を暗転させて街に送還する>-----

暗転部分はFadeのやつをつかって町長の家の会話に
飛ばしてしまえばよさそう。

チャプター番号を100ぐらいにして、Chapter.xlsに
会話作成する。
→会話内容は制作メモの方に書いておく

Chapter_importer.csに"100"を追加して、
reimprtする。
※eventNumは101にする

<全滅してるかの判定をする>
Chara.csにdeathFlg_変数を用意しておいて、
CharacterMng.csからキャラ数とdeathFlg_の数が
一致しているか調べたらいいのかな。

①Chara.csにdeathFlg_変数を用意して、
　Set/GetDeathFlg関数をつくる。

②CharacterMng.csの、Buttle関数の始めにDEATHなら
　行う処理があるから、そこに
　キャラ数分for文を回して1人でも生きていればなに　もせず全員死亡していたら
  EventMng.SetChapterNum(100,SCENE.CONVERSATION)
  を呼ぶようにする。
　
　HPdecreaseで0以下になればSetDeathFlg関数呼ぶ。

③100番の会話が終わった後に元の番号に戻したいから
　古い番号を保存しておかないといけない。
　EventMng.csのSetChapterNum関数に

if (num == 100)
{
  // 全滅時の特殊会話時には、全滅前のチャプター番　　　号を保存しておく
  oldNum = chapterNum;
}

if(oldNum != 100 && num == 101)
{
  // さっきまでの会話が全滅時の特殊会話だったとき　　　は、番号を100の前に入れてたやつに戻す
  chapterNum = oldNum;
}
else
{
  chapterNum = num;	// 通常の会話処理
}

という処理を追加する。
これで全滅時に遷移するようにできた。

------------------------------------------------

<戦闘UIの見直し>--------------------------------
画面左側の、時間帯の下にキャラのHP/MPを出す場所を
用意する。
CharaStatusFrameとCharaIconFrameの親として
空のオブジェクトを用意し、[UniCharaData]とする。
2人分いるから複製して[JackCharaData]も用意。

またまたサイズ変更が必要になります。。

(上の段)
CharaStatusFrame
Pos   X:-440 Y:150 Z:0
Scale X:3    Y:1.5 Z:1

CharaIconFrame
Pos   X:-530 Y:180 Z:0

(下の段)
CharaStatusFrame
Pos   X:-440 Y:100 Z:0
Scale X:3    Y:1.5 Z:1

CharaIconFrame
Pos   X:-530 Y:140 Z:0

あとはここにHPバーを追加する。
(上の段)
HPSlider
Pos   X:-390 Y:160 Z:0
Scale X:1    Y:2   Z:1

(下の段)
HPSlider
Pos   X:-390 Y:110 Z:0
Scale X:1    Y:2 Z:1

charHPMap_変数を新規で用意し、
CharacterMng.csのStart関数で、
[キャラ名+CharaData]の中のHPSliderのHPBar.csを
取得するように記述する。
※初期HP情報もその後すぐに設定する

これまでcharaHPBar変数でやってたところを
charHPMap_に置き換えて実行してみる。
→デバッグ成功

------------------------------------------------

<キャラが片方だけ死んだときのデバッグ>-----------

ユニが死んだとき
attackTarget_ = 0;でデバッグする
特にバグなし

ジャックが死んだとき
attackTarget_ = 1;でデバッグする
※バグ発生
①ユニが与えるダメージ量がおかしい
②倒したあとにすぐ戦闘終了しない

(原因)
ユニのAnimMaxが速すぎたせい。

(解決策)
2.0とか遅くしたらなおった。
0.67はだめやね

------------------------------------------------

<敵が、死亡したキャラを狙ってこないようにする>---
攻撃対象の決定タイミングがEnemyInstanceMng.csの
BeforeAttack関数でやってる。

決定したキャラのHPが0以下だったら再選択をするようにdo-while文をいれる。

do
{
   attackTarget_ = Random.Range   ((int)SceneMng.CHARACTERNUM.UNI,        (int)SceneMng.CHARACTERNUM.MAX);
} while
 (SceneMng.charasList_[attackTarget_].HP()<=0);

これでHPが0のキャラを選んだ時は再選択できる。

------------------------------------------------

<UniとカボスのAnimMaxについて>------------------

両方とも1.0に設定した

------------------------------------------------

<エンカウントの画像を追加/変更する>--------------
[FieldUICamvas-Encounter]
Pos X:-100 Y:100 Z:0
Image:whiteFrameMask.png

新規で、Encounterの子に[LogoImage(Image)]を追加
[LogoImage]
Pos X:-100 Y:100 Z:0
Width:140 Height:121
Image:Encount_Logo.png(新規画像)

新規でEncounterの子に[FrameImage(Image)]を追加
[FrameImage]
Pos X:-100 Y:85  Z:0
Width:250  Height:250
Scale X:1  Y:1.1 Z:1
Image:Encount_Frame.png(新規画像)
※EncountColor.csは付けないように気を付ける
外枠サイト↓
https://www.free-frame.net/data/574.php

[Encounter]
Pos X:-115 Y:110 Z:0

------------------------------------------------

<フィールドの左奥へ進んだ時に強制ボス戦をする>---

<壁の出す出さないを制御する>
戦闘が発生するための見えない壁を用意しておいて、
該当するクエストを受けてるときだけactiveにする。

新規で空のオブジェクトで[ButtleWall]を作成する。
その子として、[1(Cube)]を作成。
数字はクエスト番号と一致する番号にする。

今回の場合、1がギルドテストというクエストだから
1で作成し、左奥に設置する。

[1(Cube)]
Pos      X:-24 Y:1   Z:50
Rotation X:0   Y:-10 Z:0
Scale    X:11  Y:5   Z:1
※IsTriggerにチェックあり

FieldMng.csでFindしてButtleWallを取得できるようにし、子の番号と現在受注中のクエスト番号を照合する。

[FieldMng.cs]
Start関数内に処理を追加する。
①イベント戦発生用の壁情報を取得する
　→保存しておきたい情報ではないからローカル変数
　ButtleWallの子オブジェクトを配列で取得する

②受注中のクエスト情報を取得する。
　QuestClearCheck.csのGetOrderQuestsList関数が
　staticになっているから、ここから情報をもらう。
　
③1つもクエストを受注していない際は、
　全ての壁を非アクティブにする。
　→②のCountを見たらわかる。

④壁の個数と受注中クエスト個数で2重for文を回す。
　名前が番号同士で一致していればアクティブへ、
　不一致なら非アクティブにする。
　→このとき、すでにクリア済み(boolがtrue)なら
　　非アクティブ処理にする
　→名前一致時の処理は、必ず最後breakで終わるよう
　　にしておく。

これで壁の出す出さないは制御できるようになった。

<強制戦闘を発生させるScriptを新規で作成する>
ForcedButtle.csを作成する。
ButtleWallの子の壁にはすべてForcedButtle.csを
アタッチするようにする。

[ForcedButtle.cs]
OnTriggerEnter関数を書く。
接触したのがPlayerタグがついたもの(=ユニ)だった
場合、nowModeをBUTTLEにする。
→これで強制戦闘にできる

また、戦闘終了後にまたEnter関数に入ってこないようにthis.gameObject.SetActive(false);を記述して
非アクティブにしておく。

あとは敵の種類が指定できるようにする。
[EnemyInstanceMng.cs]
private GameObject eventEnemy_; という変数を用意しておき、SetEnemySpawn関数を新規作成して、
受け取った引数の内容をeventEnemy_に保存する。

インスタンスするときにはeventEnemy_変数がnullかどうかで敵の生成を変えるようにする。
→イベントの敵を出すときには必ずeventEnemy_を最後
　はnullにする

[ForcedButtle.cs]
SetEnemySpawn関数をFindしてから呼び出し、
public GameObject eventEnemy;
という外部アタッチ用の変数を用意する。
→ここにカボスとか特定の敵をアタッチする。

これで、イベント戦闘での敵の指定ができた。

<イベント戦闘の敵の数を指定する>
eventEnemy_をpairにする。
(GameObject,int)として、
敵の種類と敵の数ということにする。
※初期値をnullと-1にする

SetEnemySpawn関数の引数に数値を追加する。
EnemyInstance関数の頭で、
イベント用の変数が1以上の値だった場合、イベント用数値を優先するように処理を変更する。

いまのままでは、ButtleMngの敵数と値が異なってしまいバグがでる。
→EnemyInstance関数の返り値をintにして、敵数を
　返すようにする
　(return mapNum_;)

[ButtleMng.cs]
返り値をcorrectEventNumというローカル変数に保存して、debugEnemyNumをつかって処理している部分を
置き換える。

これで強制戦闘時の敵の数を調整できるようになった

------------------------------------------------

<フィールドの左奥に宝箱を設置する>---------------
学校から持ち帰ってきたデータの中にある、
FSLootBoxesファイルが宝箱。
これをAssets/Field/FSLootBoxes
という階層にしてデータを入れる。

Demo3の宝箱をAssets/Field/FSLootBoxes/Assets/Prefabsに
プレハブ化する。
(もともと入っていたほうの宝箱のプレハブは削除)

ためしにフィールドに配置してみる。
※TreasureChestPrefabについているRigidbodyの
　IsKinematicにチェックをいれる！！
　→ユニと衝突時に、ユニが宝箱の上に乗り上げるの
　　を防ぐため。

また、TreasureChestPrefabの子のOutsideCoinsは
今回は使用しないのでdeleteしとく。
それ以外はなにもいじってない。

今は接触中にスペースキーを押したら開くようになってる。

<該当クエスト中のみアクティブにする>
ButtleWallとかと同じ要領で、受注中クエストに関連する宝箱のみアクティブになるようにする。

TreasureChestPrefabを[TreasureChest]と名称変更。
その子供のChestを[該当クエストの番号]に名称変更。
→今回の場合はChestが[1]となる。

[FieldMng.cs]
最初にFindするのを("TreasureChest")にするぐらいで
他は壁と同じ処理。
※むしろまっったく同じだから関数に
　まとめたほうがいい。
　→CheckWallAndChestActive関数を新規作成

これで該当クエストの番号と一致させられた。

<設置位置を調整する>
[1](左奥の座標)
Pos      X:-24 Y:0    Z:54
Rotation X:0   Y:180  Z:0
Scale    X:1   Y:1    Z:1

<Chestの部分を番号にしたらアニメーションしなくな るバグ>
番号部分がChestじゃないと反応しない・・・？

階層の大幅な変更をする
Chests(空のオブジェクト)
　-番号
   --Chest

とする。これにより、FieldMng.csの変更も必要。
CheckWallAndChestActive("Chests");にする。

変更したものについてまとめ
・番号のRigidbodyのIsKinematicにチェックをいれる
・LootBox.csのCloseOnExitのチェックをはずす
・Chests-番号-宝箱の中身系 という階層にした
　→これにより、FieldMng.csの関数の引数も
　　"Chests"へ変更した

------------------------------------------------

<宝箱を開けたら、ワードと合格証を入手する>-------

テロップで、
○○を手に入れた！
みたいにする。

<入手できるもの>
・ギルドテスト合格証
・ワード「単体(ヘッド)」
・ワード「炎(エレメント)」
・ワード「小(テイル)」

テロップを出すときに使うキャンバスは、
[FieldUICanvas]を使う。
→エンカウント率をだしてるところ

[FieldUICanvas]の子に[GetChestsInfo(TMPText)]をいれる。
[GetChestsInfo]
Pos X:-120 Y:100 Z:0
Width:200  Height:50
FontAsset:NewMplus1-MediumSDF
FontSize :36
→ここに、宝箱から取得した内容物を記載する
今回の場合は<入手できるもの>の4つを書く。

[FieldUICanvas]の子に[BackImage(Image)]を入れる
[BackImage]
Pos X:0 Y:16 Z:0
Width:782 Height:198
Scale:X:0.8 Y:1.5 Z:1
Image:frame_text.png
これは、入手した情報&強制戦闘始まる合図
の背景に使える。

[FieldUICanvas]の子に[TitleBackImage(Image)]を
入れる
[TitleBackImage]
Pos X:0 Y:180 Z:0
Width:260 Height:68
Scale:X:1.2 Y:1.2 Z:1
Image:frame_name.png
これは、入手した情報&強制戦闘始まる合図
のタイトル背景として使える。

[FieldUICanvas]の子に[TitleInfo(TMPText)]を
いれる
[TitleInfo]
Pos X:-120 Y:185 Z:0
Width:200  Height:50
FontAsset:NewMplus1-MediumSDF
FontSize :36
Alignment:上の段のやつを[中央]にする
これは、入手した情報&強制戦闘始まるときに
GetItemとかDangerとか出すテロップにする。

[BackImage][TitleBackImage][GetChestsInfo]
[TitleInfo]の親として、[PopUp]という空のオブジェクトを用意する。

<宝箱を開けたときに特定の文字と背景を出す>
とりあえず文字はこのまま固定で考えておいて、
宝箱を開けたときにアクティブになるようにする。

①FieldMng.cs
SerializeFieldで、
private GameObject fieldUICanvasPopUp_;という
変数を用意する。
→ここにFieldUICanvasの中にあるPopUpという
  空のオブジェクトを外部アタッチする
※PopUpは最初非アクティブにしておく。

②FieldMng.cs
ChangeFieldUICanvasPopUpActive関数を作成して、
fieldUICanvasPopUp_.SetActive(true);
という内部処理をいれる。

③LootBox.cs
Open関数内でisOpen=true;の後ろで
GameObject.Find("FieldMng").
GetComponent<FieldMng().
ChangeFieldUICanvasPopUpActive();
という処理を行う。

④FieldMng.cs
ChangeFieldUICanvasPopUpActive関数で
StartCoroutine(PopUpMessage());
を呼ぶようにする。
→PopUpMessage関数は、アクティブ状態になってから　3.0秒以内なら表示し続け、上限を超えたら非アクテ　ィブにするようにしている

⑤FieldMng.cs
Update関数で、nowModeがSEARCHのときに時間の関係で
BUTTLEに切り替わる時、まだポップアップ中だったら
SetActiveをfalseにするように記述する
→たぶんここでfalseにするからまだコルーチン中でも
　activeselfの判定でwhile文を抜けてくれるはず


<特定の文字ではなく、条件にあったときの文字を
 出せるようにする>
分割しないExcelをつかってつくる。
方法はノートで図解してるからそれ見て思い出して。
※だいたいの内容はここにも書きます

[ChestInfo.xlsの作成]
QuestInfo.xlsを複製して名前変更する。
num1,num2,getItemという項目で作成する。

今回の場合
num1->1
num2->1
getItem->・ギルドテスト合格証
         ・ワード「単体(ヘッド)」
         ・ワード「炎(エレメント)」
         ・ワード「小(テイル)」
と入力する

Importするときは
class name->ChestList
sepalate sheet->チェックあり
int
int
string
にする。

いつもどおりChestInfo_importer.csのexportPathを
変更してreimportを押す。

Excelから宝箱情報の読み込みを行う。
①FieldMng.cs
private GameObject DataPopPrefab_;
private ChestList  popChestList_;
を新規作成する。

②PopList.cs
ListDataのenumにCHESTを追加する。
GetData関数のswitchにもCHESTを追加して、
tmpStr = "Chest";
return (T)(object)GetList<ChestList>(tmpStr);
とする。

③FieldMng.cs
Start関数で、
DataPopPrefab_ =
Resources.Load("DataPop") as GameObject;
popChestList_  = DataPopPrefab_.GetComponent<PopList>().GetData<ChestList>(PopList.ListData.CHEST);
とする。

これで情報を受け取るところまではできた。

クエスト番号が1つに対して複数宝箱を設置する場合について考える。

[1]としている宝箱の名前を[1-1]にする。
この影響で名前一致判定をしている処理がうまくいかなくなるから、名前一致判定のまえにハイフンの前後で数字を区切って、前の数値の方を判定に採用する。

string[] arr = objChild[i].name.Split('-');
としてから、
if(arr[0] == orderList[k].Item1.name)

※これで、一気に3つ配置するとかになっても
　[クエスト番号 - 1,2,3]で対応できるから安心

※ついでにButtleWallの方も[1-1]とかの置き方にした

あとは、開けられた宝箱の名前を取得してきて
表示する文字が選択できるようにする。

その前に、宝箱内容の文字描画先を変数で取得しとく
FieldMng.csで、
private TMPro.TextMeshProUGUI getChestsInfo_;
という変数を作成してStart関数で
getChestsInfo_ = fieldUICanvasPopUp_.transform.Find("GetChestsInfo").GetComponent
<TMPro.TextMeshProUGUI>();とする。

①FieldMng.cs
ChangeFieldUICanvasPopUpActive関数の引数で
int num1,int num2を追加する。

②LootBox.cs
ChangeFieldUICanvasPopUpActive関数を呼び出しているところで自分の名前をハイフンの前後で区切る。
それをそれぞれの引数に入れるようにする。

③FieldMng.cs
ChangeFieldUICanvasPopUpActive関数の引数でもらってきた番号とpopChestList_変数を照合する。
一致したときに、 (if文で一致してるか確認する)     getChestsInfo_.text =
popChestList_.param[i].getItem;
という処理を行う。

これで、宝箱を開けたら、ワードと合格証を入手するのもできたし、他の宝箱の設定をしようとすればできるようになった。

あ、TitleInfoの内容も書き換えれるようにしとかな。
getChestsInfo_の要領でtitleInfo_を作成。
ChangeFieldUICanvasPopUpActive関数で一致しているときに、titleInfo_.text = "GetItem";という処理を
する。

------------------------------------------------

<強制戦闘前に、確認テロップをだす>---------------

Townから、はい/いいえのやつと、矢印をコピーして
FieldUICanvasのPopUpの子にする。
(Yes/No/Icon)そして座標調整をする。
[Yes]
Pos   X:-100 Y:-60 Z:0
Width:260 Height:68
Scale X:0.6 Y:0.6 Z:1

[No]
Pos   X:100 Y:-60 Z:0
Width:260 Height:68
Scale X:0.6 Y:0.6 Z:1

[Icon]
(「はい」の方のとき)
Pos   X:-160 Y:-60 Z:0
(「いいえ」の方のとき)
Pos   X:40   Y:-60 Z:0

Width:132 Height:148
Scale X:0.25 Y:0.25 Z:1

<壁に当たった時、ユニの操作状態を切替可能にする>
ForcedButtle.csでStart関数を用意し、
UnitychanControllerをFindする。
コルーチンを用意して、そのなかでコントローラーの
enableをfalseにしたりtrueにしたり切り替えれるようにしておく

<はい/いいえを選択する処理をつくる>
ForcedButtle.csに、HouseInteriorMng.csを参考にしたコルーチン処理をつくる。
→SelectForcedButtle関数とする

while文の条件をcontroller_のenabledにしておき、
SPACEキー押下で操作可能にすると同時にwhile文を抜けられるようにする。

bool tmpFlgをつくり、はい->true,いいえ->false
にして、左右キーでフラグを切り替えるようにし、
SPACEキーを押下した時点でのフラグの状態をみて
ユニの位置を下げたり、敵の種類と数の設定をする。

<そもそもの描画処理>
※Yes/No/Iconを、[Select]という空のオブジェクトに
　入れるようにする。

FieldMng.csから描画状態は制御したほうがいい
→すでにpopupをアタッチで取得してるから。

①ForcedButtle.cs
FieldMng情報を取得できるように変数を用意して
Start関数でFindする。

②FieldMng.cs
ChangeFieldUICanvasPopUpActive関数の引数にboolで
フラグを付け加える。
true:宝箱処理 false:壁処理
として、中の処理をif文で分けるようにする。
→LootBox.csにはtrueという引数を書く必要がある。

③ForcedButtle.cs
コルーチンの最初で
ChangeFieldUICanvasPopUpActive関数を呼び出す。
引数は(-1,-1,false)とする。

④FieldMng.cs
ChangeFieldUICanvasPopUpActive関数の宝箱処理では
fieldUICanvasPopUp_.transform.Find("Select").gameObject.SetActive(false);として、
強制戦闘側では、
fieldUICanvasPopUp_.transform.Find("Select").gameObject.SetActive(true);とする。

また、すでにアクティブなら非アクティブにし、
非アクティブならアクティブにするために、
fieldUICanvasPopUp_.transform.Find("Select").gameObject.
SetActive(!fieldUICanvasPopUp_.activeSelf);

fieldUICanvasPopUp_.
SetActive(!fieldUICanvasPopUp_.activeSelf);
とする。
※処理順逆にしたら選択肢出てこないから注意

⑤ForcedButtle.cs
SPACEキー押下後に、もう一度
ChangeFieldUICanvasPopUpActive関数を呼び出す。
→非アクティブにするため

<矢印を動かす処理>
FieldMng.csにMoveArrowIcon関数を作成して、
引数で受け取ったフラグ状態をみてIconの座標を
ずらすようにする。
ForcedButtle.csのコルーチンにある左右キー処理の
中で呼び出すようにする。
→Findを使ってるけど、呼び出し回数的に最初から
　取得しておく必要もなさそうだから
　必要なときにFindするようにしている。

<テロップを出しているときはユニアニメーションを
 止める>
ForcedButtle.csのコルーチン内で、enabledをfalseにする前に、controller_.StopUniRunAnim();を
呼び出す。

<テロップの文章を書き換える>
ChangeFieldUICanvasPopUpActive関数の戦闘処理側に
titleInfo_.text = "Danger!!";
getChestsInfo_.text =
 "モンスターの気配がする…\n先に進みますか？";
という文章を記載しておく。

<いいえの処理をつくる>
ユニの座標を少し後ろに戻したい。
ForcedButtle.cs
private GameObject uniChan_;
という変数を用意する。
コルーチン処理でSPACEキー押下時にいいえだった時に
Vector3 velocity =
(-gameObject.transform.forward) * 3.0f;
uniChan_.transform.position += velocity;
という処理を付け加える。

座標の戻し方については、
https://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q14185459249
上記をみて考える。

これで強制戦闘前にテロップをだして案内表記できる

------------------------------------------------

<敵の種類を増やす>------------------------------
いよいよカボス以外も実装してくぞ。
これが終わればForestFieldはほぼほぼ完了。

学校で作成した敵をもってくる。
Assets/Prefab/Enemy/RPGMonster…という階層に入れておく。
※FieldフォルダにいれてあったEnemyフォルダは削除
動作確認するためにEnemyTest.csも入れて
アタッチする。

EnemyInstanceMngに現在はEnemy_Kabosuをアタッチしている[EnemyTest]部分をEnemy_Slimeにする。
なぜか後ろ向きにインスタンスされた。。。

[EnemyInstanceMng.cs]
EnemyInstance関数でインスタンスした直後に
敵の体の向きを変える処理をいれる。
enemy.transform.Rotate(0, 180, 0);
これでスライムがこちらを向くようになった。

<スライムに当たり判定をつける>
Attack->IdleのHasExitTimeのチェックをはずす

Tag:Enemy
RigidbodyとBoxColliderを追加

なんか敵がちょっと浮いてる。。
BoxColliderのY軸を変更したほうがよさそう
CenterのYを0.5にする。

ついでにRigidbodyのFreezeRotationに全てチェックをいれる。

<攻撃モーションと移動モーションをつける>
いまはカボス基準だから、ジャックみたいに
移動と攻撃のモーションを分ける必要がある。

接近型の敵かどうかをExcelから読み込んで(bool)
それでわけたほうがいい。
※とりあえずいまは接近型のみで作成する。
BeforeAttack関数内に攻撃対象に向かって走るコルーチンを呼び出す。(MoveToPlayerPos)

[MoveToPlayerPosについて]
MoveToPlayerPosの処理を書く。
だいたいはCharacterMng.csに書いたやつと同じ。
自分の座標を入れるところは要注意
deltatimeを割る値も敵毎にしたほうがいい

Chara.csのRunMove関数の内容をEnemy.csにもコピー

[nullにしていたAnimatorを入力]
Instance処理のところで、
enemy.GetComponent<Animator>()と入力する

<攻撃モーション>
Enemy.csのAttack関数にあったSetBoolのコメントアウトを取り、モーションするようにする。

いまのままでは弾が必ず発射される。。
strの部分をExcelから読み込めるようにしたい

体当たりでHPを減らしたいから、Slimeに当たり判定をつけて、Weaponタグをつける
※istriggerにチェックをいれる
また、同じSlimeの部分にCheckAttackHit.csを
アタッチする

<攻撃後に定位置に戻る>
AfterAttack関数、MoveToInitPos関数、
BackMove関数を実装する。
※ほぼCharacterMng.csとChara.csと同じ
戻る座標位置だけ気を付ける。
あと、定位置の誤差の値も任意で変えられるようにしたい。

<なぜかジャックに攻撃あたらん。。>
当たり判定位置をもうちょっと調整する。
Enemy_SlimeのSlimeについているBoxColliderの
CenterYを-0.5にする。
1体目のtargetが設定できてない
SetTargetNum関数より前に当たり判定が呼ばれてる。

(対応策)
BeforeAttack関数でattackTarget_を設定したあと
すぐにタグ検索してCheckAttackHitを呼び出す。

------------------------------------------------

<アニメーションがない敵用に、
 コンポーネントを確認する>----------------------
[EnemyInstanceMng.cs]
インスタンス関数内でnull確認をする。
[Enemy.cs]
set_.animatorに対してnull確認処理を数か所追加する

------------------------------------------------

<Enemy.xlsにデータを追加する>-------------------
適当にスライムのデータ値を入力する。

<新項目>
・MoveTime->移動時にdeltaTimeを割る値
・MoveDistance->キャラとの距離許容範囲
・WeaponTagObjName->CheckAttackHit.csがアタッチ
　　　　　　　　　されているオブジェクトの名前

MoveTimeとMoveDistanceは遠距離攻撃の場合-1でいい

[EnemyList.cs]
float,float,stringの順で追加する

[Enemy_importer.cs]
cellに3項目追加する。
そしてreimport

[CharaBase.cs]
敵用の情報部分に3項目追加する。
そしてインスタンス時にも追加する。

[Enemy.cs]
RunMove関数で直値で書いてた数字を
set_.MoveDistanceに変更する。

また、
    public float MoveTime()
    {
        return set_.MoveTime;
    }

    public string WeaponTagObjName()
    {
        return set_.WeaponTagObjName;
    }
という関数を追加する。

[EnemyInstanceMng.cs]
インスタンス時にenemyData_.param[1]とする。

MoveToPlayerPosコルーチンで、
MoveTime関数を呼び出すようにする。

BeforeAttack関数で、"Slime"と書いてたところを
enemyList_[num].Item1.WeaponTagObjName()にする。

MoveToInitPosコルーチンで、
直値だった値を
time +=
Time.deltaTime / (
enemyList_[num].Item1.MoveTime() / 2.0f); とする 

------------------------------------------------

<遠距離型の敵について>--------------------------

近距離型と同じようにコルーチン内には入るが、
MoveTime()を見て0以下だったらflagをすぐにtrueへ
そのままコルーチンを抜けてスルー。
という風にしておく。
※カボスで動作確認済み

------------------------------------------------

<敵の種類をランダムで
　インスタンスできるようにする>------------------

→プレハブの方を改良してなかに敵たくさんいれたら
　なんとかなるやろ。※フィールド毎

空のオブジェクトで親を作成し、
[ForestFieldEnemys]とする。
そこに、
・Kabosu
・Slime
という順で子としてアタッチする。
※ここの子の順番は、Excelと揃えておく！
※ここに特定のボス系は入れないようにする

それをAssets/Prefab/Enemyフォルダにプレハブとして
入れてヒエラルキーから削除する。

このプレハブをEnemyInstanceMngの[EnemyTest]に
アタッチする。

[EnemyInstanceMng.cs]
インスタンス関数内のforeach文で、
// 番号でどの敵をインスタンスするか決める
int enemyNum =
Random.Range(0, enemyTest.transform.childCount);
とする。

イベントエネミー処理時以外なら、
enemy =
Instantiate(enemyTest.transform.GetChild(enemyNum).gameObject,
pos,
Quaternion.identity) as GameObject;
とする。

そして、情報を設定するところでは、
enemyData_.param[enemyNum]として、
子の順とExcel順を揃えておけば正しい情報が入れられる。

イベントエネミーは、名前をBoss_Excel番号
とかにしたほうがよさそう。_の前後で区切って番号を
取り出せれば指定できるようになる。

(カボスをボスとして使う例)
プレハブ名を[Boss_0]として、
イベント用の敵をインスタンスするときに

イベント用の敵の番号部分をenemyNumとして
適用する(エクセル番号も合わせる必要がある)
enemyNum =
int.Parse(eventEnemy_.Item1.name.Split('-')[1]);
とする。

これでランダムな敵の種類にできた。
イベント用の敵も用意できた。

------------------------------------------------

<新しい敵の処理をつくろぉぉ>---------------------
信じられるか？これまだ3体目なんだぜ。。。

SlimeRabbitとかいうウサギの子にしよ。かわいい。
データを確認したところ攻撃モーションがなかった。
→Moveの延長のまま攻撃にする(moveとattackが共通)

<アニメーションについて>
SlimeのAnimatorを[SlimeRabbit]にして、
既存のアニメーション側を[SlimeRabbit1]にする。
(Assets/Prefab/Enemy/SlimeRabbit/Animator)

中のアニメーションがコピーしてきたSlimeのままだから、SlimeRabbitのやつに変更する。

実際にアニメーションをアタッチしてみる。
EnemyTest.csを使ってテストする。
とりあえず大丈夫そう・・・？だから、データ作成。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_SlimeRabbit]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

[Monster_1]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする

<ForestFieldEnemysプレハブ>
Slimeの下に追加。

<テスト処理>
ランダムにインスタンスにしてたところを、
ウサギにする。

敵がちっっちゃい！！
Sizeを2ぐらいにしよっかな

<現在のバグ>
・ジャックに攻撃があたらん
　→SetDamageNumを設定するのが遅い。
　　すでに攻撃が終わってから設定に来てる。

(改善策)
BeforeAttack関数で攻撃対象を決めた後に、
ダメージ値をSetする。
※AttackStart関数が不要になったわ

・移動から攻撃のモーションがおかしい
　→アニメーションの時間調整をExcelで行う

これで一応うさぎの設定完了
・ランダムで登場するのを確認
・普通に敵として強すぎたw

------------------------------------------------

<次の敵じゃい！>--------------------------------
キノコはAnimatorがついてなくて設定がわからなかったからあきらめる。
モグラも歩きMotionしかない。。モグラもあきらめて
ハチにしよう！

<アニメーションについて>
SlimeのAnimatorを[FantasyBeeAnim]にして、
既存のアニメーションは削除する
(Assets/Prefab/Enemy/FantasyBee)

中のアニメーションがコピーしてきたSlimeのままだから、FantasyBeeAnimのやつに変更する。

実際にアニメーションをアタッチしてみる。
EnemyTest.csを使ってテストする。

<Enemy.xls>
とりあえずそれっぽい値を入れとく。

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Bee]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

[Bee]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする

<ForestFieldEnemysプレハブ>
SlimeRabbitの下に追加。

<テスト処理>
ランダムにインスタンスにしてたところを、
ハチにする。

<バグ>
近接攻撃をしにいくとジャックにダメージが入ってしまう
→ある程度はColliderのサイズ設定で防げるけど、
　ガード処理があったほうがよさそう。

(対応策)
①UniのStaffにもCheckAttackHit.csをつける
②CheckAttackHit.csで目標の敵に当たったら
　enableをfalseにする
③EnemyInstanceMng.csのWeaponタグを探している
　処理内で、名前一致時にCheckAttackHit.csの
　enableをtrueにする

※Jackの斧のサイズをすこし大きくした
------------------------------------------------

<ユニとジャックのモーションを追加する>-----------
<被ダメージ>
Damaged@loop

UnitychanAnimator.controllerにStateを追加する。
[Damage]というStateを作成し、
Standing@loopと線をつなぐ。

ParametersにisDamagedというフラグを追加する。
Standing->Damage はisDamageをtrueにして
HasExitTimeのチェックを外す
Damage->Standing はisDamageをfalseにして
HasExitTimeのチェックのまま

※ジャックの方も同様にする。

<アニメーション切替>
[Chara.cs]
Defence関数に被ダメージアニメーションを開始する
処理を書く。

(DamageAnim関数)
// そもそもダメージを受けてないときは処理を抜ける
if (!set_.animator.GetBool(key_isDamage))
{
    return;
}

// 時間でモーションを終了させるか判定する
if (set_.animTime < set_.AnimMax)
{
    set_.animTime += Time.deltaTime;
}
else
{
    // 被ダメージアニメーションを終了
　  set_.animator.SetBool(key_isDamage, false);
    set_.animTime = 0.0f;
}


[CharaBase.cs]
DamageAnim関数を用意する。

アニメーションをループさせたくないので、
damage@loopのAnimationタブにある
LoopTimeのチェックを外してapplyボタンを押す。

[CharacterMng.cs]
自分の行動外のときにも呼ばれる関数を作成して、
ButtleMng.csのUpdate関数で呼び出す
→NotMyTurn関数を作成した。

// ダメージを受けたときのモーションを
　　規定時間で終了させる
for(int i = 0; i < (int)CHARACTERNUM.MAX; i++)
{
    charasList_[i].DamageAnim();
}
という処理を書いている。

※おそらくこれと同様に敵もダメージを受けたときのモーション処理が実装できる。

<死亡時>
GoDown
idleのモーションからつなげるように
[Death]というstateを新規作成
フラグにもisDeathを追加。
HaExitTimeのチェックを外しておく。
※いまのところ生き返る手段がないからisDeathの
　falseを設定する箇所がない

[Chara.cs]
SetDeathFlg関数で死亡アニメーションを呼び出す
set_.animator.SetBool(key_isDeath, true);

敵も同様の処理を行っていく

------------------------------------------------

<敵モーションを追加する>------------------------
<被ダメージ>
[Enemy.cs]
Chara.csと同様にDamageAnim関数を作成する。
※アニメーションがないときもreturnさせる。
Defence関数で被ダメージアニメーションを開始させる

[EnemyInstanceMng.cs]
NotMyTurn関数を作成する。

[ButtleMng.cs]
NotMyTurn関数を呼び出す。

あとはそれぞれの敵(カボス以外)に、
ダメージをくらったアニメーションを呼び出すよう設定する。
スライムから順に確認していこう！

①スライム
isDamageにフラグ名を変更する
まずGetHitのループチェックを外す。
ok
②ウサギ
isDamageにフラグ名を変更する
もともとループは外れてた
ok
③ハチ
isDamageにフラグ名を変更する
もともとループは外れてた
ok

<死亡時>
死亡したときにすぐDestroyしてしまっているから、
死亡アニメーションが終わってから消すように変更が必要。

[Enemy.cs]
deathFlg_変数を作成し、
Set/GetDeathFlg関数を用意する。
また、DeathAnim関数も用意。
→返り値をboolにして、Destroyしていい時間になれば
　return true;で返す。

[EnemyInstanceMng.cs]
今、敵オブジェクトを削除している場所で
該当する敵のSetDeathFlgをtrueにするように呼び出す

そして、NotMyTurn関数で死亡処理を行うように変更。
→タグ検索して、死亡フラグも処理待ち時間もtrueな
　らば非表示にする。

Destroyしたら数が合わなくなるから、
SetActiveをfalseにするだけにして戦闘終了後にDestroyしたほうがいい
→DeleteEnemy関数という削除用の関数を用意した。
※逃げるボタンにも敵削除処理の影響がでるから修正
[ButtleMng.cs]
CallDeleteEnemy関数を用意し、中で敵の削除関数を
呼び出す
[CharacterMng.cs]
CallDeleteEnemy関数を呼び出す

あと、最後の敵を倒したあとに死亡アニメーション待機をさせないといけない
[EnemyInstanceMng.cs]
AllAnimationFin関数を作成する。
中では現在死亡アニメーションを行っている敵がいるか調べる処理を行い、trueなら全ての敵がアニメーションを終了していることを知らせる。

[ButtleMng.cs]
GetLastEnemyToAttackFlg関数がtrueだった処理の
次の行でAllAnimationFin関数のif文を入れるように変更する。

これで最後の敵の死亡処理まで待機するようになった

<死亡前に、通常ダメージをくらったアニメーションが
入るのが邪魔>
sethp関数で0になったときはDeathで、それ以外は
Damageにする。
→他のところでやってた被ダメ/死亡アニメーションを
　もってくる


あとはそれぞれにアニメーションを追加する。
①スライム
isDeathにフラグ名を変更する
もともとループは外れてた
ok
②ウサギ
isDeathにフラグ名を変更する
もともとループは外れてた

ユニの次に攻撃してくるから、
倒れながら移動してくる恐怖のバグ
→BeforeAttack関数ですでに死亡フラグがtrueなら
　returnする条件もorで追加する。
ok
③ハチ
isDeathにフラグ名を変更する
もともとループは外れてた
ok

これで死亡処理まで終了した
------------------------------------------------

<敵の攻撃タイミングとキャラの被ダメージモーション がずれてるから修正が必要>----------------------

(原因)
攻撃の当たり判定位置がモーション切替前に当たってるから

(対策方法)
a.Colliderの位置をずらす
b.最接近位置を調節する
c.攻撃する瞬間にコライダーをenableにしたほうがい  いかもしれない。

<cについて>
※前提として、最初に敵についているboxColliderは
　enableを切っておく

[EnemyInstanceMng.cs]
changeEnableBoxCollider_変数を用意して、
タグ検索しているところで、
changeEnableBoxCollider_ = weaponTagObj[i].GetComponent<BoxCollider>();とする。

あとはこれをどこかでtrueに切り替える。
攻撃モーションの半分の値をこえたらtrueにしたい。

[Enemy.cs]
HalfAttackAnimTime関数を作成して、
AnimtimeがAnimMaxの半分を超えたらtrueを返すようにする。

[EnemyInstanceMng.cs]
Buttle関数内でHalfAttackAnimTime関数を呼び出して
trueならboxcolliderをtrueにする

①スライム
a.SlimeについてるBoxColliderのYを-0.5->-0.3へ
b.MoveDistanceを1.5->2.0にしてみる
c.Slimeのプレハブのenableを切っておく。
ok
②ウサギ
歩行モーションを速くしたい
Attackのアニメーション速度をEndを30->25へ
c.Monster_1のプレハブのenableを切っておく。
たまに歩行モーションや攻撃モーションが機能しない
→片方が死亡したあとにもう片方のモーションが固ま　る？

あー、ダメージモーション直後に移動しようとしたら硬直してるのかも。
→GetHotからIdleへのHasExitTimeのチェックを外す
→Enemy.csのRunMove関数に、ダメージモーション中
　ならダメージモーションをfalseにさせる
ok
③ハチ
c.Beeのプレハブのenableを切っておく。

Animatorで、RunからAttackの切替の時に
ヒエラルキーのAttackが速めに重なるように変更した
(20%左へ動かした)

[EnemyInstanceMng.cs]
攻撃後にBoxColliderのenableを
falseにするように処理を追加する。

AnimationChange関数のIDLEのターン切替直前に
false処理追加

------------------------------------------------

<カボスのボスを、黄カボスにする>-----------------

新規画像でKikabosu.pngを使用するように変更。
また、ForcedButtle.ceに
public int eventEnemyNum変数を用意して、
外部から敵の生成数を決定できるようにした。

黄カボス用のデータをExcelに追加する。
※必ず該当フィールドでの雑魚敵の下に書くように！

また、Assets/Prefab/Enemy/Bossに入れてる
[Boss_0]を[Boss_4]とする。
→Excelの4行目にデータがあるから(実際の行数-1)

<エラー発生>
Weaponのタグ確認時に自分のタグかを親の番号を見て判断しているが、遠距離攻撃の場合、自信にCheckAttackHitがついているわけではないから数値に変換できなくてエラーが発生する。

(対応策)
int.TryParseを利用する。
最初に数値に変換できるかみて、できるなら今まで通り親の番号と比較する。

変換できないときは、親番号と比較をしない

TryParse参考サイト↓
https://atmarkit.itmedia.co.jp/fdotnet/dotnettips/408tryparse/tryparse.html

------------------------------------------------

もしかしたらInterfaceButtle.csいらないかも
→CharaBaseを敵もキャラも両方のベースにしてるから
　必要なくなる可能性高め
EnemyInstanceMng.csを、EnemyMng.csにする予定

<いろいろメモ欄>
static変数をprivate変数に代入して、private変数の
数値が変わるだけで代入前の大元のstatic変数の数値も変化した(テストで実験してみた結果です)

towndata側でもTownMngにenum追加してMENUいれて
TABでCanvas表示にしたほうがいいかも


シーンのロード/アンロードについて↓
https://dolphinetech.com/unity/scene-road-unload/

towndataも建物や木をstaticにしたほうがいいかも

Update関数は極力減らす(↓はupdateの解説サイト)
https://qiita.com/ChurappsWatatani/items/73f0c38f0cd18620a580

セーブをするときはキャラのステータスの保存を
どのスクリプトでするか考えたほうがいい

キャラクターのステータスはポイントを振り分けられるようなシステムにしたい。


→にげるを選択するのにコマンドをぐるぐる回すのは　手間というか、面倒くさい。


キャラが攻撃対象を選ぶ時に、
矢印が敵の頭の上に浮いててフワフワくるくるしてて
ほしい。

最終的には、ButtleWarpPointPackと
EnemyInstancePointPackの2つをPrefab化しておいて
ヒエラルキーからは除外し、AssetsフォルダからMng系にアタッチするように変更する予定。
→表示座標が正式に決定してからね

今は、攻撃弾が敵にhitしたと同時に消えてて面白味がないから、改善策を考える
→衝突後パーティクルとかあるといいかも

コマンドの回転速度が一定で面白味がないので、
最初と最後が速いような速度差をつくりたい。

タグ検索速度↓
https://kan-kikuchi.hatenablog.com/entry/CompareTag