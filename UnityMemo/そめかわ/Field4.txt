メインで使用するアセット↓
https://assetstore.unity.com/packages/3d/small-cave-kit-49372

暗い洞窟のなか、
ギミックとしてはミミックとか。

骸骨とか幽霊系の敵

色のついたスモークで毒を演出
→緑色のスライム系の色
通ったときに幸運値で毒にかかるか確認するScriptを準備する

クエスト内容としては、洞窟の奥から毒の霧が漏れ出してきて洞窟近くの街に被害がでている的な。

風のワードで毒の霧が外にすごい漏れ出してる的な設定
にする。

毒霧については、unity公式アセットの中に入っていた
Smoke&SteamEffectsを使用する予定。

-------------------------------------------------

FieldフォルダのMapフォルダの中に[Small Cave Kit]を追加する。
既存の物を更に道を拡張させるように変更していく。
※Torch setは、配置しなおしたほうがいい

Cave partsのRotationのY軸を-90にする
(unpackしておく)

基本的に、下向きの道をけしておく

壁の高さが足りないので、[Cave parts]のScaleZを1.5
に変更した。不都合がでたらまた考える


Sceneの名前を[Field4]にしておいて、階層を外に出す
カメラアニメーションとか使ってムービーとかタイトルをつくりたいなぁ。

<Field初回の会話発生の条件が甘かった>-------------

[FieldMng.cs]
イベントが発生するか確認するところで、
Fieldの番号も確認しておかないとだめぽい
→他のフィールドに入っても進行度の番号次第で
　会話が発生してしまう

-------------------------------------------------

<最低限動かすのに必要な要素を他のフィールドから
 もってくる>--------------------------------------
エラーでたからいろいろアタッチ直しした。
大丈夫そう。

-------------------------------------------------

<メインカメラの画角がやばい>----------------------

ユニの真後ろから撮るか、天井やっぱりぶち抜いて
見下ろし型にしたほうがいい

<見下ろし型にする>
[MainCamera]
Position X:0  Y:4 Z:2
Rotation X:55 Y:0 Z:0

MainCameraにアタッチしているCameraSample.csも
処理の追加が必要。
現在のフィールドがField4のところなら(数字的には3)
offset変数の値を別のものを入れるようにする。

Start関数時にはまだnowSceneがNONなので、
Initに変更して後から決定にしたほうがいい
※ついでにUpdateもコルーチンにできる

Init関数の呼び出し元は、CameraMng.csにしておいて
そのCameraMng.csの関数を呼び出すのはFieldMng.cs
からとする。(経由して設定みたいな感じ)

FieldMng.cs->CameraMng.cs->CameraSample.csのInit
みたいな。

確認完了。

-------------------------------------------------

<画面外が見えるのをなんとかしないとだよね>--------

真っ黒にしてみる。

FieldMapの子として[BlackPanel]を用意して、
都合よくFurnitureフォルダにBlackというマテリアルが
あったから流用する。
ScaleのXとZを大き目の10と設定して
地面より下に敷く。

-------------------------------------------------

<バトル位置を決定する>----------------------------

別で戦闘用の空間をつくったほうがいい。
画角的に外が見えちゃうから壁だけ高くしたい
→同じ形の地形を反転して蓋するみたいにした。

完全な左右対称ではないからちょっと切れ目みたいなのができるのでそこをオブジェクトで塞いでごまかしたい
→手前に合わせておいて、奥の切れ目はオブジェクトで
　ごまかした

[ButtleWarpPointPack]
Position X:42 Y:0 Z:-20

[ButtleWarpPointPack]
Position X:42 Y:0 Z:-17

-------------------------------------------------

<コライダーを追加する>----------------------------

形のMeshがあるから、MeshColliderをつけるだけでいけそう。
→とりあえず一括で全部につけた

[Cave parts]のインスペクターのStaticにチェックを
入れておく。

移動速度を結構落とさないとすり抜け地獄になる
→5.0fにした

道をふさいでいる岩には、BoxColliderをつけたほうが
良い。

小さすぎる石のコライダーはremoveしておく

行き止まりの丸角はBoxCollider置いたほうがいい
→その丸角の中にBoxColliderをアタッチする

-------------------------------------------------


<毒の霧を追加する>--------------------------------
nity公式アセットの中に入っていた
Smoke&SteamEffectsを使用する

Fieldフォルダの中のMapフォルダに追加した。
Prefabの中にある[PoisonGas]以外は全て削除する
→使わないTextureやらなにやらも消す

FieldMapの子オブジェクトとして
[PoisonSmoke]を作成し、その中に入れていく。

今後はこのプレハブに当たり判定を付ける感じで進める
→毒判定用


-------------------------------------------------

<登場する雑魚とボスのアセット>--------------------

①幽霊魔法使い(ボス+雑魚)
https://assetstore.unity.com/packages/3d/characters/creatures/fantasy-monster-wizard-demo-103037

②骸骨兵
https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy-monster-skeleton-35635

③よくわからないのと宝箱(宝箱はミミック用)
https://assetstore.unity.com/packages/3d/characters/creatures/rpg-monster-partners-pbr-polyart-168251

④鬼ごっこゲームに使われていたやつ
https://assetstore.unity.com/packages/3d/characters/creatures/level-1-monster-pack-77703#content
→ここから2つとる

※狼(これは最後のフィールドに回そう)
https://assetstore.unity.com/packages/3d/characters/animals/mammals/casual-rpg-monster-wolf-208130

-------------------------------------------------

まだやらないといけないことはあるけど、
ひとまずField4完成！！

<戦闘フィールドに松明を置く>----------------------

暗くて見えんちゃん・・

-------------------------------------------------

<ジャックが定位置に戻るときに、位置が間違っているのかジャンプ->走る->止まるになる>-------------------

[Chara.cs]
BackMove関数のif(distance <= 0.1f)
を、0.15fにしたらうまくいった
→他のフィールドと敵との距離感が違うから戻り切れてないのかもしれない

-------------------------------------------------

<敵を追加する>----------------------------------
①Beholder
直訳すると「見る人」って意味らしい。。
ミミックとセットになっていた敵を近接攻撃の敵として
出現させる。

<アニメーションについて>
TurtleShellからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

Attack03がループになっているので、LoopTimeの
チェックを外す。

<Enemy.xls>
いい感じに付け加える
Enemy.xlsに"Field3"のタブを付けくわえておく
→Enemy_importer.csに"Field3"を足す

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Beholder]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Beholder]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に1番目で[Enemy_Beholder]を入れる。

アニメーターが死んでるバグが発生中。
→「Root」というオブジェクトの名前を変更しなければ
　アニメーションが発生した。
※空のオブジェクトでWeaponタグをつける
　「Beholder」を用意したほうがいい。

HPバーの位置を高くする敵としてif条件に追加しとく。

確認完了。

②スケルトン近接型
<アニメーションについて>
そもそもAnimatorがなかったから作成する。
TurtleShellからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

Idleのアニメーションにループがついてなかったので
チェックをいれておく

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Skeleton]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Skeleton]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に2番目で[Enemy_Skeleton]を入れる。

ちっっっちゃ。。
ScaleをXYZ全て10にする。

アニメーションに違和感
Runが終わるのが早くて、攻撃の初動がおそい。
攻撃モーションの時間を早めたほうがいいかも

途中で走りモーションが終わってしまう。
Run->AttackのHasExitTimeのチェックを外しておく。
また、ExcelのMoveTimeを[100]にする

確認完了。

③スケルトン遠距離型(MagicSkeleton)
<アニメーションについて>
Spiderからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

deadのモーションが長いので、短くする

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Skeleton]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
SpiderAttack(Clone)を使ってみる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に3番目で[Enemy_MagicSkeleton]を入れる。

大きすぎるんだけど。。。
ScaleをXYZ全て0.3に設定した。

ダメージ時に出血のエフェクトがでるんだけど、
これを参考に自前でエフェクト作ってアタッチさせたほうがよさそうだとおもった。

④こうもり
<アニメーションについて>
そもそもAnimatorがなかったから作成する。
Spiderからコピーしてきて、アニメーションの中身を入れ替える。

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Bat]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
SpiderAttack(Clone)を使ってみる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に3番目で[Enemy_Bat]を入れる。

ちっっっちゃ。。
ScaleをXYZ全て20にする

⑤ボス
こうもりと同じアセットの、
緑のスライムにしようかな。でっかくする

Bossのプレハブファイルに入れておく

<アニメーションについて>
そもそもAnimatorがなかったから作成する。
Skeletonからコピーしてきて、アニメーションの中身を入れ替える。

※ダメージモーションがないから、Dieと同じにする

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[PoisonSlime_4]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[PoisonSlime]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

大きさをXYZ全て150程度にする。

<ButtleWallを用意する>
オブジェクト名を[6-1]にして、
X:38.4 Y:1.96 Z:37.36
に配置する。

ForcedButtle.csの
EventEnemy->PoisonSlime_4
EventEnemyNum->1
とする。

※まだメインクエストの6番目を作成していない

------------------------------------------------

<クエスト6の開始の会話を作成する>------------

Chapter.xlsに[Chapter18]を追加する。

[Chapter_importer.cs]
"18"を追加して、reimportしておく。

[Guild.cs]
GuildQuestEvent関数のクエスト受注タイミングの
switch文に、case 18を追加してquestNumが6なら
Chapter18を実行するように書く。

-------------------------------------------------

<クエスト6を追加する>-----------------------------

[QuestInfo.xls]
eventNumを18、questTypeを2にして
その他はそれっぽく書く。

[Guild.cs]
受注時に18で6番受注なら会話が発生するようにする

-------------------------------------------------

<回復魔法の作成をする>----------------------------

必要な要素
・単体
選択したキャラを一定値回復
magicattack依存

・複数
ランダムな回数回復する
※すでにHPがMAXのキャラも含めてランダム

・全体
全員のHPを回復する

・どれぐらいHPが回復するか点滅みたいな感じで
　だしたい

・エフェクトもそれっぽいのがほしい(後回し)

<単体小回復の実装>
データ的には
1,単体回復小,アアア,non,10,8,0,0,0,0,0,0

[CharaUseMagic.cs]
CheckUseMagic関数に回復処理を加える。
選択した魔法が回復だった場合(=elementが0)

キャラの枠の横に矢印をだすようにして選択できるようにしたい。
→ButtleUICanvasにある[UniCharaData]と
  [JackCharaData]の子に[ArrowImage(Image)]を付ける

[ArrowImage]
Uni
Pos X:-300 Y:100 Z:0
Rotate Yが180
Scale XYZ全て0.5

Jack
Pos X:-300 Y:50 Z:0
Rotate Yが180
Scale XYZ全て0.5

この矢印を選択中のキャラのみ表示するようにしたい。
[CharacterMng.cs]
charaArrowImage_という配列の変数を用意。
Start関数内でUniCharaData/ArrowImageとかをfindして
表示/非表示がいじれるようにしておく。

SetCharaArrowActive関数を新規作成し、引数に
全員の矢印を表示状態にするのか否かがはんだんできるようにする。

[CharaUseMagic.cs]
characterMngを取得するようにFindをしておく。
回復単体の時には、
characterMng_.SetCharaArrowActive(false);
とする。
複数回と全体の時にはtrueにする。

単体の時にはどのキャラを回復させるか操作できるようにしないといけない
HキーとJキーで矢印の表示を切り替える感じにしたい。

[CharacterMng.cs]
コルーチンを追加して、その中で回復対象を選択する
矢印の操作と決定の操作を行う。
(SelectToHealMagicChara関数)

<魔法とその使用キャラのMagicAttackに依存させる>
[CharacterMng.cs]
SelectToHealMagicChara関数で直値でいま回復値を入れてるから、そこをGetHealPower関数を呼び出すようにする。

[CharaUseMagic.cs]
healPower_変数を作成して、GetHealPower関数で渡せるようにした。

とりあえずここまでで基本の単体回復は終了。
あとは複数回と全体回復について処理を追加していく。

<複数回ランダム回復>
データとしては、
1,複数回回復小,アアア,non,10,8,1,0,0,0,0,0

[CharacterMng.cs]
SetCharaArrowActive関数に引数を追加する。
(bool randFlg)
呼び出し先で、複数回でtrue,全体でfalseとする
(単体もfalse)

int[] tmpArrayを用意しておき、最大回復数の4回に
合わせて中に-1をいれておく。

randFlgがtrueなら複数回なのでランダムで回復回数を
決めて、死亡中キャラも含めたキャラの中から誰を何回回復するか決定する。

randFlgがfalseなら全体なので死亡中キャラも含めて全員分tmpArrayに数字をいれる。

SelectToHealMagicCharaのコルーチンにも引数を追加して、tmpArrayが受け取れるようにする。
allFlagがtrueのときにはarrayの中を見るようにして、
for文で-1がくるまで回して回復させるようにする。

複数回回復確認完了。

最後に全体回復の確認をする。
データとしては、
1,全体回復小,アアア,non,2,10,2,0,0,0,0,0

確認完了。

<MPが足りないときに発動できないようにする>
攻撃魔法と共通処理でできてた

※死亡中にHP回復されてもNO EFFECT(効果なし)と
　カウントする

<判定方法を変える>
sub2に[HP]が来たらHP回復を発動させる

[CharacterMng.cs]
SetCharaArrowActive関数に引数を追加する。
int型でsub2が何番かで
SelectToHealMagicChara関数を呼ぶかどうか判断する。

※[HP]というのがsub2の中で[0]番なので、
　これでif文をつけておく
  →他の状態異常の回復もsub2とかみるので忘れずに！

-------------------------------------------------

<回復魔法にエフェクトをつける>--------------------

土魔法とかいろいろお世話になったgitの人から
HEALをダウンロードしてくる。

7種類のうち、4種類を使い分けたい。
(HP回復と状態異常回復で分けたい。HP回復は小中大で
 3種類。状態異常回復は1種類)
蘇生魔法用に1つ残しておく

<HP小回復のエフェクト>
Effectフォルダ内の[heal_1]フォルダのものをつかう。
攻撃魔法と同じように番号で判断させたい。

回復(エレメント)    ->0
小(威力)            ->0
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-0-0]という名前のプレハブにする

[CharaUseMagic.cs]
magicPrefabNum_変数を回復時には作り方を
変える必要がある。

// [エレメント-威力-
何を回復するか(sub2が0かそれ以外かで判断させたい)]
magicPrefabNum_ =
magicData.element.ToString() + "-" + magicData.tail.ToString() + "-" + magicData.sub2.ToString();
とする。

そして、InstanceMagicCoroutine関数で、
magicPrefabNum_変数をハイフンで分割したときに
2つに分けれたら(=攻撃魔法)
3つに分けれたら(=回復魔法)
として判断し、if文で分けるようにする

あとは発動座標を決める必要がある。
基本はキャラクターの立っている位置にしたい。

単体回復のときは、
useMagic_.InstanceMagicInfo(charasList_[(int)selectChara].GetButtlePos(), new Vector3(-1, -1, -1), -1, 0);

複数回or全体回復のときは、                        useMagic_.InstanceMagicInfo
(charasList_[array[i]].GetButtlePos(), new Vector3(-1,-1,-1), -1, i);
とする。

※[0-0-0]に使ったエフェクトがループ再生になっている
　ので、ループを解除する

<単体回復なのに2回エフェクトが生成されるバグ>
原因としては、攻撃魔法と処理がまざっていて
敵の数分処理が発生してた。

(対策法)
GetElementNum関数をCharaUseMagic.csに用意しておき
InstanceMagicInfo関数と、
StartCoroutine(useMagic_.InstanceMagicCoroutine());を呼ぶタイミングを攻撃魔法系と回復系で分けるようにする。

<回復魔法の再生終了後に魔法が削除されないバグ>
(原因)
MagicMove.csがないから自然消滅しない

(対策法)
ParticleSystemのStopActionを[Destroy]に設定する

確認完了。

<HP中回復のエフェクト>
Effectフォルダ内の[heal_4]フォルダのものをつかう。

回復(エレメント)    ->0
中(威力)            ->1
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-1-0]という名前のプレハブにする

ループ再生を切って、
ParticleSystemのStopActionを[Destroy]に設定する

確認完了。

<HP大回復のエフェクト>
Effectフォルダ内の[heal_6]フォルダのものをつかう。

回復(エレメント)    ->0
大(威力)            ->2
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-2-0]という名前のプレハブにする

ループ再生を切って、
ParticleSystemのStopActionを[Destroy]に設定する

大きめのエフェクトにしたいから、StartSizeをいじる
また、光彩のエフェクトのRotationを斜めに変更する
→地面と平行だとちらつくから

確認完了。

-------------------------------------------------

<魔法選択からTキーで戻ったときに、コマンド選択の
 画像がでないバグ>--------------------------------

現在は、回転画像が1つに対してアイコンや魔法をアタッチするようにしているけど、
回転画像をそれぞれにしたほうがよさそう。

魔法の回転画像の方は、最初はSetActiveを切っておく
enableもfalse

コマンド回転のほうも、魔法中はSetActiveとenableを
falseにする。

Commandの子のFrameもSetActiveを切り替えるようにする。

やっとバグがなおったぁぁぁ

更新するときはButtleUICanvasをプレハブで更新する。
もう一時保存ではなくて普通にプレハブとして扱う。

-------------------------------------------------

<状態異常系の処理>--------------------------------

予定としては、毒とかのスリップダメージ系は戦闘後にも持ち越すようにし、街に帰還したら強制的に治るようにする。
→現状のスリップダメージは「毒」のみ

状態異常にかかるかどうかはキャラの「Luck」を見てきめる。

[作成が必要な処理]
・毒
・暗闇
・麻痺
・即死

CharaBase.csに状態異常用のenumをつくっておいて、
各キャラや敵が自分の状態を管理できるようにする。
→同時に2つ以上状態異常になる可能性を考えると
　配列のほうがいいかもしれない

[CharaBase.cs]
enumでCONDITIONをつくり、
健康、毒、暗闇、麻痺、即死と入れる。

CharacterSettingの構造体の中にCONDITIONを用意して
初期化時に共通でNONに設定する

<キャラから敵に状態異常をかける>
基本は攻撃魔法についたサブワードからしかかからない
→可能性としてはアイテムで状態異常単体をかけること
　もあるかも？

<敵からキャラの状態異常をかける>
どの状態異常をかけるのかはExcelのEnemy.xlsに項目を増やしたほうがいい(数字より文字列のほうがいい)

ButtleMngオブジェクトにアタッチする形で
状態異常系を判断する新規Scriptを用意したほうがいい
→[BadStatusMng.cs]を作成

<「キャラ->敵」の状態異常について考える>
※アイテムは今は考えずに攻撃魔法についてきたもの
　だけでやる

状態異常系はsub1かsub2に必ず入る。
まずは、BadStatusMng.csを呼び出すまでの処理を書く。

[CharaUseMagic.cs]
sub1かsub2に状態異常系の数字が入っていたら
ButtleMng.csにSet関数を用意しておいて
敵に付与しようとしているenumを保存するように書く。

[ButtleMng.cs]
Set/GetBadStatus関数を用意する。

[CharaBase.cs][Chara.cs][Enemy.cs]
Set/GetBS関数を用意する。

[EnemyInstanceMng.cs]
敵はLuckで確認してかかるときにはButtleMng.csのGet関数でなんのバステにかかるか確認する。
そしてset_にいれる。
→Luckで付与するかどうかの判定は、Enemy.csの
　SetBS関数でやったほうがいい

テストとして、
sub1に毒を入れてる炎単体魔法を用意する。
2,単体炎小毒,イイイ,non,1,3,0,2,0,2,-1,-1

後ろから3番目がsub1で、Bag_Magic.csのenumを
見た感じだと毒は[2]だから2をいれる。
他は[-1]とする

デバッグしたところ、ちゃんと毒の場所の配列がtrueに
なったから付与まではできた。

あとは敵が自分のターンが終わる直前に毒のダメージを
入れるようにする。
→ダメージ処理とかいろいろ書くのはBadStatusMng.cs

<敵が自分のターンが終わる直前に毒のダメージ>
EnemyInstanceMng.csでBadStatusMng.csを呼び出せるようにしておき、自分の行動終了直前に呼び出す。

[CharaBase.cs][Chara.cs][Enemy.cs]
GetBS関数を用意する。

[EnemyInstanceMng.cs]
AfterAttack関数の中で、
badStatusMng_.BadState(enemyList_[num].Item1.GetBS());
と書いて、バステ効果を発動させる

<通常攻撃でも毒が付与されるバグ>
原因はSetBadStatus関数のなかを通常攻撃前に-1へ
戻していなかったから。

(対処法)
CharacterMng.csでコマンドがATTACKのときに
buttleMng_.SetBadStatus(-1,-1);
とするようにかく。

<実際の毒処理を書く>
[BadStatusMng.cs]
引数にT型のやつとHPMPBarとboolを用意した関数を用意する。
その中で毒が付与されているときはHPスライダーを動かして、内部数値を変更させる

[EnemyInstanceMng.cs]
自分の行動後にBadStatusMngを呼び出して、

badStatusMng_.BadState<Enemy>(enemyList_[num].Item1.GetBS(), enemyList_[num].Item1, enemyList_[num].Item2,false);
とする。

これで敵が毒の処理はできた。
次にキャラが毒の時の処理を書く。

[CharacterMng.cs]
BadStatusMng.csを取得する。
AnimationChange関数のIDLEのところでBadState関数を
呼び出す。

付与されたかを決めるのはHPdecrease関数内

状態異常を付与してくる敵を決める。
Field0だったらハチかなー。

テストとして、敵がハチならば通常攻撃に毒付与をいれるようにする。
[EnemyInstanceMng.cs]
Attack関数に
buttleMng_.SetBadStatus
((int)CONDITION.POISON,-1);
と追加する。

確認完了。

特定の敵の攻撃に状態異常を付与するのはちょっと後回しで、他の状態異常を先につくりおわる

[BadStatusMng.cs]
前判定用の関数と後判定用で分けたほうがいい

後判定は毒だけ。
他は前判定。

<暗闇状態の処理>
暗闇状態なら命中/回避率を下げるようにする

[EnemyInstanceMng.cs]
HPdecrease関数でSetBS関数のあとに
BadStateMoveBefore関数を呼び出すようにする。

magicData.csvでsub1を暗闇の[3]に変更する

[CharaBase.cs][Enemy.cs][Chara.cs]
SetSpeed関数を用意する

[BadStatusMng.cs]
BadStateMoveBefore関数のDARKで
SetSpeedを呼び出して半分にするように処理を書く

[EnemyInstanceMng.cs]
ButtleMng.csにSetSpeedを渡す前に処理を呼ばないといけないから、BeforeAttack関数に書く。

確認完了。

次はキャラが暗闇になったときの処理を書く。
[CharacterMng.cs]
BeforeAttack関数と、MagicAttack関数の最初で
BadStateMoveBefore関数を呼び出すようにする。

[EnemyInstanceMng.cs]
テストで敵が暗闇を付与するように書いておく

確認完了。

<マヒ状態の処理>
・動けるかどうかは自分のターンになってすぐ判定
・動ける場合は通常通りコマンド選択
・動けないときはそのキャラ/敵の行動をすぐにとばす

まずは敵が麻痺になったときの処理をつくる

[BadStatusMng.cs]
BadStateMoveBeforeの返り値をペアにして、
(コンディション,bool)とする。
→麻痺か即死のときに役立つ

麻痺で動けないときは
(CONDITION.ぱららいず,true)
動けるときは後ろのboolをfalseにする

確率で麻痺の判定をしたいから、
if(30 + enemy.Luck() < rand)
として、3割+自分の幸運値より大きいか小さいかで
そのとき動けるかどうかを判断する

[EnemyInstanceMng.cs]
BeforeAttack関数に入れているBadStateMoveBefore関数の引数でif文をおこなう。
        if(bst == (CONDITION.PARALYSIS,true))
        {
            // 麻痺で動けない
            anim_ = ANIMATION.IDLE;
            return;
        }
とする。

magicData.csvのsub1を麻痺の[4]にしておく

[CharacterMng.cs]
myTurnOnceFlg_という変数を用意して、
Buttle関数内で最初に麻痺状態を確認するときに使う。

if(!myTurnOnceFlg_)
{
   myTurnOnceFlg_ = true;
  var bst = badStatusMng_.BadStateMoveBefore　(charasList_[(int)nowTurnChar_].GetBS(), 　charasList_[(int)nowTurnChar_], charaHPMPMap_　[nowTurnChar_].Item1, true);

  if (bst == (CONDITION.PARALYSIS, true))
  {
      // 麻痺で動けない
      Debug.Log("麻痺だから行動を飛ばす");
      anim_ = ANIMATION.IDLE;
      oldAnim_ = ANIMATION.NON;
      oldAnim_ = anim_;
      AnimationChange();
      return;
  }
}

[EnemyInstanceMng.cs]
敵の攻撃が麻痺状態を付与させるようにテストでかく

確認完了。

<即死状態の処理>
[BadStatusMng.cs]
BadStateMoveBefore関数に処理をかく
DEATHのときには、
tmpConditionCheck =
(CharaBase.CONDITION.DEATH, true); 
と処理を書いておく

[EnemyInstanceMng.cs]
HPdecrease関数のバステ付与判定の後でBadStateMoveBefore関数を呼び出して返り値を見るようにする。そこで(CONDITION.DEATH,true)
になっていたときにはHPを-9999するようにしておく

magicData.csvのsub1を即死の[5]にする

確認完了。

つぎに、キャラの即死処理をかく
[CharacterMng.cs]
HPdecrease関数に敵処理と同じように
BadStateMoveBefore関数の呼び出しをする。

[EnemyInstanceMng.cs]
テストで即死付与をかく

※HPMPBar.csのMoveSliderBar関数を一部修正
　値が毎フレーム増減するように修正した

確認完了。

<特定の敵の攻撃に状態異常を付与する>
Enemy.xlsに項目を増やす必要がある
一番右に[Bst]という項目を増やして、
効果なし -1
毒   2
暗闇 3
麻痺 4
即死 5
という数字で設定していく

[EnemyList.cs]
public int Bst;を追加する

[Enemy_importer.cs]
cell = row.GetCell(16); p.Bst = (int)(cell == null ? 0 : cell.NumericCellValue);
を追加する

[Enemy.cs]
Bst関数を追加する

[CharaBase.cs]
敵用にBst変数を構造体に追加する

[EnemyInstanceMng.cs]
Attack関数で
buttleMng_.SetBadStatus(enemyList_[num].Item1.Bst(),-1);
と書く

※ちゃんとreimportすること

<バステの付与率を計算する>
今は幸運値でしか見ていないからほぼほぼかかる
これを修正していく。

[Chara.cs][Enemy.cs]のSetBS関数
・命中率と幸運値+ランダム(1d100)を比較する
→命中率が高かったら付与
→幸運値+ランダム(1d100)が高かったらバステ回避
※引数でint hitNumを追加して命中率を持ってくる
　ようにする
※敵の方がバステにかかりやすいようにランダムを
  (1d80)に調整する

[EnemyInstanceMng.cs][CharacterMng.cs]
hitProbabilityOffset変数をローカルのスコープを
広くしておいて、
必中なら値を200
それ以外は計算した数字を代入する
その数字をSetBS関数の引数に入れるようにする

<数ターンで状態異常が治るようにする>
今は、1度かかると状態異常が永続するので修正したい

各キャラと敵で自分の状態異常を管理するようにつくる

[CharacterMng.cs]
HPdecrease関数でバステが付与された直後に処理を追加する。

コンディションの数でfor文を回して健康状態以外がtrueになっていたらマップに保存していく。
※キーが存在しない場合はとばしたり、初回登録処理を
　別にしないとエラーになるから注意

あとは自分のターンの終了前に保存している持続数字を
マイナスしていき、0になったら登録を消す
※DEATHは即発動なのでfor文に入らなくても問題ない

全ての状態異常がなおったら、CONDITION.NONをtrueに
する処理が必要
→ConditionReset関数を用意した。

[EnemyInstanceMng.cs]
ほぼCharacterMng.csと同じ。
ターン数を短くする処理はAfterAttack関数に書いた。

<ボスには即死が利かないようにする>
さすがにボスが即死はまずいので、対策する
Enemy.csのSetBS関数内で、敵が自分の名前を取得
したときにボスだったら即死を無効にするように書く

[Enemy.cs]
ボスの名前を集めたstring[]変数を作成する
SetBS関数の中でそのボスの名前と一致していたら
DEATHをfalseにする

<状態異常を回復魔法で治せるようにする>
<毒回復>
データとしては、
1,単体回復小毒,アアア,non,2,10,0,0,0,0,1,0

[CharacterMng.cs]
ConditionReset関数を改善して引数を増やす
・全ての状態異常をリセットする
・回復したいやつだけリセットする
が選べるようにしておく

SelectToHealMagicChara関数でスペースキーを押した時
回復処理で毒・暗闇・麻痺の回復で
ConditionReset関数を呼び出すようにする
引数は(false,whatHeal)

状態異常回復はできたから、あとはエフェクト処理
状態異常のエフェクトは全部同じものを使う
数字としては
[0-威力-9]とする

<状態異常回復小>
使用するエフェクトは[Eff_Heal_3]
名前は[0-0-9]

ループ再生を切って、StopActionをDestroyにしておく
単体回復確認完了。

次に複数回ランダム状態異常回復
1,複数回回復小毒,アアア,non,2,10,1,0,0,0,1,0
ok

最後に全体状態異常回復
1,全体回復小毒,アアア,non,2,10,2,0,0,0,1,0
ok

念のため他の状態異常でも確認する

<<状態異常回復中><状態異常回復大>>
同じエフェクトでいいと思うから、[0-0-9]をコピペして
[0-1-9]
[0-2-9]
とする

1,全体回復中暗闇,アアア,non,2,10,2,0,1,0,2,0

-------------------------------------------------

<回復対象の選択からTキーを押したときに
 画像は戻るがスペースキーを押すとエフェクトがでる>-

(原因)
SelectToHealMagicChara関数のコルーチンを止めていないから矢印を非表示にした後すぐに表示状態に切り替えられている

(対処法)
CharacterMng.csにコルーチン管理の変数を用意して、
Tキーを押された時にStopコルーチンをしたあと、
その変数をnullにして初期化しておく。

-------------------------------------------------

<キャラHPが戦闘に反映されないバグ>----------------

ロードしたときにHPが15から50とかに増えない
[CharacterMng.cs]
ButtleSetCallOnce関数で
SetHPMPBarを呼び出すようにする。

<単純に保存内容が足りない>
nowHPとmaxHPで分けて保存したほうがよさそう

-------------------------------------------------

<後でやる事>
・状態異常中のアイコンがほしい
・nowHPとmaxHPで分けて保存する

ダメージ時に出血のエフェクトがでるんだけど、
これを参考に自前でエフェクト作ってアタッチさせたほうがよさそうだとおもった。


※Field0以外にもやらないといけない処理
　・FieldUICanvasのLayerを[Field]にする
　・ButtleMngにBadStatusMng.csをアタッチする

