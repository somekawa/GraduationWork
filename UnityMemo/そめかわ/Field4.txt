メインで使用するアセット↓
https://assetstore.unity.com/packages/3d/small-cave-kit-49372

暗い洞窟のなか、
ギミックとしてはミミックとか。

骸骨とか幽霊系の敵

色のついたスモークで毒を演出
→緑色のスライム系の色
通ったときに幸運値で毒にかかるか確認するScriptを準備する

クエスト内容としては、洞窟の奥から毒の霧が漏れ出してきて洞窟近くの街に被害がでている的な。

風のワードで毒の霧が外にすごい漏れ出してる的な設定
にする。

毒霧については、unity公式アセットの中に入っていた
Smoke&SteamEffectsを使用する予定。

-------------------------------------------------

FieldフォルダのMapフォルダの中に[Small Cave Kit]を追加する。
既存の物を更に道を拡張させるように変更していく。
※Torch setは、配置しなおしたほうがいい

Cave partsのRotationのY軸を-90にする
(unpackしておく)

基本的に、下向きの道をけしておく

壁の高さが足りないので、[Cave parts]のScaleZを1.5
に変更した。不都合がでたらまた考える


Sceneの名前を[Field4]にしておいて、階層を外に出す
カメラアニメーションとか使ってムービーとかタイトルをつくりたいなぁ。

<Field初回の会話発生の条件が甘かった>-------------

[FieldMng.cs]
イベントが発生するか確認するところで、
Fieldの番号も確認しておかないとだめぽい
→他のフィールドに入っても進行度の番号次第で
　会話が発生してしまう

-------------------------------------------------

<最低限動かすのに必要な要素を他のフィールドから
 もってくる>--------------------------------------
エラーでたからいろいろアタッチ直しした。
大丈夫そう。

-------------------------------------------------

<メインカメラの画角がやばい>----------------------

ユニの真後ろから撮るか、天井やっぱりぶち抜いて
見下ろし型にしたほうがいい

<見下ろし型にする>
[MainCamera]
Position X:0  Y:4 Z:2
Rotation X:55 Y:0 Z:0

MainCameraにアタッチしているCameraSample.csも
処理の追加が必要。
現在のフィールドがField4のところなら(数字的には3)
offset変数の値を別のものを入れるようにする。

Start関数時にはまだnowSceneがNONなので、
Initに変更して後から決定にしたほうがいい
※ついでにUpdateもコルーチンにできる

Init関数の呼び出し元は、CameraMng.csにしておいて
そのCameraMng.csの関数を呼び出すのはFieldMng.cs
からとする。(経由して設定みたいな感じ)

FieldMng.cs->CameraMng.cs->CameraSample.csのInit
みたいな。

確認完了。

-------------------------------------------------

<画面外が見えるのをなんとかしないとだよね>--------

真っ黒にしてみる。

FieldMapの子として[BlackPanel]を用意して、
都合よくFurnitureフォルダにBlackというマテリアルが
あったから流用する。
ScaleのXとZを大き目の10と設定して
地面より下に敷く。

-------------------------------------------------

<バトル位置を決定する>----------------------------

別で戦闘用の空間をつくったほうがいい。
画角的に外が見えちゃうから壁だけ高くしたい
→同じ形の地形を反転して蓋するみたいにした。

完全な左右対称ではないからちょっと切れ目みたいなのができるのでそこをオブジェクトで塞いでごまかしたい
→手前に合わせておいて、奥の切れ目はオブジェクトで
　ごまかした

[ButtleWarpPointPack]
Position X:42 Y:0 Z:-20

[ButtleWarpPointPack]
Position X:42 Y:0 Z:-17

-------------------------------------------------

<コライダーを追加する>----------------------------

形のMeshがあるから、MeshColliderをつけるだけでいけそう。
→とりあえず一括で全部につけた

[Cave parts]のインスペクターのStaticにチェックを
入れておく。

移動速度を結構落とさないとすり抜け地獄になる
→5.0fにした

道をふさいでいる岩には、BoxColliderをつけたほうが
良い。

小さすぎる石のコライダーはremoveしておく

行き止まりの丸角はBoxCollider置いたほうがいい
→その丸角の中にBoxColliderをアタッチする

-------------------------------------------------


<毒の霧を追加する>--------------------------------
nity公式アセットの中に入っていた
Smoke&SteamEffectsを使用する

Fieldフォルダの中のMapフォルダに追加した。
Prefabの中にある[PoisonGas]以外は全て削除する
→使わないTextureやらなにやらも消す

FieldMapの子オブジェクトとして
[PoisonSmoke]を作成し、その中に入れていく。

今後はこのプレハブに当たり判定を付ける感じで進める
→毒判定用


-------------------------------------------------

<登場する雑魚とボスのアセット>--------------------

①幽霊魔法使い(ボス+雑魚)
https://assetstore.unity.com/packages/3d/characters/creatures/fantasy-monster-wizard-demo-103037

②骸骨兵
https://assetstore.unity.com/packages/3d/characters/humanoids/fantasy-monster-skeleton-35635

③よくわからないのと宝箱(宝箱はミミック用)
https://assetstore.unity.com/packages/3d/characters/creatures/rpg-monster-partners-pbr-polyart-168251

④鬼ごっこゲームに使われていたやつ
https://assetstore.unity.com/packages/3d/characters/creatures/level-1-monster-pack-77703#content
→ここから2つとる

※狼(これは最後のフィールドに回そう)
https://assetstore.unity.com/packages/3d/characters/animals/mammals/casual-rpg-monster-wolf-208130

-------------------------------------------------

まだやらないといけないことはあるけど、
ひとまずField4完成！！

<戦闘フィールドに松明を置く>----------------------

暗くて見えんちゃん・・

-------------------------------------------------

<ジャックが定位置に戻るときに、位置が間違っているのかジャンプ->走る->止まるになる>-------------------

[Chara.cs]
BackMove関数のif(distance <= 0.1f)
を、0.15fにしたらうまくいった
→他のフィールドと敵との距離感が違うから戻り切れてないのかもしれない

-------------------------------------------------

<敵を追加する>----------------------------------
①Beholder
直訳すると「見る人」って意味らしい。。
ミミックとセットになっていた敵を近接攻撃の敵として
出現させる。

<アニメーションについて>
TurtleShellからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

Attack03がループになっているので、LoopTimeの
チェックを外す。

<Enemy.xls>
いい感じに付け加える
Enemy.xlsに"Field3"のタブを付けくわえておく
→Enemy_importer.csに"Field3"を足す

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Beholder]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Beholder]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に1番目で[Enemy_Beholder]を入れる。

アニメーターが死んでるバグが発生中。
→「Root」というオブジェクトの名前を変更しなければ
　アニメーションが発生した。
※空のオブジェクトでWeaponタグをつける
　「Beholder」を用意したほうがいい。

HPバーの位置を高くする敵としてif条件に追加しとく。

確認完了。

②スケルトン近接型
<アニメーションについて>
そもそもAnimatorがなかったから作成する。
TurtleShellからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

Idleのアニメーションにループがついてなかったので
チェックをいれておく

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Skeleton]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Skeleton]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に2番目で[Enemy_Skeleton]を入れる。

ちっっっちゃ。。
ScaleをXYZ全て10にする。

アニメーションに違和感
Runが終わるのが早くて、攻撃の初動がおそい。
攻撃モーションの時間を早めたほうがいいかも

途中で走りモーションが終わってしまう。
Run->AttackのHasExitTimeのチェックを外しておく。
また、ExcelのMoveTimeを[100]にする

確認完了。

③スケルトン遠距離型(MagicSkeleton)
<アニメーションについて>
Spiderからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

deadのモーションが長いので、短くする

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Skeleton]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
SpiderAttack(Clone)を使ってみる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に3番目で[Enemy_MagicSkeleton]を入れる。

大きすぎるんだけど。。。
ScaleをXYZ全て0.3に設定した。

ダメージ時に出血のエフェクトがでるんだけど、
これを参考に自前でエフェクト作ってアタッチさせたほうがよさそうだとおもった。

④こうもり
<アニメーションについて>
そもそもAnimatorがなかったから作成する。
Spiderからコピーしてきて、アニメーションの中身を入れ替える。

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Bat]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<遠距離攻撃型にする>
SpiderAttack(Clone)を使ってみる

<Field4Enemysプレハブ>
[Field4Enemys]の
中に3番目で[Enemy_Bat]を入れる。

ちっっっちゃ。。
ScaleをXYZ全て20にする

⑤ボス
こうもりと同じアセットの、
緑のスライムにしようかな。でっかくする

Bossのプレハブファイルに入れておく

<アニメーションについて>
そもそもAnimatorがなかったから作成する。
Skeletonからコピーしてきて、アニメーションの中身を入れ替える。

※ダメージモーションがないから、Dieと同じにする

<Enemy.xls>
いい感じに付け加える

<モデルにつけるコンポーネント>
本体の名前を[PoisonSlime_4]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[PoisonSlime]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

大きさをXYZ全て150程度にする。

<ButtleWallを用意する>
オブジェクト名を[6-1]にして、
X:38.4 Y:1.96 Z:37.36
に配置する。

ForcedButtle.csの
EventEnemy->PoisonSlime_4
EventEnemyNum->1
とする。

※まだメインクエストの6番目を作成していない

------------------------------------------------

<クエスト6の開始の会話を作成する>------------

Chapter.xlsに[Chapter18]を追加する。

[Chapter_importer.cs]
"18"を追加して、reimportしておく。

[Guild.cs]
GuildQuestEvent関数のクエスト受注タイミングの
switch文に、case 18を追加してquestNumが6なら
Chapter18を実行するように書く。

-------------------------------------------------

<クエスト6を追加する>-----------------------------

[QuestInfo.xls]
eventNumを18、questTypeを2にして
その他はそれっぽく書く。

[Guild.cs]
受注時に18で6番受注なら会話が発生するようにする

-------------------------------------------------

<回復魔法の作成をする>----------------------------

必要な要素
・単体
選択したキャラを一定値回復
magicattack依存

・複数
ランダムな回数回復する
※すでにHPがMAXのキャラも含めてランダム

・全体
全員のHPを回復する

・どれぐらいHPが回復するか点滅みたいな感じで
　だしたい

・エフェクトもそれっぽいのがほしい(後回し)

<単体小回復の実装>
データ的には
1,単体回復小,アアア,non,10,8,0,0,0,0,0,0

[CharaUseMagic.cs]
CheckUseMagic関数に回復処理を加える。
選択した魔法が回復だった場合(=elementが0)

キャラの枠の横に矢印をだすようにして選択できるようにしたい。
→ButtleUICanvasにある[UniCharaData]と
  [JackCharaData]の子に[ArrowImage(Image)]を付ける

[ArrowImage]
Uni
Pos X:-300 Y:100 Z:0
Rotate Yが180
Scale XYZ全て0.5

Jack
Pos X:-300 Y:50 Z:0
Rotate Yが180
Scale XYZ全て0.5

この矢印を選択中のキャラのみ表示するようにしたい。
[CharacterMng.cs]
charaArrowImage_という配列の変数を用意。
Start関数内でUniCharaData/ArrowImageとかをfindして
表示/非表示がいじれるようにしておく。

SetCharaArrowActive関数を新規作成し、引数に
全員の矢印を表示状態にするのか否かがはんだんできるようにする。

[CharaUseMagic.cs]
characterMngを取得するようにFindをしておく。
回復単体の時には、
characterMng_.SetCharaArrowActive(false);
とする。
複数回と全体の時にはtrueにする。

単体の時にはどのキャラを回復させるか操作できるようにしないといけない
HキーとJキーで矢印の表示を切り替える感じにしたい。

[CharacterMng.cs]
コルーチンを追加して、その中で回復対象を選択する
矢印の操作と決定の操作を行う。
(SelectToHealMagicChara関数)

<魔法とその使用キャラのMagicAttackに依存させる>
[CharacterMng.cs]
SelectToHealMagicChara関数で直値でいま回復値を入れてるから、そこをGetHealPower関数を呼び出すようにする。

[CharaUseMagic.cs]
healPower_変数を作成して、GetHealPower関数で渡せるようにした。

とりあえずここまでで基本の単体回復は終了。
あとは複数回と全体回復について処理を追加していく。

<複数回ランダム回復>
データとしては、
1,複数回回復小,アアア,non,10,8,1,0,0,0,0,0

[CharacterMng.cs]
SetCharaArrowActive関数に引数を追加する。
(bool randFlg)
呼び出し先で、複数回でtrue,全体でfalseとする
(単体もfalse)

int[] tmpArrayを用意しておき、最大回復数の4回に
合わせて中に-1をいれておく。

randFlgがtrueなら複数回なのでランダムで回復回数を
決めて、死亡中キャラも含めたキャラの中から誰を何回回復するか決定する。

randFlgがfalseなら全体なので死亡中キャラも含めて全員分tmpArrayに数字をいれる。

SelectToHealMagicCharaのコルーチンにも引数を追加して、tmpArrayが受け取れるようにする。
allFlagがtrueのときにはarrayの中を見るようにして、
for文で-1がくるまで回して回復させるようにする。

複数回回復確認完了。

最後に全体回復の確認をする。
データとしては、
1,全体回復小,アアア,non,2,10,2,0,0,0,0,0

確認完了。

<MPが足りないときに発動できないようにする>
攻撃魔法と共通処理でできてた

※死亡中にHP回復されてもNO EFFECT(効果なし)と
　カウントする

<判定方法を変える>
sub2に[HP]が来たらHP回復を発動させる

[CharacterMng.cs]
SetCharaArrowActive関数に引数を追加する。
int型でsub2が何番かで
SelectToHealMagicChara関数を呼ぶかどうか判断する。

※[HP]というのがsub2の中で[0]番なので、
　これでif文をつけておく
  →他の状態異常の回復もsub2とかみるので忘れずに！

-------------------------------------------------

<回復魔法にエフェクトをつける>--------------------

土魔法とかいろいろお世話になったgitの人から
HEALをダウンロードしてくる。

7種類のうち、4種類を使い分けたい。
(HP回復と状態異常回復で分けたい。HP回復は小中大で
 3種類。状態異常回復は1種類)
蘇生魔法用に1つ残しておく

<HP小回復のエフェクト>
Effectフォルダ内の[heal_1]フォルダのものをつかう。
攻撃魔法と同じように番号で判断させたい。

回復(エレメント)    ->0
小(威力)            ->0
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-0-0]という名前のプレハブにする

[CharaUseMagic.cs]
magicPrefabNum_変数を回復時には作り方を
変える必要がある。

// [エレメント-威力-
何を回復するか(sub2が0かそれ以外かで判断させたい)]
magicPrefabNum_ =
magicData.element.ToString() + "-" + magicData.tail.ToString() + "-" + magicData.sub2.ToString();
とする。

そして、InstanceMagicCoroutine関数で、
magicPrefabNum_変数をハイフンで分割したときに
2つに分けれたら(=攻撃魔法)
3つに分けれたら(=回復魔法)
として判断し、if文で分けるようにする

あとは発動座標を決める必要がある。
基本はキャラクターの立っている位置にしたい。

単体回復のときは、
useMagic_.InstanceMagicInfo(charasList_[(int)selectChara].GetButtlePos(), new Vector3(-1, -1, -1), -1, 0);

複数回or全体回復のときは、                        useMagic_.InstanceMagicInfo
(charasList_[array[i]].GetButtlePos(), new Vector3(-1,-1,-1), -1, i);
とする。

※[0-0-0]に使ったエフェクトがループ再生になっている
　ので、ループを解除する

<単体回復なのに2回エフェクトが生成されるバグ>
原因としては、攻撃魔法と処理がまざっていて
敵の数分処理が発生してた。

(対策法)
GetElementNum関数をCharaUseMagic.csに用意しておき
InstanceMagicInfo関数と、
StartCoroutine(useMagic_.InstanceMagicCoroutine());を呼ぶタイミングを攻撃魔法系と回復系で分けるようにする。

<回復魔法の再生終了後に魔法が削除されないバグ>
(原因)
MagicMove.csがないから自然消滅しない

(対策法)
ParticleSystemのStopActionを[Destroy]に設定する

確認完了。

<HP中回復のエフェクト>
Effectフォルダ内の[heal_4]フォルダのものをつかう。

回復(エレメント)    ->0
中(威力)            ->1
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-1-0]という名前のプレハブにする

ループ再生を切って、
ParticleSystemのStopActionを[Destroy]に設定する

確認完了。

<HP大回復のエフェクト>
Effectフォルダ内の[heal_6]フォルダのものをつかう。

回復(エレメント)    ->0
大(威力)            ->2
HP(何を回復するのか)->0
と、3つの判定が必要になる。
だから、[0-2-0]という名前のプレハブにする

ループ再生を切って、
ParticleSystemのStopActionを[Destroy]に設定する

大きめのエフェクトにしたいから、StartSizeをいじる
また、光彩のエフェクトのRotationを斜めに変更する
→地面と平行だとちらつくから

確認完了。

-------------------------------------------------

<魔法選択からTキーで戻ったときに、コマンド選択の
 画像がでないバグ>--------------------------------

現在は、回転画像が1つに対してアイコンや魔法をアタッチするようにしているけど、
回転画像をそれぞれにしたほうがよさそう。

魔法の回転画像の方は、最初はSetActiveを切っておく
enableもfalse

コマンド回転のほうも、魔法中はSetActiveとenableを
falseにする。

Commandの子のFrameもSetActiveを切り替えるようにする。

やっとバグがなおったぁぁぁ

更新するときはButtleUICanvasをプレハブで更新する。
もう一時保存ではなくて普通にプレハブとして扱う。

-------------------------------------------------

<状態異常系の処理>--------------------------------

予定としては、毒とかのスリップダメージ系は戦闘後にも持ち越すようにし、街に帰還したら強制的に治るようにする。
→現状のスリップダメージは「毒」のみ

状態異常にかかるかどうかはキャラの「Luck」を見てきめる。

[作成が必要な処理]
・毒
・暗闇
・麻痺
・即死

CharaBase.csに状態異常用のenumをつくっておいて、
各キャラや敵が自分の状態を管理できるようにする。
→同時に2つ以上状態異常になる可能性を考えると
　配列のほうがいいかもしれない

[CharaBase.cs]
enumでCONDITIONをつくり、
健康、毒、暗闇、麻痺、即死と入れる。

CharacterSettingの構造体の中にCONDITIONを用意して
初期化時に共通でNONに設定する

<キャラから敵に状態異常をかける>
基本は攻撃魔法についたサブワードからしかかからない
→可能性としてはアイテムで状態異常単体をかけること
　もあるかも？

<敵からキャラの状態異常をかける>
どの状態異常をかけるのかはExcelのEnemy.xlsに項目を増やしたほうがいい(数字より文字列のほうがいい)

ButtleMngオブジェクトにアタッチする形で
状態異常系を判断する新規Scriptを用意したほうがいい
→[BadStatusMng.cs]を作成

<「キャラ->敵」の状態異常について考える>
※アイテムは今は考えずに攻撃魔法についてきたもの
　だけでやる

状態異常系はsub1かsub2に必ず入る。
まずは、BadStatusMng.csを呼び出すまでの処理を書く。

[CharaUseMagic.cs]
sub1かsub2に状態異常系の数字が入っていたら
ButtleMng.csにSet関数を用意しておいて
敵に付与しようとしているenumを保存するように書く。

[ButtleMng.cs]
Set/GetBadStatus関数を用意する。

[CharaBase.cs][Chara.cs][Enemy.cs]
Set/GetBS関数を用意する。

[EnemyInstanceMng.cs]
敵はLuckで確認してかかるときにはButtleMng.csのGet関数でなんのバステにかかるか確認する。
そしてset_にいれる。
→Luckで付与するかどうかの判定は、Enemy.csの
　SetBS関数でやったほうがいい

テストとして、
sub1に毒を入れてる炎単体魔法を用意する。
2,単体炎小毒,イイイ,non,1,3,0,2,0,2,-1,-1

後ろから3番目がsub1で、Bag_Magic.csのenumを
見た感じだと毒は[2]だから2をいれる。
他は[-1]とする

デバッグしたところ、ちゃんと毒の場所の配列がtrueに
なったから付与まではできた。

あとは敵が自分のターンが終わる直前に毒のダメージを
入れるようにする。
→ダメージ処理とかいろいろ書くのはBadStatusMng.cs

<敵が自分のターンが終わる直前に毒のダメージ>
EnemyInstanceMng.csでBadStatusMng.csを呼び出せるようにしておき、自分の行動終了直前に呼び出す。

[CharaBase.cs][Chara.cs][Enemy.cs]
GetBS関数を用意する。

[EnemyInstanceMng.cs]
AfterAttack関数の中で、
badStatusMng_.BadState(enemyList_[num].Item1.GetBS());
と書いて、バステ効果を発動させる

<通常攻撃でも毒が付与されるバグ>
原因はSetBadStatus関数のなかを通常攻撃前に-1へ
戻していなかったから。

(対処法)
CharacterMng.csでコマンドがATTACKのときに
buttleMng_.SetBadStatus(-1,-1);
とするようにかく。

<実際の毒処理を書く>
[BadStatusMng.cs]
引数にT型のやつとHPMPBarとboolを用意した関数を用意する。
その中で毒が付与されているときはHPスライダーを動かして、内部数値を変更させる

[EnemyInstanceMng.cs]
自分の行動後にBadStatusMngを呼び出して、

badStatusMng_.BadState<Enemy>(enemyList_[num].Item1.GetBS(), enemyList_[num].Item1, enemyList_[num].Item2,false);
とする。

これで敵が毒の処理はできた。
次にキャラが毒の時の処理を書く。

[CharacterMng.cs]
BadStatusMng.csを取得する。
AnimationChange関数のIDLEのところでBadState関数を
呼び出す。

付与されたかを決めるのはHPdecrease関数内

状態異常を付与してくる敵を決める。
Field0だったらハチかなー。

テストとして、敵がハチならば通常攻撃に毒付与をいれるようにする。
[EnemyInstanceMng.cs]
Attack関数に
buttleMng_.SetBadStatus
((int)CONDITION.POISON,-1);
と追加する。

確認完了。

特定の敵の攻撃に状態異常を付与するのはちょっと後回しで、他の状態異常を先につくりおわる

[BadStatusMng.cs]
前判定用の関数と後判定用で分けたほうがいい

後判定は毒だけ。
他は前判定。

<暗闇状態の処理>
暗闇状態なら命中/回避率を下げるようにする

[EnemyInstanceMng.cs]
HPdecrease関数でSetBS関数のあとに
BadStateMoveBefore関数を呼び出すようにする。

magicData.csvでsub1を暗闇の[3]に変更する

[CharaBase.cs][Enemy.cs][Chara.cs]
SetSpeed関数を用意する

[BadStatusMng.cs]
BadStateMoveBefore関数のDARKで
SetSpeedを呼び出して半分にするように処理を書く

[EnemyInstanceMng.cs]
ButtleMng.csにSetSpeedを渡す前に処理を呼ばないといけないから、BeforeAttack関数に書く。

確認完了。

次はキャラが暗闇になったときの処理を書く。
[CharacterMng.cs]
BeforeAttack関数と、MagicAttack関数の最初で
BadStateMoveBefore関数を呼び出すようにする。

[EnemyInstanceMng.cs]
テストで敵が暗闇を付与するように書いておく

確認完了。

<マヒ状態の処理>
・動けるかどうかは自分のターンになってすぐ判定
・動ける場合は通常通りコマンド選択
・動けないときはそのキャラ/敵の行動をすぐにとばす

まずは敵が麻痺になったときの処理をつくる

[BadStatusMng.cs]
BadStateMoveBeforeの返り値をペアにして、
(コンディション,bool)とする。
→麻痺か即死のときに役立つ

麻痺で動けないときは
(CONDITION.ぱららいず,true)
動けるときは後ろのboolをfalseにする

確率で麻痺の判定をしたいから、
if(30 + enemy.Luck() < rand)
として、3割+自分の幸運値より大きいか小さいかで
そのとき動けるかどうかを判断する

[EnemyInstanceMng.cs]
BeforeAttack関数に入れているBadStateMoveBefore関数の引数でif文をおこなう。
        if(bst == (CONDITION.PARALYSIS,true))
        {
            // 麻痺で動けない
            anim_ = ANIMATION.IDLE;
            return;
        }
とする。

magicData.csvのsub1を麻痺の[4]にしておく

[CharacterMng.cs]
myTurnOnceFlg_という変数を用意して、
Buttle関数内で最初に麻痺状態を確認するときに使う。

if(!myTurnOnceFlg_)
{
   myTurnOnceFlg_ = true;
  var bst = badStatusMng_.BadStateMoveBefore　(charasList_[(int)nowTurnChar_].GetBS(), 　charasList_[(int)nowTurnChar_], charaHPMPMap_　[nowTurnChar_].Item1, true);

  if (bst == (CONDITION.PARALYSIS, true))
  {
      // 麻痺で動けない
      Debug.Log("麻痺だから行動を飛ばす");
      anim_ = ANIMATION.IDLE;
      oldAnim_ = ANIMATION.NON;
      oldAnim_ = anim_;
      AnimationChange();
      return;
  }
}

[EnemyInstanceMng.cs]
敵の攻撃が麻痺状態を付与させるようにテストでかく

確認完了。

<即死状態の処理>
[BadStatusMng.cs]
BadStateMoveBefore関数に処理をかく
DEATHのときには、
tmpConditionCheck =
(CharaBase.CONDITION.DEATH, true); 
と処理を書いておく

[EnemyInstanceMng.cs]
HPdecrease関数のバステ付与判定の後でBadStateMoveBefore関数を呼び出して返り値を見るようにする。そこで(CONDITION.DEATH,true)
になっていたときにはHPを-9999するようにしておく

magicData.csvのsub1を即死の[5]にする

確認完了。

つぎに、キャラの即死処理をかく
[CharacterMng.cs]
HPdecrease関数に敵処理と同じように
BadStateMoveBefore関数の呼び出しをする。

[EnemyInstanceMng.cs]
テストで即死付与をかく

※HPMPBar.csのMoveSliderBar関数を一部修正
　値が毎フレーム増減するように修正した

確認完了。

<特定の敵の攻撃に状態異常を付与する>
Enemy.xlsに項目を増やす必要がある
一番右に[Bst]という項目を増やして、
効果なし -1
毒   2
暗闇 3
麻痺 4
即死 5
という数字で設定していく

[EnemyList.cs]
public int Bst;を追加する

[Enemy_importer.cs]
cell = row.GetCell(16); p.Bst = (int)(cell == null ? 0 : cell.NumericCellValue);
を追加する

[Enemy.cs]
Bst関数を追加する

[CharaBase.cs]
敵用にBst変数を構造体に追加する

[EnemyInstanceMng.cs]
Attack関数で
buttleMng_.SetBadStatus(enemyList_[num].Item1.Bst(),-1);
と書く

※ちゃんとreimportすること

<バステの付与率を計算する>
今は幸運値でしか見ていないからほぼほぼかかる
これを修正していく。

[Chara.cs][Enemy.cs]のSetBS関数
・命中率と幸運値+ランダム(1d100)を比較する
→命中率が高かったら付与
→幸運値+ランダム(1d100)が高かったらバステ回避
※引数でint hitNumを追加して命中率を持ってくる
　ようにする
※敵の方がバステにかかりやすいようにランダムを
  (1d80)に調整する

[EnemyInstanceMng.cs][CharacterMng.cs]
hitProbabilityOffset変数をローカルのスコープを
広くしておいて、
必中なら値を200
それ以外は計算した数字を代入する
その数字をSetBS関数の引数に入れるようにする

<数ターンで状態異常が治るようにする>
今は、1度かかると状態異常が永続するので修正したい

各キャラと敵で自分の状態異常を管理するようにつくる

[CharacterMng.cs]
HPdecrease関数でバステが付与された直後に処理を追加する。

コンディションの数でfor文を回して健康状態以外がtrueになっていたらマップに保存していく。
※キーが存在しない場合はとばしたり、初回登録処理を
　別にしないとエラーになるから注意

あとは自分のターンの終了前に保存している持続数字を
マイナスしていき、0になったら登録を消す
※DEATHは即発動なのでfor文に入らなくても問題ない

全ての状態異常がなおったら、CONDITION.NONをtrueに
する処理が必要
→ConditionReset関数を用意した。

[EnemyInstanceMng.cs]
ほぼCharacterMng.csと同じ。
ターン数を短くする処理はAfterAttack関数に書いた。

<ボスには即死が利かないようにする>
さすがにボスが即死はまずいので、対策する
Enemy.csのSetBS関数内で、敵が自分の名前を取得
したときにボスだったら即死を無効にするように書く

[Enemy.cs]
ボスの名前を集めたstring[]変数を作成する
SetBS関数の中でそのボスの名前と一致していたら
DEATHをfalseにする

<状態異常を回復魔法で治せるようにする>
<毒回復>
データとしては、
1,単体回復小毒,アアア,non,2,10,0,0,0,0,1,0

[CharacterMng.cs]
ConditionReset関数を改善して引数を増やす
・全ての状態異常をリセットする
・回復したいやつだけリセットする
が選べるようにしておく

SelectToHealMagicChara関数でスペースキーを押した時
回復処理で毒・暗闇・麻痺の回復で
ConditionReset関数を呼び出すようにする
引数は(false,whatHeal)

状態異常回復はできたから、あとはエフェクト処理
状態異常のエフェクトは全部同じものを使う
数字としては
[0-威力-9]とする

<状態異常回復小>
使用するエフェクトは[Eff_Heal_3]
名前は[0-0-9]

ループ再生を切って、StopActionをDestroyにしておく
単体回復確認完了。

次に複数回ランダム状態異常回復
1,複数回回復小毒,アアア,non,2,10,1,0,0,0,1,0
ok

最後に全体状態異常回復
1,全体回復小毒,アアア,non,2,10,2,0,0,0,1,0
ok

念のため他の状態異常でも確認する

<<状態異常回復中><状態異常回復大>>
同じエフェクトでいいと思うから、[0-0-9]をコピペして
[0-1-9]
[0-2-9]
とする

1,全体回復中暗闇,アアア,non,2,10,2,0,1,0,2,0

-------------------------------------------------

<回復対象の選択からTキーを押したときに
 画像は戻るがスペースキーを押すとエフェクトがでる>-

(原因)
SelectToHealMagicChara関数のコルーチンを止めていないから矢印を非表示にした後すぐに表示状態に切り替えられている

(対処法)
CharacterMng.csにコルーチン管理の変数を用意して、
Tキーを押された時にStopコルーチンをしたあと、
その変数をnullにして初期化しておく。

-------------------------------------------------

<キャラHPが戦闘に反映されないバグ>----------------

ロードしたときにHPが15から50とかに増えない
[CharacterMng.cs]
ButtleSetCallOnce関数で
SetHPMPBarを呼び出すようにする。

<単純に保存内容が足りない>
nowHPとmaxHPで分けて保存したほうがよさそう

<Character.xlsに項目を追加する>
HPの次にMaxHP
MPの次にMaxMPを挿入する

<CharacterList.cs>
HPの次にMaxHP
MPの次にMaxMPの項目を入れる

<Character_importer.cs>
HPの次にMaxHP
MPの次にMaxMPの項目を入れる
※番号に注意！

reimportする

<CharaBase.cs>
キャラの方にだけ設定を追加する

<SaveLoadCSV.cs>
ステータスの項目の見出しとか
セーブ/ロードにmaxHPとmaxMPを追加する
※番号に注意！

<MenuActive.cs>
ステータスの表示の部分に現在数値/max数値
とするように修正する

-------------------------------------------------

<状態異常中のアイコンを用意する>------------------

<必要なもの>
・毒
・暗闇
・麻痺

[毒]
https://www.ac-illust.com/main/detail.php?id=22309007&word=%E6%AF%92%E3%80%80%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3%E3%80%80&searchId=2982839312

[暗闇]
https://www.ac-illust.com/main/detail.php?id=2431446&word=%E3%83%96%E3%83%A9%E3%83%83%E3%82%AF%E3%83%9B%E3%83%BC%E3%83%AB+%E6%B8%A6+%E5%AE%87%E5%AE%99+%E3%83%9F%E3%82%B9%E3%83%86%E3%83%AA%E3%83%BC&searchId=2602201495

[麻痺]
https://www.ac-illust.com/main/detail.php?id=22363195&word=%E9%9B%B7%E8%A4%87%E6%95%B0&searchId=1208806894


64*64のサイズに3つともあわせとく

<画像を1つにまとめる>
TexturePackerのツールをつかってひとまとめにする
まとめたやつはStreamingAssetsフォルダに入れておく

[ItemImageMng.cs]
enumにBADSTATUSICONを追加してAwake関数で
分割する

<画像のアタッチ先を準備する>
最高でも3つまでしかバステはつかないから3つImageを
用意する必要がある

まずはキャラクターの方の準備
ButtleUICanvasの中にある
[UniCharaData]と[JackCharaData]に
[BadStateImages(空のオブジェクト)]を置いて、
その子として[Bst0,1,2(Image)]を用意する

ここに画像を入れられるようにしたい
[CharacterMng.cs]
SetBstIconImage関数を用意する。
BadStatusImagesの子の数でfor文を回して
画像が入っていない場所にspriteMapを代入する。

この関数の呼び出しはHPdecrease関数の
SetBsとかをいろいろすませたあと。

あとは自然回復や魔法で治療したときにアイコンを消す
SetBstIconImage関数の引数で治療側の処理を追加する。

1回全てのアイコンをnullに戻してからまだ治ってない状態異常を再びセットするやり方でかく。

-------------------------------------------------

<2つの状態異常をつけるときにバグ>-----------------

2つめの画像がでない
バステの効果持続ターンを設定する処理がおかしかった

-------------------------------------------------

<敵側にも状態異常のアイコンが表示できるようにする>-

SetBstIconImage関数をBadStatusMng.csに移動させて
キャラと敵が共有化する

敵側のアイコンサイズは32にする
→HPSliderプレハブを更新することになる

EnemyInstanceMng.csにCharacterMng.csみたいに書いて
終了。共通化してたらやりやすかった

-------------------------------------------------

<補助系魔法の処理をつくる>------------------------

<味方からのバフ/デバフ必要部分>
・味方
　→魔法攻撃上昇
　→魔法攻撃反射
　→魔法攻撃吸収

　→物理攻撃上昇
　→物理攻撃反射
　→物理攻撃吸収

　→命中/回避上昇
　→防御力上昇

・敵
　→魔法攻撃低下
　→物理攻撃低下
　→防御力低下
　→命中/回避低下

敵への
デバフの方が作りやすそうだから先にそちらをすませる

<敵の物理攻撃低下>
データとしては、
単体補助小敵物理攻撃低下
Head【0】
Element【1】
Tail【0】
Sub1【1】
Sub2【1】
Sub3【1】

2,単体補助小敵物理攻撃低下,
イイイ,non,1,3,0,1,0,1,1,1

・補助魔法かどうか判断
・単体/ランダム/全体かを判断
・味方へか敵へか判断
・魔法/物理/防御力/回避・命中のどれか判断
・上昇か低下か判断

[CharaUseMagic.cs]
補助魔法かの判断をする。
else if(magicData.element == 1)
に処理を書いていくようにする

headを見てcaseでわける
敵用の処理としてif文でわけたほうがいい
sub1を見て、0なら味方へのバフ,1なら敵へのデバフ

ButtleMng.csにどの項目を下げるのか、上げるのか
というのを渡すようにする

[ButtleMng.cs]
Set/GetAuxiliary関数を作成する。
(Auxiliary = 補助)

変数でauxiliaryNum_を作成しておき、ここで管理する。

[CharaUseMagic.cs]
SetAuxiliary関数を呼び出してセットする

あとはどこでGetしてあげたらいいのか。。
CharacterMng.csのMagicAttack関数で
続きの処理を書いていきたい

<エフェクトを先に決定する>
上昇系と低下系で分けたいからsub3できめたほうがいい
今回の場合だと、
威力
敵
項目
低下
だから、
[0-1-1-1]というエフェクトをつくる
とりあえず適当なエフェクトを複製して作成
※同様に[1-1-1-1][2-1-1-1]

攻撃魔法系と同じように敵にあてて、
あたったときにデバフをつけるようにしたい
→当たるまで色を透過しとけばばれない

[CheckAttackHit.cs]
数字が4文字以上のとき、補助魔法に該当するから
EnemyInstanceMng.csのDebuff関数を呼び出すようにする。Debuff関数の引数に<威力>と<項目>が入れられる
ようにする。

[EnemyInstanceMng.cs]
Debuff関数を用意しておく。
この関数の中でSetBuff関数を呼び出す

[CharaBase.cs][Enemy.cs][Chara.cs]
SetBuff関数を用意しておく。

[Enemy.cs]
SetBuff関数について書いていく。
引数のtailによってどれだけ増減するか決める

(tail)
小(0)->1割
中(1)->3割
大(2)->5割
みたいな
数字をつくるとしたら、
小+小+1 = 1
中+中+1 = 3
大+大+1 = 5
となる。

次に減少する項目を選択する
switch文でbuffの数字をみて
0から3で判断する

基本3ターン固定として、3ターン経過後にはデバフを
消すようにしたい

方針としては、元のAttackとかDefenceの値は動かさないで、別で値を管理するmapを用意しておき
ターン数と共に低下した値を保存する仕組みにする

[Enemy.cs]
private Dictionary<int, (int, int)> Debuffmap_ 
        = new Dictionary<int, (int, int)>();
という変数を用意する。

最初の値はset_系から取り出しておいてItem2は-1としておく。
デバフにかかったら固定3ターンにしておき数値をいじる

あとは3ターン後に回復する処理を書きたい。
CheckBuffTurn関数を用意しておき、0ターンでない場合は-1ターンするように書く。
もし0ターンの場合は数字をAttackとかのやつをいれるようにする。
→これをEnemyInstanceMng.csの
　AfterAttack関数で呼び出す

Enemy.csでデバフ部分をswitch文でしていたが、
AttackとかSpeedの値をintの配列にして保存し、
まとめられるようにした。

Debuffmap_[buff] =
(statusMap_[buff - 1] - (int)num, 3);
とか。

デバッグ大丈夫そうだからキャラのほうにうつろう。

<キャラにバフをもれるようにしよう>
基本はEnemyのデバフと同じ仕様でいけるとおもう。

[Chara.cs]
SetBuff関数とCheckBuffTurn関数をEnemy.csと同様に内部処理を書く。

この2つの関数をどう呼び出すかが問題となってくる。

※SetTurnInit関数内でstatusMap_変数とかbuffMap_変数を初期化するようにしておく

[CharaUseMagic.cs]
GetElementNum関数をGetElementAndSub1Num関数に修正
した。魔法を発動させるときにインスタンスが2回走る原因として、魔法攻撃と補助魔法の敵デバフ処理が重なっていた。それを直すのにelementとsub1の値を見るif文に
する必要があったから。

次に、
補助魔法処理のelse if(magicData.sub1 == 0)
部分を書いていく。

威力 
味方
項目
上昇
だから[0-0-1-0]とかになる
※同様に[1-0-1-0][2-0-1-0]
適当にエフェクトをつかっておく。

データとしては、
2,単体補助小味方物理攻撃上昇,イイイ,non,1,3,0,1,0,0,1,0

SetCharaArrowActive関数を呼び出すときに
エレメントを見て0なら回復、それ以外なら補助という使い分けをする。
→rest_変数に入れるコルーチンを分ける

SelectToBuffMagicChara関数を作成して、
中で選択したキャラに対してのSetBuff関数を呼び出すようにする。

あとはIDLEのときに
CheckBuffTurn関数を呼び出すようにしてバフを1ターン減少させるようにしておく。

上昇処理はできたっぽい。
一応エフェクトの再生はループ切って再生後はdestroy
されるようにしておこう
([0-0-1-0][1-0-1-0][2-0-1-0]のエフェクト)
あと発生する高さがちょっと気に食わない
→CharaUseMagic.csの補助魔法のadjustPosで
　CharaPos.yに+0.5fしておく

※CharaUseMagic.csの共通部分をCommon関数にまとめて
　行数を減らしておく

<反射処理>
補助の物理/魔法攻撃時にsub3で[反射]がきたときの
処理を追加する。

テトラカーンの能力としては味方に1度反射する攻撃をくらうまでは永続効果になる。これを同じように採用する

データとしては、
2,単体補助小味方物理攻撃反射,イイイ,non,1,3,0,1,0,0,1,2

適当なエフェクト(水エフェクトからとってきた)で、
小-味方-物理攻撃-反射だから、
[0-0-1-2]をつくる

[CharacterMng.cs]
SetCharaArrowActive関数の引数にsub3を持たせられるようにする。

SelectToBuffMagicChara関数の引数にもsub3を持たせられるようにして設定する。

SelectToBuffMagicChara関数では、
sub3で上昇か反射か吸収かを見分けるようにする。

[CharaUseMagic.cs]
magicData.sub3を引数として設定する

[Chara.cs]
Set/GetReflectionOrAbsorption関数を用意する
(Enemyでは使わないから個別でつくってよし)

ここで反射や吸収、効果なしを決められるようにする。
enumでいいね。

[CharacterMng.cs]
ダメージをくらう直前に現在のバフ状態を見て
反射か吸収の処理をおこなうようにする。

(反射)
反射相手がわかるようにしないといけない

CheckAttackHit.csでSetTargetNum関数の引数に
攻撃する側の数字も入れるようにして、
HPdecrease関数にその値を入れて、
反射のときにはButtleMng.csを経由して数字を渡して
NotMyTurn関数で反射処理をする。

反射ダメージは確実にあたるようにHPdecrease関数の引数にboolをいれといたほうがいい

デバッグ完了。

(吸収)
くらったダメージの半分を回復値とする
SetHP関数を呼ぶようにする
→防御力から引いた値にならないようにGet関数から
　直接値をとってくる

データとしては、
2,単体補助小味方物理攻撃反射,イイイ,non,1,3,0,1,0,0,1,3

適当なエフェクト(エフェクトからとってきた)で、
小-味方-物理攻撃-反射だから、
[0-0-1-3]をつくる

デバッグ完了。

<エフェクト差し替え>
・バフ
・デバフ
・反射
・吸収

いつものサイトで、Eff_Auraのシリーズをおとしてくる

Aura1を逆さまにしてデバフに使うのと、
Aura2はそのままで色違いにしてバフでつかう

[バフ]Eff_Aura_2を使用
物理攻撃アップ[0-0-1-0][1-0-1-0][2-0-1-0]赤系
魔法攻撃アップ[0-0-2-0][1-0-2-0][2-0-2-0]青系
防御力アップ　[0-0-3-0][1-0-3-0][2-0-3-0]緑系
命中/回避アップ[0-0-4-0][1-0-4-0][2-0-4-0]黄系

小威力
Aura_1とfire1を削除して、
Shockとpar3だけで表現する。
全体的なサイズがでかいからそこも調整する
あとループ再生も切って、再生後はDestroyする。
ShockのDurationを2にして、2秒間でエフェクトが終わるようにする。

同様に青・緑・黄もつくる

中威力
Aura_1を追加したバージョンにする
あんまりAura_1が上まで立ち昇らないようにする
→StartSizeとかStartDelayとかで調整する

同様に青・緑・黄もつくる

大威力
うーん。。。もっと派手にする方法？
とりあえず最初の通りのAura_2を使用する

同様に青・緑・黄もつくる

ここまで完成。

[デバフ]Eff_Aura_1を使用
par1のRotationXを180にした。

威力差も見た目もぶっちゃけおなじで良い。
→デバフ系なら固定で同じ番号呼ぶようにしよう
[0-1-1-1]固定

色を紫っぽくしてなんかデバフ感をだしといた。
あとは再生が最後まで終了するまで待つようにしたい。
→CheckAttackHit.csで補助魔法にMagicMove.csがアタ　ッチされているかで判断して、アタッチされてたら
　再生を待つようにする

<反射と吸収の良いアセットがないから、
 新しくアセットストアで探す>
https://assetstore.unity.com/packages/vfx/particles/3d-games-effects-pack-free-42285

<反射>
[0-0-1-2]
固定で同じ番号呼ぶようにする

<吸収>
[0-0-1-3]
固定で同じ番号呼ぶようにする


この2つのエフェクトがまだ決まってないから後回し。

[_Creepy_Cat]ファイルの05と08のエフェクトをつかう
05->反射
08->吸収
とりあえずこのフォルダをEffectフォルダの中に入れる

[0-0-1-2]反射
半径を小さくする->StartSizeを1.5
PositionYを0.5にする
ループ再生を切って、終了後にDestroyする
→ループ切ってもDestroyしない！！
おそらくTextureの関係で消滅していないのかも？
時間で消滅させたほうがいいかもしれない

(対処法)
・Rigidbody->usegravityのチェックをはずす
・MagicMove.cs
をアタッチする

MagicMove.csにSerializeFieldでdestroyTime_を用意して、初期値は-1.0fにする。

Start関数の中にdestroyTime_が0.0f以上なら
Destroy(this.gameObject, destroyTime_);
とする。
これで時間指定で消せるようになった。
→時間設定を3にする

あとは他の反射も0-0-1-2で固定する。
[CharaUseMagic.cs]
Common関数のflagがtrueのときのif文に、
if (split[3] == 2.ToString() &&
    split.Length == 4)
ならobj = Resources.Load("MagicPrefabs/0-0-1-2") as GameObject;
とするようにかく。
→吸収魔法の時の処理も似たように書く

[0-0-1-3]吸収
半径を小さくする->StartSizeを1.0
PositionYを0.5にする

・Rigidbody->usegravityのチェックをはずす
・MagicMove.cs
をアタッチする
→時間設定を3にする

<バフアイコン>------------------------------------
四角っぽいアイコンの横にバフ倍率を書きたい
□20%みたいな
アイコンのサイズは64*64でつくって32*32に貼り付けて
縮小しよう
※吸収/反射は、アイコンじゃなくてキャラの周りに
　つねにエフェクトを出すようにする

4つ作成できたから、[BuffIcon.png]という名称にして
まとめて保存する
→物理・魔法・防御・命中回避の順番に並べるのが大事

あとはバフをかけたときにアイコンとどれぐらいバフが
かかったか数字を出すようにする。
1割なら10%とか

まずは物理攻撃上昇でバフ画像がでるようにしていく
[ItemImageMng.cs]
enumに[BUFFICON]を追加して、Awake関数に
spriteMap[IMAGE.BUFFICON] =
ImageMng(1, 4, "/BuffIcon");
とする。

[CharacterMng.cs]
eachCharaDataの構造体にbuffIconParent変数を追加しておき、FindでBuffImagesのオブジェクトを取得する。
(BuffImagesオブジェクトは新規追加したもの)

SetBuff関数の処理後に追加されたバフのアイコンを表示するようにしてみる。
→基本的には状態異常のアイコンをだすときと似てる
倍率を数字で出すのはダサかったので、▲矢印にする

▲が3段階にわけるとして、

▲*1 = バフが1%~30%
▲*2 = バフが31%~70%
▲*3 = バフが71%~100%
とする。

バフの画像と▲画像は1つにまとめたプレハブにする
現在の倍率をみてArrowのSetActiveをtrue/falseする

[Chara.cs]
(現在値 - 元値) / 元値 = 倍率
例でいうと、
15 - 10 = 5
5 / 10 = 0.5(5割)
という感じで数字が出せる

SetBuffの返り値をintにして、
0.5 * 100 = %にして
その値が10~30,40~70,80~100で
それぞれ0,1,2の数字で返そう

[CharacterMng.cs]
ラムダでアイコンの表示/非表示を管理する
→単体魔法でも複数or全体でも対応できるように

あとは、魔法がきれたときにどうするか
バフの解除処理はCheckBuffTurn関数でしている。
→返り値をboolにして、バフ/デバフの効果がきれたら
　falseを返すようにする

[CharaBase.cs][Chara.cs][Enemy.cs]
GetBuffMap関数を作成する

[CharacterMng.cs]
CheckBuffTurn関数の返り値がfalseだったときには、
GetBuffMap関数を呼び出して、効果がきれたバフの
アイコンや上昇矢印の非表示処理をする。

<反射と吸収のバフアイコンについて>
□の中に文字で[反][吸]とかかく。
□の色を赤と青のどちらかにして、
赤->物理
青->魔法
の効果とする。

まずはBuffIconの画像にこの四角だけの画像を2つ足す。
→TexturePackerを使う作業

その後、画像分割の部分を書き直して
CharacterMng.csとButtleCanvas(オブジェクト)に
処理とImageを追加する。

SpecialBuff(Image)と、その子としてText(TMP)を
追加した。

物理と魔法の区別が処理になかったので追加していく
→区別するにはsub2を見る必要がある

Chara.csのSPECIALBUFFのenumや、
SetReflectionOrAbsorption関数に物理と魔法の区別が
付けられるように処理を追加した。

-------------------------------------------------

<バフの重ね掛け処理>------------------------------

SetBuff関数に処理の追加をする。
buffNumのところにfloat tmpの値の計算結果で
*100じゃなくて*10したものをいれる

ターン数が-1のときは3ターンバフで、
それ以外なら1ターンバフ延長。とする

同じバフの重ね掛け時にアイコンが増えるバグ
→重ね掛け時にはアイコン追加処理に飛ばないようにす　るために、SetBuff関数の引数を(int,bool)にする
　trueのときにはアイコン追加に飛ばないようにする

バフの倍率がやっぱりちょっと低すぎるなぁ。。
変更しよう！

[元]小(0)->1割,中(1)->3割,大(2)->5割
[新]小(0)->2割,中(1)->4割,大(2)->6割
(tail + 1) * 2とすればいい

-------------------------------------------------

<敵へのデバフアイコン>----------------------------

[元]小(0)->1割,中(1)->3割,大(2)->5割
[新]小(0)->2割,中(1)->4割,大(2)->6割
(tail + 1) * 2とすればいい
これをEnemy.csのSetBuff関数にも適用する。

アイコンの設置位置としてはHPバーの下らへんかな

PrefabのHPSliderにBuffImagesのオブジェクトを追加して、PrefabのBuffを4ついれる。
中の矢印アイコンを下向きにして、Colorを赤に変更。

[EnemyInstanceMng.cs]
private GameObject[] enemyDebuffIconImage_ =
new GameObject[4];    // デバフアイコン
を作成しておく。

Debuff関数にバフのアイコン処理を書く。
→CharacterMng.csと同様

あとはEnemy.csのほうのSetBuff関数にも似たような処理を書いたら完成。
※デバフ効果がきれたときにアイコン消す処理忘れてた

AfterAttack関数に追加で書いて終了

<バステで麻痺のときの処理>
AfterAttack関数をよびだして、デバフとバステの
ターンを進めるようにする。
→キャラ側はIDLEを呼び出していてそのなかにバフと
　バステ処理があるから大丈夫。

-------------------------------------------------

<戦闘中と戦闘外にアイテムをつかう処理>-------------

UseItem.csを新規で作成して、この中に各アイテムの
効果処理を書いていく。
→UseItem.csは、DontDestroyCanvasのItemBagMngに
　アタッチする

[DontDestroyCanvasオブジェクト]
ItemBagMng-InfoBackの子として、
[ItemUse(Button)]を追加する。
「捨てる」ボタンの操作をしているのがBag_Item.csということなので、ここに「使う」ボタンの表示処理も
加えていく。

[Bag_Item.cs]
SetItemNumber関数にUseBtn_変数として処理を追加する
新規でOnClickUseButton関数を作成して、
ItemUseにアタッチする。
→Managersから引っ張ってくる

UseItem.csをFindできるようにしておき、
新規で作ったUse関数を呼び出すようにする。
(引数にclickItemNum_を受け取って効果がわかるように)

[UseItem.cs]
Use関数を作成し、
DontDestroyCanvasのItemBagMngにアタッチする

あとはUse関数に死ぬほど処理を書いていくだけ。

まずは、戦闘以外でも使えるかどうかの判断処理を書く
→全アイテムが21種類なので
　0,1で戦闘以外でも使える/使えないをわけていく
　
次にUse関数の中でreturnする内容を条件分けてかく。

return処理を抜けられた下のほうで、実際のアイテムの
処理を書く。

Use関数の返り値をboolにしてreturn trueのときには
haveCntを--するようにする。
※画面上の数字は減ってないからさきちゃんの方のバグ

<各アイテムの処理>
[0]HPポーション(小)
まずは確定でユニのHPを回復できるようにする。
SceneMng.charasList_[0].SetHP(SceneMng.charasList_[0].HP() + 10);

[1]毒消し
とりあえず確定でユニの毒を回復する
SceneMng.charasList_[0].ConditionReset(false, (int)CharaBase.CONDITION.POISON - 1);

[2]攻撃アイテム
全体に無属性の確定値ダメージとする

[3]カエレール
フィールドで使用したら街へ帰れるようにする
FieldMng.nowMode = FieldMng.MODE.SEARCH;
FieldMng.oldMode = FieldMng.MODE.NON;
SceneMng.SceneLoad((int)SceneMng.SCENE.UNIHOUSE);
と記述する。
nowModeとかを切り替える事で、他シーンで歩行できるようにしている。

[4]ニゲレール
強制戦闘でない場合は使用可能とする

[13]エンカウント率低下
FieldMng.cs
stopEncountTimeFlg
stopEncountTimeFlgOld_
keepTime_
という3つの変数を用意する。

UseItem.cs
stopEncountTimeFlg = true
とする。

FieldMng.cs
Update関数に
stopEncountTimeFlg &&
stopEncountTimeFlg != stopEncountTimeFlgOld_
の条件の時に現在の値を保存しておいて
エンカウントまでの時間を大幅に伸ばすようにする。

その後、戦闘に入ったら効果がきれるタイミングだから
保存していた値を入れなおして通常のエンカウント率に
戻す。

-------------------------------------------------

<メニュー画面からアイテムを使用するキャラを選択
 できるようにする>--------------------------------

①「使う」を押す
②InfoBackが右に、③が左にずれる
③空いた左のスペースに、
　キャラ名とHPとMPを数字で表示する

→InfoBackの後ろに常に数字とかは表示しておいて、
　左右にずれたようにしてみせたい

DontDestroyCanvasのItemBagMngにCharasTextを追加する。それにユニとジャックのステータス値をいれる
Textを子としてもたせる。
※これが③

左右にずらす処理ではコルーチンをつかう。

元に戻すタイミングは、
・アイテムを1つ使ったとき
・違うアイテムのボタンを押した時
コルーチンの引数にboolを持たせておいて、
true->左右に広げる　,false->初期位置に戻す
と使い分ける

<回復相手を選べるようにテキストをボタンに変更>
クリックに合わせてそのキャラを回復するようにする
CharasTextの親としてButtonを追加する。
これを押されたら回復。としたい。

[ItemUse.cs]
Use関数の返り値を2つにして、
(bool->今使えるかどうか,bool->使う際に対象の指定が必要かどうか)
とする。

またOnClickCharaButton関数を作成して、
Buttonにアタッチし、押されたボタンに応じたキャラを
回復させるようにする。
→ItemBagMngからアタッチを引っ張ってきて引数に
　上から順に0,1とする。

<実際のキャラのステータス値をいれる>
画面を開いた時に1回と、回復毎に1回Init関数が
呼ばれる感じにしたい。

[UseItem.cs]
TextInit関数をつくる。
MenuActive.csのStatusViewみたいに作成して
Bag_Item.csとOnClickCharaButton関数内で呼び出す。

呼び出す際には引数でTextの配列を入れられるように
GetComponentの処理が必要になる。

これで個別の回復処理が完成した。

DontDestroyCanvasの一部更新が必要となる。

-------------------------------------------------

<戦闘中にアイテム選択ができるようにする>-----------

DontDestroyCanvasのItemBagMngだけを
表示できるようにしたい。

→MenuActive.csにGetItemBagMng関数があるから
　これのActiveをtrueにできたらいいかも
　(MenuActive.csはSceneMngにアタッチされてる)

[CharacterMng.cs]
switch文のITEMのところで、
GameObject.Find("SceneMng").GetComponent<MenuActive>().GetItemBagMng().gameObject.SetActive(true);
と記述して呼び出してみる。
→なぜか魔法のやつがでてきた
　2回目は成功。原因調査中

Townから遷移する前にメニューからアイテム画面を
開くかどうかで表示物がかわっている。
開かない->アイテム画面に魔法(バグ)
開く->アイテム画面にアイテム(正常)
たぶんSetActiveを呼ぶやつが間違ってる感じ

ItemBagMngをtrueにして
その子を一度全部falseにして
ItemMng・CharasText・InfoBack・Topicsをtrueにする
この関数をMenuActive.csに用意して、CharacterMng.csで呼び出す

クリックで回復したときにHPMPバーの方も変動させるようにしたい。
→アイテムをつかったあとに画面を閉じて、
　そのときに自動更新されるようにする。

Bag_Item.csでhaveCntが--されたときに
trueになるフラグをstaticで作成する。
CharacterMng.csでそのフラグの状態をみてアイテムが使用されたか判断

次に状態異常をアイテムで治すとき
[UseItem.cs]
condition_変数を作成して、回復する内容に対応した
enumをいれる。
クリックされたときに回復が発動するようにしておく。
(condition_ - 1 が 0 より大きいときは状態異常回復)

[CharacterMng.cs]
Bag_Item.itemUseFlgがtrueのときに
デバフの更新処理を入れる。
各キャラのGetBS関数を呼んで
コンディションが全てfalseになっていたら(NON含め)
アイテムで状態異常を回復したことになるから
badStatusMngのSetBstIconImage関数を呼び出すようにする。

-------------------------------------------------

<敵全体へ攻撃するアイテムの実装>------------------

[UseItem.cs]
GameObject.Find("ButtleMng").GetComponent<ButtleMng>().ItemDamage(15);
とする。

[ButtleMng.cs]
新規でItemDamage関数を作成し、
SetDamageNum(itemDamageNum);    
// ダメージ値をセット
enemyInstanceMng_.ItemDamage(); 
// 全エネミー分HPdecrease関数を回すようにする
をかく。

[EnemyInstanceMng.cs]
新規でItemDamage関数を作成し、
// 対象は全てのエネミー
for(int i = 0; i < enemyList_.Count; i++)
{
    HPdecrease(i,true);
    enemyList_[i].Item1.DamageAnim();
}
とする。
これで敵への攻撃アイテム処理が完成
※ここにエフェクト系の追加がほしいところ

-------------------------------------------------

<アイテムでキャラ単体に中威力バフをつける>---------

全体へするのはだいぶめんどくさそうだからやめる。
[UseItem.cs]
それぞれでtmpFlgをtrueにしてキャラ指定用にする。
変数でpair(int,int)のbuff_をつくり、
そこにバフに該当する数字をいれる。
→pairにしないと、物理&魔法攻撃up処理が作れないから

あとはOnClickの関数のところにactionのラムダ式を
用意してバフ画像を出しながら、キャラ毎の
SetBuff関数を呼び出すだけ。

-------------------------------------------------

<戦闘中に逃げれるアイテムの実装>------------------

[UseItem.cs]
強制戦闘ではないときは、
敵を削除して現在のMODEをSEARCHにもどし、
ユニの座標を再設定してアイテム画面を閉じるようにする。

強制戦闘中は
return (false,tmpFlg);としておく

[ButtleMng.cs]
Get/SetFieldPos関数を用意しておく。

[CharacterMng.cs]
keepPos_変数で戦闘前後の座標を保持していたのを
ButtleMng.csに渡すようにした。
→UseItem.csでもこの座標が使えるようにするため。

-------------------------------------------------

<蘇生アイテムの実装>------------------------------

キャラの復活モーションがないからエフェクトで
ごまかしてIDLE状態に戻すようにしたい。

HPが0のキャラに対して使用すると
最大値の半分、もしくは全回復するようにする

[UseItem.cs]
private string alive変数を用意し、
半回復なら"half"
全回復なら"all"
を代入する

OnClick処理にaliveが"half"なら最大値の半分まで
回復して、SetDeathFlg関数をfalseにする。
("all"も同様)

[Chara.cs]
SetDeathFlgで、falseが設定された時には
key_deathをfalseにする処理を追加する。

[ユニとジャックのアニメーション設定]
DeathからIdleに戻る矢印を追加して、
deathFlgがfalseならIdleへ遷移するように設定する

これで蘇生処理は終了

-------------------------------------------------

<即死身代わりアイテム>----------------------------

敵の付与してくるバステで、即死にかかりそうになったとき、バッグの中身を検索してもっていたら自動で-1
して即死を無効化する。

[UseItem.cs]
ここには何も書かない

[CharacterMng.cs]
即死処理の中で、
if(Bag_Item.itemState[deathBstNoEffectItemNum_].haveCnt > 0)
{
  Bag_Item.itemState[deathBstNoEffectItemNum_].haveCnt--;
  return;
}
というのをかく。

deathBstNoEffectItemNum_変数は、
readonlyのintで、即死アイテムの番号を入力している

-------------------------------------------------

<アイテム画面を閉じるボタンを用意する>------------

現在は何かアイテムを指定するまで閉じないので
戻るボタンを用意する

[ButtleMng.cs]
OnClickItemBackButton関数を作成し、
中でSceneMngのIsOpenItemMng(false);
を呼ぶ。

[ButtleUICanvasに追加オブジェクト]
ItemBackButtonを追加
画面の左上にでるようにして、
ButtleMngからOnClickItemBackButton関数をアタッチ
する。

アイテム画面を開くまでこの矢印は表示させたくないので、CharacterMng.csとButtleMngのボタン処理時にItemBackButtonの表示/非表示処理をする

？ボタンがうまく反応していない
→Y軸を-180してしまうとボタン側が裏にいってしまう
Z軸を-180してあげる必要がある

-------------------------------------------------

<片方が死亡した状態で戦闘がおわったらHP1の状態で
 生き返らせる>------------------------------------

MODEがSEARCHに切り替わったときに、
キャラのHPを見て、0になっていたら1にして
deathFlgをfalseにする

モーションの切替も必要
[Chara.cs]
ButtleInit関数を作成して、
set_.animator.Play("Standing@loop");
とかく。

[ButtleMng.cs]
戦闘終了直前に
ButtleInit関数の呼び出しと、
HPを1にしてflagをfalseにする処理をかく

-------------------------------------------------
　　　
<毒でHPが0になってもしなないバグ>-----------------

1までしか減らさないようにしたほうが他のバグに
対応しやすい。

現在HP < 毒ダメージのときは、
現在HP-1した値をダメージとする(これで絶対HPが1残る)
if(enemy.HP() < damage)
{
   damage = enemy.HP() - 1;
}

<死亡したらバステとバフを全て消すようにする>
ButtleInit関数に引数でboolをつけるようにして
falseならアニメーションを除いたバステとバフの
消滅をさせるようにする。

-------------------------------------------------

<バステやバフが戦闘終了しても消えてない>----------

[Chara.cs]
ButtleInit関数にバステを消すのとバフを消す処理を
追加する。

[CharacterMng.cs]
アイコンを消す処理も必要なので、
ButtleSetCallOnce関数にバステとバフアイコンの
削除処理を追加する。

-------------------------------------------------

<2回目の戦闘で敵選択マークがでない>---------------

EnemySelectObjの中に移したHPBarが1回の戦闘毎に
中身を消していなかったせいで、非表示状態になってた
→子を毎回消したら大丈夫になりそうだからためす

戦闘終了時に消すようにしたらよさそう
[ButtleMng.cs]
for (int i = 0; i < EneSelObj.childCount; ++i)
{
   Destroy(EneSelObj.GetChild(i).gameObject);
}
とする。

-------------------------------------------------

<ダメージ時に数字をだす>--------------------------

どら消しのゲームみたいにギザギザ吹き出しマークの中に、数字を入れる感じにしたい。

まずは画像探し
https://www.ac-illust.com/main/detail.php?id=22170555&word=%E6%BF%80%E3%81%97%E3%81%84%E5%90%B9%E3%81%8D%E5%87%BA%E3%81%97%EF%BC%88%E5%B7%A6%E5%81%B4%EF%BC%89&searchId=4192610598

これの吹き出し内の色を白に塗りつぶし、画像サイズを
小さめに変更してからDamageIcon.pngとして保存する。


連続hitする魔法があるのを考えると、最高で4回同じ敵に当たるから4個は吹き出しを先に生成しとくべき。

ButtleUICanvasに[DamageIcons(GameObject)]と
その子として、[Icon(Image)]*4個を準備する。
さらに各IconにTextをいれておく。
親の方は表示/子は非表示にしておく。

<キャラから敵へダメージ時>
[EnemyInstanceMng.cs]
CharacterMng.csと同様に処理を書く。
localpositionではなくpositionにenemyHPPos_を
代入するようにしておく。
buttleUICanvasをあらかじめ取得しておく必要があるので、public変数を増やして外部アタッチでCanvasを入れるようにする。

<敵からキャラへのダメージ時>
[CharacterMng.cs]
buttleDamageIconsObj_変数を用意して、Start関数で
ButtleUICanvasからFindして中身をいれる。

HPdecrease関数の中で、return処理を通り過ぎた後の
部分でまだ表示に使われていないアイコンをfor文で回して探し、表示する。
→反射/吸収処理よりも下にかく

ダメージ値はdamageというローカル変数からとれるので
表示するImageの子にあるTextに代入するように書く。

表示位置はダメージを受けるキャラの上らへんになるように、固定の座標位置を用意する
buttleDamgeIconPopUpPos_[0] =
 new Vector3(-260,   0, 0);
buttleDamgeIconPopUpPos_[1] =
 new Vector3(-260, 100, 0);

<ダメージアイコン用にScriptを用意する>
やることとしては、表示状態になったときに
①だんだん上に上がる
②だんだん透明になる(α値を変動させる)
③α値が0になったら非表示状態に戻す
この3点

新規Scriptとして、[DamageIconCtl.cs]を用意。
それをDamageIconsの子0~3にアタッチする。

[DamageIconCtl.cs]
OnEnable(表示時に通る処理)と
OnDisable(非表示時に通る処理)を用意する。

OnEnable関数の中で
Imageの取得とalpha値の初期設定(1.0f)
とコルーチンの設定をし、StartCoroutineを呼び出す

OnDisable関数の中で
StopCoroutineと変数類のnullとかの初期化を済ませる

コルーチンの中で
①②の内容をかき、while文を抜けた先で③を行う

これで終了！

-------------------------------------------------

<行動ターンをわかりやすくする>--------------------

今現在、敵のHPの残りとして表示している数値を
行動順の数字に置き換えることにする。

ユニとジャックの方にもそれぞれ順番の数字を枠内に
入れるようにする。

[HPSlider(プレハブ)]
CurrentNumとしていたオブジェクトを、
MoveSpeedという名前に変更する

ButtleUICanvasの中の各CharaDataにもMoveSpeed(TMP)
というのを用意する。

[HPMPBar.cs]
currentNumText_変数に関してnullチェックをしっかり
つけるようにする。

[ButtleMng.cs]
行動順を決定した際にそれぞれのキャラと敵に
行動順番の数字を渡すようにする。
SetMoveSpeedNum関数を呼び出すようにする。
→CharacterMngの方を呼んでfalseで帰ってきたときだけ
　EnemyのほうのSetMoveSpeedNum関数を呼び出すように
　する

[CharacterMng.cs]
SetMoveSpeedNum関数を作成する。
返り値はboolにしておいて、uniとjackの番号を
入れられた時はtrueを返す

[EnemyInstanceMng.cs]
SetMoveSpeedNum関数を作成する。
こっちは返り値voidでok
各敵のMoveSpeedに数字をいれる

<攻撃順の数字ですよとわかりやすくしたい>
なんかいい感じの画像ないかなぁ
イラストACで走るピクトグラムをダウンロードしてくる
キャラの方にはつけたけど、敵のほうには付けなくても
いいかなぁ・・・

暗いステージでは数字の色を白にしたほうがいいかもしれない
→EnemyInstanceMng.csのSetMoveSpeedNum関数の方で、
　Field3ではcolorを白にする

-------------------------------------------------

<魔法を使う前に説明を出す>------------------------

魔法コマンドを選択したときに、
画面左端に魔法の説明がでる枠を準備する。

ButtleUICanvasに[MagicInfoFrame]を用意。
(imageはframe_nameを利用する)
その子として[MagicInfoText(TMP)]をつけて、
行の幅や文字サイズを調整しておく。

[CharacterMng.cs]
魔法コマンド選択中しか表示されないように、
SetActiveの切替をおこなう。

文字列の内容をその魔法に合わせた説明にする。
Buttle関数内でキー処理に関係なく魔法コマンドを
開いているときに、nowとoldの選択中魔法番号が異なるときには文字列を更新するように準備をする。
(old保存用の変数は新規作成)

文字列の準備はCharaUseMaig.csでやることにし、
MagicInfoMake関数を用意して、それを呼び出す。
返り値を説明テキストにいれる。

[CharaUseMagic.cs]
MagicInfoMake関数について書いていく。
文字の分岐点について考える

回復->絶対キャラ
補助->Sub1で敵かキャラか決める
属性系->絶対敵

Elementで最初大まかに分ける。
そのあとヘッドワードで対象を指定する。
テイルワードで威力を書き込む。

ここからちょっと複雑。。。

<回復系>
味方(単体/全体/ランダム)に小威力の
(HP/各状態異常系)回復
→何を回復するかはsub2で決まる

<補助系>
味方(単体/全体/ランダム)に小威力の
(各状態up系)(上昇/反射/吸収)付与
→sub2とsub3で決まる

敵(単体/全体/ランダム)に小威力の
(各状態up系)(低下)付与
→sub2はswitchで、sub3は固定

<攻撃系>
敵(単体/全体/ランダム)に小威力の
(各魔法属性)攻撃
→Elementできまる
これに+でバステがつく。あと必中も。

-------------------------------------------------

<デバフ2つ目付与でエラーが出るバグ>---------------

sub1とsub2ではデバフの番号がちがう。
sub1:2,3,4,5がデバフだが、
sub2:5,6,7,8がデバフとなる。

[Enemy.cs]
2つ目を、
set_.condition[num.Item2 - 4].Item2 = true;
とするのが正しい。

※一応Chara.csの同様の部分も書き換えておく

<デバフアイコンが片方しかつかないバグ>
EnemyInstanceMng.csでバステの効果持続ターンを
設定するときに1つ設定できたらbreakで抜けるようになってた。
breakを削除したら2つ同時にバステアイコンがつけられるようになった。

-------------------------------------------------

<敵に攻撃したらエラーがでる>----------------------

原因はcurrentNum部分を攻撃順番にしたせい。
currentNum_変数をなくして、
引数でその都度現在HPを受け取るようにしたら
修正できた。

-------------------------------------------------

<敵への攻撃に必中効果を適用する>------------------

必中効果は攻撃系の魔法のsub3をみればいい。

[CharaUseMagic.cs]
攻撃系効果のなかに、
magicData.sub3が"4"であるときは
必中効果がその魔法につくので、
ButtleMng.csのSetAutoHit関数をtrueにする。

[ButtleMng.cs]
Set/GetAutoHit関数と、autoHitFlg_変数を用意しておく。

[EnemyInstanceMng.cs]
HPdecrease関数で、refFlgがtrueのときのif文条件に、
orでGetAutoHit関数を引っ張ってきてtrueなら
防御無視の必中効果とする
→必中はクリティカルなしになるのはしょうがない。
効果後にはSetAutoHit関数を呼んで、falseに戻しておく

-------------------------------------------------

<Field4にスリップダメージ処理を入れる>-------------

緑色の煙部分を通過するときに、ダメージをいれる。
一定時間でHP-2とか。
(ただしHPが1のときは受けないようにする)

まずはFieldMapないの各PoisonSmokeにCollisionを
つけていく。
BoxColliderをつけて、IsTriggerにチェックをいれる。
rigidBodyも必要になるんだっけ。いれとこう。
こっちはIsKinematicにチェックをいれておく
→動かないオブジェクトなので

[SlipDamageGas.cs]
新規でスクリプトを作成する。
OnTriggerStay関数を作成し、
中で接触中のコライダーのタグがPlayerであれば
ログがでるようにしておいた。
このScriptをPoisonSmokeにアタッチする。
→とりあえず毎フレーム呼ばれるようになった。

つぎにこれが一定間隔で呼ばれるようにする。
0.5秒おきぐらいがちょうどよさそうだったので、
nowtimeとchecktimeの変数をつくって、
stay中に値を加算して、checktimeの時間をこえたら
ダメージ。とする。

立ち止まっている間もダメージは酷いから、
キャラが移動中かどうか確認したほうがいい。
UniについているUnitychanControllerをfindして、
GetMoveFlag関数を呼び出すようにする。

あとは実際にダメージを与えるところ
SceneMngからcharasList変数を呼び出して、HPを現在値
から減らすようにした。
slipDamage変数もconstで用意しておいて、2未満のときに処理しないとか、減らす値の部分に利用するように
している。

これで完成かな。

-------------------------------------------------

<キャラがField4の壁をすりぬけるバグ>--------------
他のSceneからユニをもってきなおしたらなおった。
斜め移動処理もおかしかったから、おきなおしてみてよかった。

-------------------------------------------------

<セーブが街でしかできないようにする>---------------

街とユニハウス以外ではボタン部分が
暗くなるようにして、押しても反応がないようにする。

[MenuActive.cs]
MoveMenuButtons関数の中で、
まず現在のシーンがtownもしくはunihouseであるか
確認する。

新規でButtonStateColorChange関数を用意し、
そこでセーブボタンの色変えができるようにしておく。

現在がtownかunihouseならtrue,違うときはfalseを
ButtonStateColorChange関数の引数へ渡す。
渡した先で色変えとinteractableの切替をする
(interactableはボタンの反応の有無を決められる)

-------------------------------------------------

<納品アイテム画像の差し替え>----------------------

まず最初に、大成功アイテム用のマークを納品処理の
片方に追加する(右側に表示するほうへ)

TownのGuildにあるDeliveryPanelにある
ItemBox(1)の子にSpecialIconを追加する。
画像は[ExSymbol.png]をいれる。
あとはこれの座標を-45,45,0として左上に配置したらok

そもそものアイテム画像はまだ差し替えられないから
そっとしておこう。。

-------------------------------------------------

<報酬の受け取り処理を作る>------------------------

QuestInfo.xlsにあるreward部分に、実際の報酬処理用
の項目を付け足す。
→今あるrewardはテキスト表示用

お金
素材
アイテム
が入手できるように、
Money
Materia
Item
の3項目を追加する。

TerasurwareにあるQuestInfo系のScriptに項目を
追加する。

[QuestMng.cs]
ClickReportButton関数内で報酬処理をつくる。
①お金
SceneMng.SetHaveMoney(SceneMng.GetHaveMoney() + popQuestInfo_.param[questNum_].money);

②素材とアイテム
①と同じく増加させるものを調べる
(素材、アイテム番号)_(個数)としているから
_で区切ってMateriaGetCheck関数とItemGetCheck関数を
呼び出すようにする。


<大成功の納品報酬について>
いくつ大成功を納品したかで報酬を良くする。
→rewardの文字には、下の段とかに
　(追加報酬)・○○*3とか書こうかな

納品数全体の何％が大成功の品物かで判断する。
0%           -- 報酬0倍
1%  ～ 49%   -- 報酬1.2倍
50% ～ 79%   -- 報酬1.5倍
80% ～ 100%  -- 報酬1.8倍
みたいな感じにしよう

あとはrewardGradeUp_変数をfloatで作成して、
報酬受け取り処理時に+してあげればいいだけ。

いやまってよ、、今のままだと納品クエスト以外の
報酬もグレードアップしちゃう
また、他の納品クエストの納品結果で上書きされちゃう
→各クエスト毎にグレードアップ値を保存しないとだめ

private Dictionary<int, float> rewardGradeUp_ = new Dictionary<int, float>();   
キー:クエスト番号
値:納品する大成功アイテム数に応じて数値が変化する

というのを作成して、各クエスト毎に反映するようにした。

rewardGradeUp_変数をAddするタイミングをつくる。
クエストを受注したときにその番号に該当する箱部分が
なければAddするようにしたい。

<報酬受け取り時の報酬上乗せ分の文字を表示される
 ようにする>
CliclReportButton関数に処理を追加する。

※追加報酬の文字が枠内におさまらなかったため
　枠を大きくした。
　→Guild-QuestCanvas-QuestMng-PopUp-BackImage
    これのScaleを、1,2.5,1にした。

-------------------------------------------------

<納品数が違う状態で納品ボタンが押せるバグ>---------

[QuestMng.cs]
DeliveryCoroutine関数で、
合計の納品予定数と必要数を比べるときに
int.Parse(slider.maxValue.ToString()) == tmpNum
としていたのを、

int.Parse(str) == tmpNum
とするようにした。
maxValueで比べてしまうとそのアイテムを全部納品するときにボタンが押せるようになってしまうから。

-------------------------------------------------

<受注中のクエストデータが消えてしまうのを修正>----

現在はotherData.csvに保存するとき、
クエスト部分は達成か未達成かで回数しか保存していなかった。これに受注中の場合の目印が必要。

[SaveLoadCSV.cs]
<セーブの時>
受注中で、クリアしてない状態のもの
→回数の末尾に"_"をつけるようにする。

受注中で、クリアしたが報告していないもの
→回数の末尾に"_c"をつけるようにする。

<ロードの時>
末尾に_か_cがあるか見て、
クエストの状態を変化させられるようにする。

→SceneMngのゲームオブジェクトに、
　プレハブのCompleteQuestPrefabを付ける必要がでた

グレードアップ値も保存してあげないといけない。
→rewordGradeUp_変数が何も入ってないからエラーでる
つづきはここからする。

[QuestMng.cs]
onceFlg_変数を用意して、初回のみquestClearCntをAdd
しているところに使うようにする。
→このとき、ContainsKeyのチェックが必要

-------------------------------------------------

<Field4のストーリーを作成する>--------------------

[まずは入ってすぐの会話]
Chapter19を作成する
→ジャックの表情差分がうまく機能するか確かめる

洞窟の背景画像が必要
https://www.ac-illust.com/main/detail.php?id=1316535&word=%E6%B4%9E%E7%AA%9F%E3%81%9D%E3%81%AE%EF%BC%91&searchId=363502066

画像サイズを少し小さめにしてCave.pngとして
StreamingAssetフォルダにいれる。

Terasurware-Chapter_importer.csに"19"を追加して
reimportする

FieldMng.csに
現在のチャプターが19かつField4に来たときに
再生するように書く。

[ボスを倒してからのギルド会話]
Guild.csに
現在の進行度が20でクエスト6番を達成したら
Chapter20の会話が発生するようにする。

ボスの討伐処理として、
KnockDownEnemy.csにBossGolemとPoisonSlime
の処理を追加する。
→これをゲームオブジェクトにアタッチしておく。

Terasurware-Chapter_importer.csに"20"を追加して
reimportする

-------------------------------------------------

<Field5へのクエストを受注するさいのストーリー>----

Chapter21で用意する。
その前に、先にクエストをつくっておく。

Guild.csに
現在の進行度が21で、クエスト7番を受注した
ときの処理を追加する。

Terasurware-Chapter_importer.csに"21"を追加して
reimportする

-------------------------------------------------

<敵の攻撃で、遠距離なら魔法攻撃,近接なら物理攻撃
という風にわける>---------------------------------

[ButtleMng.cs]
isAttackMagicFlg_変数を作成し、
Get/Set関数を作成する。

[EnemyInstanceMng.cs]
遠距離攻撃型の敵が使う魔法の弾生成をしている箇所が
あるから、そこで魔法攻撃だと判別できる。

BeforeAttack関数の最初で初期設定としてbuttleMng_.SetIsAttackMagicFlg(false);
を書くようにし、
魔法攻撃だとわかったらtrueにする。

[CharacterMng.cs]
HPdecrease関数の反射/吸収処理をしているところで
GetIsAttackMagicFlg関数を呼び出して
物理攻撃に対して物理反射/吸収、
魔法攻撃に対して魔法反射/吸収
と対応しているときのみ処理が行われるようにする。

-------------------------------------------------

<攻撃時にミス、クリティカル、弱点属性のweakを用意>-

<ミスのとき>
中に数字が入れられる枠の中に、『ミス』ってかく

[CharacterMng.cs]
HPdecrease関数の中でダメージアイコンの処理をしている箇所を別関数に分けて、回避のときには文字で
「ミス」と表示するようにした。

[EnemyInstanceMng.cs]
同上。

<Weakのとき>
数字のすぐ上に出したほうがいい
→クリティカルより表示する回数が多いから
　変に隙間がないほうがよさそう

表示方法としてはスーって消えていくのと同じでいい

ButtleUICanvasのDamageIconsに追加する
→プレハブの更新が必要になる。

DamgeIcons-Icon0,1,2,3-Textの子にWeak(Text)を
アタッチする。
同様にそこにCriticalもアタッチする。

Textの表示タイミングにそれがweakなのかCriticalなのか、両方なのかを判断してSetActiveを切り替える用にする。

-------------------------------------------------

ダメージ時に出血のエフェクトがでるんだけど、
これを参考に自前でエフェクト作ってアタッチさせたほうがよさそうだとおもった。


※Field0以外にもやらないといけない処理
　・ButtleMngにBadStatusMng.csをアタッチする


<序盤>
HPポーション(小)
毒消し
攻撃アイテム(小全体)
カエレール
ニゲレール
物理/魔法攻撃力アップ(単体)
防御力アップ(単体)
速度アップ(単体)
<中盤>
HPポーション(中)
MPポーション(小)
暗闇消し
麻痺消し
攻撃アイテム(中全体)
エンカウント率(低下)
蘇生(HP小状態で)
<終盤>
HPポーション(大)
MPポーション(中)
即死身代わり
蘇生(HP全快)


作品エントリー 1/24
授業は 1/27まで


・毒　　2
・暗闇  3
・麻痺  4
・即死  5

※ジャックの会話中ポーズを修正した。でも棒立ちで
　かわいそう
※基本的にアイテムや素材の報酬は5を基本とする