Uniちゃんの家に関するScene

<家の周りを作成する>----------------------------
新規でテラインを作成し、Assets-Town-Terrainの
フォルダに[UniHouseData]として保存する。

地面に模様と色を付ける際は
Terrainの[AddLayer]でAssets-Town-Terrainにある
NewLayerを使用する
※CreateLayerは基本しなくてよさそう

<家の配置>
BakerHouseから持ってきてUnPackし、
[UniHouse]と名前を付ける
Pos    X:17.5 Y:0 Z:25
Rotate X:-90  Y:0 Z:0

家のテクスチャのMaxSize[128]

<MainCameraの位置>
Pos    X:6  Y:20 Z:7.5
Rotate X:55 Y:65 Z:0

SceneMngを配置し、
UniとDemoを引数にアタッチする・
※Uniはサイズを2倍にする

WarpOutとLocationSelCanvasを設置

また、新規の空のオブジェクトで
[UniHouseMng]を作成し、[UniHouseMng.cs]を
作ってアタッチする。

UniHouseMng.csには
void Start()
{
    // 現在のシーンをTOWNとする
    SceneMng.SetNowScene(SceneMng.SCENE.UNIHOUSE);
}

をいれる。

------------------------------------------------

<ユニちゃんが自分の家と当たり判定したとき、
 ユニちゃん家の室内にカメラを切り替える>---------

SubCameraとCameraControllerを作成する
CameraControllerにMainとSubをアタッチしておく。

[SubCamera]
Pos X:100 Y:0 Z:0
※AudioLisenerはRemoveしておく

<当たり判定ボックスの作成>
UniHouseにBoxColliderを付ける
Center X:2.3 Y:0  Z:4.5
Size   X:10  Y:10 Z:10
IsTriggerのチェック なし

家に新規ScriptでInHouseCheck.csを作成して
アタッチする。
※このスクリプトは他の家にも付けれる汎用性の
　あるものにする

<InHouseCheck.cs>
コライダーでの当たり判定を行う。
※UniのTagが[Player]になっているか確認しておく

void OnCollisionEnter(Collision collision)
{
    if(collision.transform.tag == "Player")
    {
　　　cameraMng_.SetChangeCamera(true);
      Debug.Log("当たった!");
    }
}

Collisionでの当たり判定では、CompareTagでの
タグ確認ができなかったので、仕方なく == で
判定を取っている。
※CameraMngの取得方法はFieldMng.csと同じ

------------------------------------------------

<室内オブジェクトのSetActive切替テスト>----------
次に、InHouseCheck.cs自身がどの家に
アタッチされているかを取得できるようにする。
→室内オブジェクトのSetActiveの切替に使えるように

※SetActive側は、オブジェクトの親名をそれぞれの
　家と同じ名前にしないといけない

<テスト用のオブジェクトをサブカメラ前に配置>
空のオブジェクトで[HouseInterior]を作成
Pos X:100 Y:0 Z:0
※サブカメラと座標を同位置にする

その子として空のオブジェクトで[UniHouse]と
[Guild]を作成
それぞれの子として、さらに適当にオブジェクト設置

[HouseInterior]に、新規Scriptで
[HouseInteriorMng.cs]を作成してアタッチする。

<HouseInteriorMng.cs>
SetHouseVisible関数で、
自分の子の名前と、関数の引数名と一致しているものはActiveをtrueに、それ以外はfalseになるようにする
→for文で子オブジェクトの名前を取得していき、
　一致しない家はSetActiveをfalseにする

あとはこの関数をInHouseCheck側から呼び出す。

<InHouseCheck.cs>
HouseInteriorMng.csをprivate変数で取得する。

Start関数でFindした後OnCollisionEnterで、
interiorMng_.SetHouseVisible(this.gameObject.name);
と記述する。

これでテストした結果、うまくSetActiveが動いているのを確認できた。
これをUniちゃんの家以外は、Townシーンで行う
必要がある。

<Townシーンでの変更点>
①Restaurantの子のBoxColliderという名前の
　オブジェクトを[Restaurant]に変更する
　→名前変更した場所に[InHouseCheck.cs]をつける

②BookStoreの子のBoxColliderという名前の
　オブジェクトを[BookStore]に変更する
　→名前変更した場所に[InHouseCheck.cs]をつける

③Guildの子にCubeを作成して[Guild]と名前をつける
　→つけたCubeに[InHouseCheck.cs]をつける
Pos X:-1.4 Y:-1.0 Z:-0.35

④ItemStoreの子にCubeを作成して[ItemStore]と
  名前をつける
　→つけたCubeに[InHouseCheck.cs]をつける
Pos    X:1.5 Y:0  Z:3
Scale: X:4   Y:4  Z:4

⑤SomeColliderにある[MayorHouseCollider]という
　名前のオブジェクトを[MayorHouse]に変更する
　→名前変更した場所に[InHouseCheck.cs]をつける

⑥SomeColliderのCollider6のScale:Zを20→25にする

※SetActive側は、オブジェクトの親名をそれぞれの
　家と同じ名前にしないといけない
------------------------------------------------

<Uniの家の内装を作成する>-----------------------
DarkFantasyKiy[Free]から部屋の全てをInHouseの
シーンにもってきて、サブカメラの前に配置する

[HouseInterior]の子の[UniHouse]の子として
ヒエラルキーに置く。

[UniHouse]
Pos  X:0 Y:-1.5 Z:5
Rota X:0 Y:-90  Z:0

<壁と天井のマテリアルを変更する>
新規で[UniHouseRoof]というマテリアルを作成

[UniHouseRoof.mat]
Shader     → Standard
色         → R:0.36 G:0.15 B:0.1
Metalic    → 0.4
Smoothness → 0
NormalMap  → Assets/Furniture/RunemarkStudio/
              DarkFantasyKit[Free]/Meshes/
              Steps,Floor,Celling/Materials/
              Dfk_ceiling_wood_normal

※このマテリアルを[CEILING]と[WALLS]につける

<床のマテリアルを変更する>
新規で[UniHouseFloor]というマテリアルを作成

[UniHouseFloor.mat]
Shader     → Standard
Albedo→Assets/Furniture/PollyPrivateers/
        SeamlessMaterials/Roof/Roof_Albedo.tga

Metalic    → 0.3
Smoothness → 0.5

Normal→Assets/Furniture/PollyPrivateers/
  Map   SeamlessMaterials/Roof/Roof_Normal.tga
   
<机の上に本を設置する>
Assets/Furniture/Books/Prefabsにある
Bookを3冊配置する。

上の方の棚にはAssts/Furniture/QA_Books/Prefabsに
あるBooks_15を設置する

<棚を設置する>
Assets/Furniture/InteriorAsset/Prefabにある
Sehlfを配置する。
※Prefabは後で削除する
棚の中身は頑張る

棚の上に、地球儀でも置いとくか
※地球儀の色はすこし変更している

<植物を吊るす>
なんか、おしゃれな家って植物吊るしてるよね
がんばってつくってみた

<窓をつける>
そういえば窓がない…
PollyPrivattersにある窓をはめ込んでみる
テクスチャは棚と同じやつにする

<その他>
右の壁がさみしいからInteriorAssetの絵画を配置
PollyPrivattersにある大き目の観葉植物を右側に置く
何か天井もさみしいからボックスで囲んでみる
[UniHouseCeiling]という新規マテリアルを追加
→UniHouseFloorの色を変えただけのやつ
　色 → R:0.36 G:0.15 B:0.1

<SubCameraの画角変更>
Pos  X:100  Y:0.3 Z:0
Rota X:13.5 Y:0   Z:0
※これにより、InHouseCheck.csでのSetSubCameraPos
　が変更になる。
　また、カメラのRotateの調整も必要になる。

------------------------------------------------

<家と接触時に、家に入るかを確認するテロップ表示>-

[HouseInterior]のオブジェクトの子としてCanvasを
作成する。
そのCanvasにImageとText(TMP)を3つつける。
①[HouseInfo]
  Image　　 → frame_name.png
  Text内容　→ ○○の家に入りますか？という文章
②Yes
  Image　　 → none
  Text内容　→ 選択肢の「はい」
③No
  Image　　 → none
  Text内容　→ 選択肢の「いいえ」

次に、このCanvasが家と接触したときにActiveに
なるようにする。

<HouseInteriorMng.cs>
privateでGameObject変数を作り、
Findで"Canvas"を探す。

InHouseCheck.cs側でそのFindしたオブジェクトの
アクティブ状態を切り替えるようにする。
→[SetActiveCanvas]という関数を呼び出す

これで接触時にキャンバスが表示されるようになった

------------------------------------------------

<コルーチンを使って選択肢のキー操作を実装>-------

(仕様)
「はい」「いいえ」の選択をできるようにする
操作は矢印キーの左右、決定はスペースキーにする。

(実装方法)
<HouseInteriorMng.cs>
①SetActiveCanvas関数でコルーチンをスタートする
　→SelectInHouseというコルーチン関数を呼び出す

②SelectInHouse関数ではwhile文を回す
　flagがtrueである間は1フレーム毎に処理が
　呼ばれる仕組みにする
　スペースキー押下でflagをfalseにするとwhileを
　抜けられる(ストップ処理がいらなくなる)
※参考サイト
https://qiita.com/kwst/items/ce04abce7c1e2c72e023

これでキー押下での操作ができるようになった。
次はこのキー押下時の処理を書いていく。

private変数でboolのinHouseFlg_というのを作成し、
キー操作でtrue/falseが変わるようにする。

・trueでスペースキー→cameraMng_からサブカメラの
　切替処理を呼びだす

・falseでスペースキー→SetActiveCanvas関数を
　呼び出して、flagの引数をfalseにする
　※これでキャンバスを非表示に切り替える

このキー処理を作成するにあたって、いままで
InHouseCheck.csでcameraMng_処理をしていたものを
HouseInteriorMng.csに移植することになった。
(むしろこのほうが処理がきれいに書けた)

※SetActiveCanvasをfalseにするとき
　引数でnameがあるが、そこは[""]にし、
　関数内で[""]だったときはコルーチンスタート処理
　をしないように、キャンバスだけ非表示にして
　returnするようにした

------------------------------------------------

<建物接触時のキャンバス表示中はキャラ移動停止>---

UniのUnitychanControllerのenableをfalseにする。

HouseInteriorMng.csでfindでUnitychanControllerを
取得し、必要なところでenabledをfalseにする。

また、enabledをした際にアニメーションを止める
必要があるため、UnitychanController側にStopUniRunAnimという関数をつくり、
外部からアニメーションを止められるようにしておく

→これでWarpField.csからもアニメーションが止められるようになったから、一部書き換えました。

playerController_.StopUniRunAnim();
というのを適切な箇所で呼び出せば終了。

-----------------------------------------------

<[○○(の家)に入りますか]という文章を表示する>---

建物との当たり判定時に、建物の名前をテロップとして出すようにする。
→表示先は、HouseInfoのText(TMP)

文字表示を作るのはHouseInteriorMng.csの
SelectInHouse関数内

まず、private変数でTMPro.TextMeshProUGUI text_を
用意し、Start関数内でFindしておく
→ヒエラルキーのText(TMP)はTextという名前に変更
　しておくこと

そして、SelectInHouse関数のwhile文前で
text_.text = "ユニの家に入る？";
というテスト文章を入れて実行する
→文字サイズを[20]にしてちょうど良さそうだった。
→文字表示位置は中央にすること

あとは、この"ユニの家"とかを建物毎に変わるようにしておき、それに +"に入る？"をくっつける。

<建物毎に表示名を変える>
mapで[キー:英語建物名,値:日本語建物名]を
Start関数で作るようにする。

readonly変数で英語建物と日本語建物の
string配列を用意する
※建物名の順番をそろえておく

そして、mapをつかってキーと値にした後、
SelectInHouse関数内で
text_.text = buildNameMap_[name] + "に入る？";
と呼び出せば名前を建物毎に変更できる

(問題発生)
町長、魔道具屋、という言葉がフォントにない
→新規フォントで対応する

https://mplusfonts.github.io/
上記のサイトのGithubからMplus1-Medium.ttfを
使うようにした。
→このフォントは現在案内表記で使用予定
※フォントの追加の仕方や設定方法は
　canversationdata.txtで確認しながら行う。

------------------------------------------------

<[はい][いいえ]がわかるように矢印アイコンを表示>-
現在自分がどちらの選択肢を選んでいるかわかるように矢印アイコンを描画するようにする。

矢印アイコンには、nextMessage_iconを使用する。
HouseInterior内のCanvasの子に[Icon(Image)]を追加

[Icon(Image)]
Pos
はい   X:-140 Y:-70 Z:0
いいえ X:  40 Y:-70 Z:0

Scale　X:0.2  Y:0.2 Z:0

この矢印アイコンがHouseInteriorMng.csの
SelectInHouse関数にある左右キー操作で
左右に動くようにしたい

<矢印アイコンを左右に動かす>
private変数でGameObject iconImage_を作成し、
Start関数でfindする。

SelectInHouseのwhile文で、キー処理をするときに
「はい」                iconImage_.transform.localPosition =
new Vector3(-140.0f, -70.0f, 0.0f);

「いいえ」
iconImage_.transform.localPosition =
new Vector3(40.0f, -70.0f, 0.0f);

という座標移動処理を追加する。
→このとき、localPositionを利用したほうが
　座標指定がしやすい。
※普通のPositionだとCanvas経由で計算するため
　複雑になり、考えづらい。

これで、選択中の方にアイコンが動くようになり
わかりやすくなった。

------------------------------------------------

<選択肢中は、ワープ処理を不可能にする>-----------

①WarpCanvasを非表示にする
HouseInteriorMng.csに、publicでwarpCanvasを
取得するようにして、適切なタイミングSetActiveの
true/falseを切り替える

②「いいえ」を選択したときにワープが同じスペース　キーで反応してしまうのを止める
HouseInteriorMng.csに、publicでwarpTownを取得し
て、適切なタイミングでenableのtrue/falseを
切り替える

これでワープ処理が同キーで発生してしまうバグを
修正できた。

------------------------------------------------

<室内で出る選択肢のキャンバスを表示する>---------

大元のキャンバスは共通にしておき、
その中に空のオブジェクトを建物と同じ名前にする。
その空のオブジェクトを、SetActiveで切り替える仕組みにする。

HouseInteriorの子として[InHouseCanvas]を作成
その子として、空のオブジェクトで
[BookStore][MayorHouse]等々、建物名と同じものを
用意する。

HouseInteriorMng.csにprivate変数でGameObjectのinHouseCanvas_を準備し、Start関数内でfindする。

コルーチン処理の最後のif文
(SetHouseVisible(name))というやつの中で、
inHouseCanvas_をSetActive(true)にした後に
該当しない子オブジェクトを名前で判定してfalseへ。

※親を表示にしてから、該当しない子を非表示にする
　という流れにしないと、子だけ表示はできないので
　注意が必要

------------------------------------------------

<建物からの出口処理>----------------------------

処理内容はどの建物も共通の為、HouseInteriorMng.csに記述する。

ボタン位置などは調整がしやすいように、各オブジェクト毎に出口ボタンを用意したほうがいい。

①各、空のオブジェクトに[ExitButton(Button)]を
  作成し、座標はテストとしてX:0 Y:-100 Z:0にする

②HouseInteriorMng.csに新規関数で[ExitButton]を
　作る。

③②の処理内容として、とりあえずログを出すように
　しておき、①のOnClick()にHouseInteriorを
　アタッチして、ExitButton関数を呼ぶ。

→ログが正常にでたことを確認

(ExitButton関数の処理内容)
①退出時には、ワープキャンバスを表示にする。
②室内用キャンバスを非表示にする。
③キャラ操作を可能にする。
④建物毎にカメラの調整をする。
→今いる建物を把握するために、nowInHouseNameと
　いう変数を用意し、SetHouseVisible(name)の
　if文内でnameから=で貰うようにした。

これで、退出ボタン処理ができた。
※TownSceneでも同様に設定する。

------------------------------------------------

<進行度7の時に、家で「休む」ができるようにする>--

逆に、[7]まではこのボタンが押せないようにする。

まずは、TownのGuildから[QuestCanvas]と[QuestMng]
をコピペして[UniHouse]の子にする。
→このとき、InHouseCanvasの子にあったExitButtonを
　削除しておく。

[QuestCanvas]→[UniHouseCanvas]に名称変更。
[QuestMng]は、ぶっちゃけ建物1つしかないこのシーン
ならいらないから、子の[QuestUI]を[UniHouseUI]に
して[QuestMng]から取り出す。

※現時点で[UniHouseUI]に入れるものがないから放置
　→表示/非表示の切替は[UniHouseMng.cs]でする
　　外部アタッチ方式で管理する予定

<「休む」ボタンの作成>
UniHouseCanvasの子に、[SleepButton(Button)]を
作成する。(Textを休むにしておく)

<UniHouseMng.cs>
ClickSleepButton関数を作成して、
SleepButtonのOnClick関数にアタッチする。

押された時に、現在の進行度を確認して、7未満
だったら押されても何も起こらないようにreturnさせる。
→ボタンは、押せないように暗くなるようにしたい

これで、進行度7を境にしてボタンを反応させるか
どうかを分けれるようにした。
次はボタンを押した時の処理について考える。

------------------------------------------------

<日付が変わるのがわかる表現をする>---------------
画面左上に朝、昼、夕、夜という4つを用意しておき
切り替わるようにする。

使用素材↓
https://www.ac-illust.com/main/detail.php?id=22078260&word=%E6%AD%AF%E8%BB%8A&searchId=895069833

どの画面の上にも出すからstaticなオブジェクトに
したほうがよさそう。
→新規Scriptを用意して、消えないオブジェクトにし　よう(SceneMngを参考に、消えないキャンバス作る)

<キャンバスを用意する>
[TimeCanvas(Canvas)]を新規作成し、
その子として[Image(Image)]を作成する。
→[Image]に[TimeGrar.png]を入れる。

[Image]
アンカーポイント：左上
Pos X:10 Y:-10 Z:0
Width:329 Height:329
Scale X:1 Y:1 Z:1
※Rotationは、Z軸をマイナスしていけばいい 

<SceneMng.cs>
enumでTIMEGEARを作成する。
朝・昼・夕・夜

Get/SetTimeGear関数を作成して、変数のtimeGear_
設定したり取得したりできるようにしておく。

新規Scriptで、[TimeGear.cs]を作成。
TimeGear.pngを入れてるImageにアタッチする。

<TimeGear.cs>
Singletonにしないと、ヒエラルキーにキャンバスを
置いてるだけで複数できてしまうから
SceneMng.csのSingletonをマネして処理を入れる。

Awake関数内で、自分の親(Canvas)
がシーンを跨いでも消えないように処理を追加する。
→親を登録すれば、子のImageも消えないオブジェクト
　と判定されるみたい

rotateTimeGearMap_関数を作成して、
キーがenumのTIMEGEARで、値がZ軸の目標回転値に
なるように設定する。
あとはImageRotate.csを参考にして回転処理を作成する。

------------------------------------------------

<挨拶クエスト関連で時間が経過するようにする>-----

①ギルドを初回訪れたタイミング→昼へ
②クエストクリア時→夕方へ

①について、
Guild.csのCheckEvent関数でチャプター2の会話に
飛ばすまえに、
SceneMng.SetTimeGear(SceneMng.TIMEGEAR.NOON);

②について、
同じくGuild.csのGuildQuestEvent関数の方で
チャプター6の会話に飛ばす前に、
SceneMng.SetTimeGear(SceneMng.TIMEGEAR.EVENING);

------------------------------------------------

<家で[休む]を押したときに、時間経過で朝にする>---
<UniHouseMng.cs>
ClickSleepButton関数のreturnを通過したとき、
SceneMng.SetTimeGear(SceneMng.TIMEGEAR.MOLNING);
になるようにする。

------------------------------------------------

<時間経過時には、背景を暗くする>-----------------
TimeCanvasに[Panel(Panel)]を用意する
(黒背景でα値が0.5)

TimeGear.csでFindで取得するようにして、
Awake関数内で最初に非表示にする。
その後、
回転するときには表示に、それ以外は非表示にする。

------------------------------------------------

<DirectonalLightの数値変更>---------------------

InHouseAndUniHouseのDirectionalLightのRealtimeShadowsにあるStrengthを[0.2]にする

------------------------------------------------

※現時点で[UniHouseUI]に入れるものがないから放置
　ミニゲームとか図鑑系はここにいれるだろう
　→表示/非表示の切替は[UniHouseMng.cs]でする
　　外部アタッチ方式で管理する予定


Updateとコルーチンの違い↓
https://zenn.dev/torisoup/articles/coroutine_01

基本的なコルーチンの使い方↓
https://qiita.com/kwst/items/ce04abce7c1e2c72e023

<Directional Lightの設定を変更>
Intensity    → 1.2
影のStrength → 0.6

最後にPrefab類やSceneは全て削除すること
テクスチャのサイズ調整も行うこと

