新規に作成した、街をつくるテストのScene

ここに、さきちゃんから受け取った街のアセットを利用して作成していく。

<透過した画像をオブジェクトに貼りつける方法>-----

参照したもの↓
https://am1tanaka.hatenablog.com/entry/20120131/1328015837

①いつも通り、Pictureの画像のTextureTypeを
Sprite(2DandUI)にする

②Pictureフォルダ内にMaterialsフォルダを用意して
そこに新規でマテリアルを作成
(UnityLogoと命名)

③MaterialのShaderを
[Legacy Shaders/Transparent/Diffuse]にする

④Selectと書かれているところに、今回適用したい
　画像をアタッチする

⑤UnityLogoマテリアルを3DObjectのQuadとかに
　貼り付けたら完成

------------------------------------------------

<Terrainで地面づくり>---------------------------
参照したもの↓
①基本操作
https://qiita.com/yando/items/ef76c200bb50005170d5

②テクスチャの貼り方が変わったらしいので。
https://teratail.com/questions/173073

③草の生える量の調整について。
https://unity.moon-bear.com/3d%E3%82%A2%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8C%E3%83%A6%E3%83%8B%E3%83%86%E3%82%A3%E3%81%A1%E3%82%83%E3%82%93%E3%83%91%E3%83%AB%E3%82%AF%E3%83%BC%E3%83%AB%E3%80%8D/terrain%E3%81%A7%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8%E3%82%92%E4%BD%9C%E3%82%8B/#toc7

------------------------------------------------

<定点カメラ方式の実装>--------------------------

十字路の道で、左右の道に入ったとき、定点カメラに切り替わるようにする。
もともとCameraMng.csで切替の仕組みを用意しているため、ここを街のカメラも使えるように修正する。
UnitychanController.csの内容も追加するものが増える。

左右の定点カメラは、Unityちゃんの座標によって移動させれば、1台だけですむはず。


※往復してカメラが連続で切り替わるときにも
　不可視の当たり判定用のボックスを設置しといて、
　Exit関数通過時にそのボックスより左右どちらに
　いるかを判定してカメラの切替がありなりを決める

-----------------------------------------------

<街の定点カメラ準備>----------------------------
CameraMng.csでFindでカメラを探すようにしている所を、アタッチ方式に変更しなおす。
→どのSceneでも使えるようにするため。

CameraMng.csの、
buttleCameraという変数名をSubCameraに名前変更する

ヒエラルキーに新規カメラを追加して、
FixedPointCameraと命名する。
ヒエラルキーに空のオブジェクトを作成して、
CameraControllerと命名し、CameraMng.csをアタッチ
MainCamera→MainCamera
SubCamera →FixedPointCamera

また、FieldMng.csのnowModeの初期値をNONにし、
UtnichanController.csでのUpdate関数のreturn処理条件に、　&& nowMode != NONを追加した。

nowModeがNONということは、「街にいる」という
考え方にする！

[FixedPointCamera]
Position X:24 Y:3 Z:89

------------------------------------------------

<通過テストを始める>----------------------------

とりあえず、右通路のテストからしよう。
新規でキャラ通過確認用のCubeを追加する。
名前は、[GoThroughRight] 
Position X:19 Y:0.5 Z:95
Scale    X:2  Y:2   Z:10
BoxColliderのIsTriggerにチェックを付けておく
RigidBodyもつけて、IsKinematicにチェックする。

[GoThroughRight]につける新規Scriptを作成する。
名前は、[GoThroughCheck.cs]
このスクリプトで、キャラが通過したかを確認して、CameraMng.csにカメラ切り替えの指示を出す。

[GoThroughCheck.cs]で、
void OnTriggerEnter(Collider col)
{
    if(col.CompareTag("Player"))
    {
        Debug.Log("カメラ切替");
        cameraMng_.SetChangeFlg(true);
    }
}
という判定を行い、現在ログを出力しているところに
CameraMng.csで新規に用意したSetChangeFlg関数を
呼び出す。

これで右へ通過したときにカメラが切り替わるようになった。
-----------------------------------------------

<キャラがカメラに映らない位置に来たりする>-------

家のMeshCollider1つ1つは外して、大きいBoxColliderとかを別で用意したほうがよさそう。
カメラ替えたときに映らないところへは当たり判定で
移動できないようにしておいたほうがいい。
ヒエラルキーに追加した[House12-13Collider]という
のを参考に設定していくこと！

また、キャラのZ座標が、94以下の時には
95に設定するように[GoThroughCheck.cs]の
OnTriggerEnterに処理を追加した。

------------------------------------------------

<右の通路カメラから元のカメラに戻れるようにする>-
GoThroughCheck.csにて。

EnterとExitを使うことで、通り抜けしたときと
通り抜けずに引き返したときのカメラの処理を正しくできる。

EnterとExitでそれぞれキャラの座標を変数に入れて置き、Exitの方でExitPos - EnterPosのnormalizedの
X座標をみて、
1.0なら右への通過
-1.0なら左への通過と考えるようにした。

ただし、まだ左の住宅街の処理をつくっていないため
場合によってはまた修正をするかもしれない。

------------------------------------------------

<左の通過テストをする>--------------------------

右と同様に、[GoThroughLeft]という通過確認用の
Cubeを作成する。
Rightの方をコピーして、X座標をマイナス値にするだけでいい。
作ったCubeにGoThroughCheck.csとRigidbodyがあるのを確認しておくこと。

GoThroughCheck.csでOnTriggerExit関数に
オブジェクトの名前でカメラ位置や、SetChangeFlgの切替を分けるように処理を書いたら終了。

------------------------------------------------

<すり抜けてほしくない箇所に壁を設置していく>-----

当たり判定の精度を高めて、すり抜け防止のために
UniのRigidbodyにある[CollisionDetection]を
Continuousに変更した。

詳細は下のサイトで↓
https://ekulabo.com/rigidbody-collision-detection#outline__3

------------------------------------------------

<噴水の水について>------------------------------

噴水のアセット+StandardAssetsという中にある水のやつが必要らしい。
バージョンによってはStandardAssetsのインポート後にエラーがでるとのことなので、対処法を記載しているサイトを載せておく↓
https://nekojara.city/unity2020-standard-assets

噴水以外に水を設置するときに参考にできるサイト↓
https://xr-hub.com/archives/3452

とくにエラーはでなかった…

------------------------------------------------

<キャラが建物を貫通する>------------------------

2人で調べたところ、建物の判定で斜めの面とキャラが
当たり判定したときに貫通するようになっていると
わかった。そのため、判定位置を大きくしたり
ずらすことによって、多角面と判定が起こらないように調整して修正した。

-----------------------------------------------

<キャラの移動速度について>----------------------

斜め移動時に、速度が速くなりすぎておかしくなっていたため、UnitychanController.csに修正をいれた。

参照したもの↓
https://unity-senpai.hatenablog.com/entry/2020/10/13/010845#%E4%B8%89%E5%B9%B3%E6%96%B9%E3%81%AE%E5%AE%9A%E7%90%86%E3%81%AE%E5%BE%A9%E7%BF%92

上記のサイトで正規化して値をつくって使用する方法が書かれている。これと、もともと書いていた処理を組み合わせて

// 速度ベクトルを作成（3次元用）
var speed = new Vector3(movedir.x, 0.0f, movedir.z);

// 速度に正規化したベクトルに、移動速度をかけて代入する
rigid.velocity = speed.normalized * FieldMng.charaRunSpeed;

// 座標更新
// キャラクターを移動させる処理
rigid.MovePosition(rigid.position + rigid.velocity * Time.deltaTime);

最初のベクトル作成時にY座標を0.0fにしておかないと
障害物と当たったときに天高くunityちゃんが舞い上がってしまうから注意！

-----------------------------------------------

<Guildの室内を作成する>-------------------------
Assets/Furniture/PollyPrivattersのサンプルシーン
を一回丸コピしてきて、設置する。
カメラの角度的に映らない部分のオブジェクトを
取り除き、コライダー類を全てはずしてstaticに
すれば終了。
※ここのPrefabは魔道具屋にも使えそうなもの多い

------------------------------------------------

<Restaurantの室内を作成する>--------------------
Assets/Furniture/DiningSetのサンプルを引っ張って
くる。

壁が無いので、DarkFantasyの方から窓があるものを
持ってきてマテリアルを新規で作る
[RestauranWall]
Shader→Standard
Albedo→真っ白
NormalMap→DarkFantasiKitの、
           Steps,Floor,Ceiling/Materials/
           dfk_floor_01_normal.png

-----------------------------------------------

<BookStoreの室内を作成する>---------------------
壁のマテリアルとして、Assets/Furniture/BarChair/
Objects/Materials/Floor.mat
を利用した。

床のマテリアルとして新規に[BookStoreFloor]をつくり、Assets/Furniture/BarChair/
Objects/Materials/Floor.matをコピーして、内部の数値を調整したもの適用した。

-----------------------------------------------

<ItemStoreの室内を作成する>---------------------

ItemStoreWallというマテリアルを新規作成しました。
ワインボトル関連の棚のマテリアルの色を変更
[RusticWood]
R→0.56
G→0.37
B→0.2

------------------------------------------------

<TownMng.csを主軸とした修正>--------------------

会話文の終了後にその建物の中に画面遷移させるようにする関係で、広範囲のScriptに変更がでたので記載しておく。

[TownMng.cs]
①inHouseCanvasという外部アタッチ変数を用意した
　→HouseInteriorの子のInHouseCanvasをアタッチ

②①を使って該当する建物の室内キャンバスの表示を
　行うようにしている

③TownMng.csで該当する建物の前にキャラを飛ばす
　ようにしているが、Start関数のタイミングが、
　TownMng.cs→WarpTown.csとなっていて
　結果として直前につかったワープ座標が入るように
　なっていた。

　(解決方法)
　WarpTown.csのStart関数をInit関数と命名しなおし
　TownMng.csのStart関数内でInit関数を呼び出す
　ように修正した。
　→呼ばれるタイミングは、建物前に飛ばす処理より
　　前に必ずする必要がある

④建物内のカメラに最初からする必要があったので
　SetChangeCamera関数を呼び出すようにしていたが
　これも③と同じで、Start関数のタイミングが
　TownMng.cs→CameraMng.csとなっていた。

　(解決方法)
　そもそもCameraMng.csのStart関数を削除し、
　すべてSetChangeCamera関数を呼び出すようにした。
　※この関係で、UniHouseMng.csでも
　　cameraMng_.SetChangeCamera(false);
　　を呼び出すように修正した。

⑤室内カメラに遷移するときは、ワープ系の処理と
　キャラクター移動処理を切る必要があったため、
　HouseInteriorMng.csで新規に
　SetWarpCanvasAndCharaController関数を作成し
　これをTownMng.csでも呼び出せるようにした。
　※ただ、キャラアニメーションがnullでエラーに
　　なったため、UnitychanController.csの
　　StopUniRunAnim関数でthis.animetor_がnullかの
　　チェックをするif文をいれた。

これで会話終了後にそれまで話をしていた建物の中からスタートできるようになった。

------------------------------------------------

<ギルドのクエスト受注処理を作成する>-------------

参考サイト↓
https://gametukurikata.com/program/quest

上記サイトのように実装してから改良していく。

ギルド内に、「クエストを見る」のボタンを作成する
ヒエラルキーのHouseInterior/Guildの子に
[QuestCanvas(Canvas)]を新規作成し、更にその子として[LookQuest(Button)]を作る。※フォント変えとく

次に、プレハブにしておいた[QuestMng]も[Guild]の
子にする。(Unpackしておくこと)

<サイトからの変更点>
①ボタン操作でクエスト一覧がでるように、
<QuestMng.cs>にClickLookQuest関数を追加して
それを[LookQuest(Button)]のOnClickから呼び出すようにした。

②[QusetMng]にアタッチされている<QuestMng.cs>で
まだ非表示の[QuestUI]を取得しようとしてエラーに
なったため、外部アタッチで取得するようにした。


あとは、表示位置の座標とかをいろいろいじる。

スライドバー動かんやんけ。と思ったけど、
ちゃんとギルド内なら動く

------------------------------------------------

<ユニちゃんコントローラーの修正>-----------------

Animatorのパラメータ指定にはStringToHashしたものを使ったほうが良い。と書かれていたので、

private readonly int runParamHash = Animator.StringToHash("isRun");
という変数を用意しておき、
切り替えるときには
// WaitからRunに遷移する
this.animator_.SetBool(runParamHash, true);
みたいに書くように変更した。

------------------------------------------------

<HouseInterorMng.csの修正>----------------------

Start関数の呼び出し順序の関係で、TownMng.csから
SetWarpCanvasAndCharaController関数を呼び出した時にまだplayerController_情報がfindされてない事
があるらしい。

そのため、関数内でplayerController_のnull確認をして、nullならその場でfindするように修正した。

また、そのあとにStart関数が呼ばれると、
もう一度コントローラー情報をfindしようとするので
こっちにもnull確認を追加した。

<会話シーンから建物内を映してて、退出すると
 建物が非表示にならないバグ>

(原因)
HouseInteriorMng.csのExitButtonに、
全ての建物の内装を非表示にする処理が書かれていなかった。

(対処法)
// 建物オブジェクトの非表示(名前部分を""にすることで、全て非表示にできる)
ChangeObjectActive(this.gameObject.transform.childCount, this.transform, "");

上の文章を追加すれば解決した。

------------------------------------------------

<Toggleチェック時にクエストの説明を画面に出す>---

画面右側には最初からパネルを用意しておき、
そこに書き出す情報はトグルにチェックが入ったもの
みたいな感じにしたほうが、それぞれにパネルをつける必要もなくなるからいいかもしれない。

<QuestPrefabの変更点>
[InfomationPanel]を削除する。
→かわりにQuestUIの子として[InfomationPanel]を
　設置するから

[QuestToggle.cs]を新規作成し、[QuestPrefab]に
アタッチする。
(引数)
Toggle→Toggle

ToggleのOnValueChangedに[QuestPrefab]のアタッチ
をしてQuestToggle.OnToggleChanged関数を設定する

<QuestToggle.csの内容>
public変数でトグルの情報を持つようにする。
OnToggleChanged関数でトグルの状態を確認して
OnならQuestMng.csのSetSelectQuest関数に
自分の番号を渡す。

<QuestMng.cs>
[QuestPrefab]をインスタンス時に、[QuestPrefab]にクエスト番号を持たせるようにする。
// クエスト番号を設定する
questUIInstance.GetComponent<QuestToggle>().SetQuestNum(i);

private Text questInfoText;
という変数を新規で用意して、questUIからfindで読み込むようにstart関数に記載した。

SetSelectQuest関数で受けとったら、Excelから読み込んでおいた情報からクエスト情報をInfomationPanelのTextに書き込むようにする。

※ここまで、Excelからの読み込み以外は終了。

------------------------------------------------

<クエスト情報をExcelで作成する>-----------------
新規でExcelを作成し、
[Sheet1]を[Quest0]に変更する。

1行目に、num(int),info(string),clear(int)
というのを作成する。
今回はテストとして
num  →0,1,2
info →表示メッセージを3つ用意する
clear→すべて0にする

このExcelを[QuestInfo.xls]としてExcelDataファイルに保存する。
unity側でExcelをインポートするときに
class nameを[QuestInfo]にして他設定を行いcreate

いつもの\→/にするエラーを直してからreinportを
おして.assetファイルを作成。Resourcesファイルに
いれる。

※あとで追加で必要になるタブ[報酬][進行度]
　進行度は、画面にそもそも表示させるかとかの
　判定に必要になる

<QuestMng.cs>
TextMng.csを参考にしながらExcelデータを読み込めるようにStart関数に処理を追加する。

SetSelectQuest関数では、        questInfoText.text = popQuestInfo_.param[num].info;
という処理を行うように修正する。
※受け取ったExcelのinfo情報を代入する

<PopList.cs>
enumの数が増えてきたのでswitch文に変更
クエスト情報が来ても対応できるように追加変更

※現状では2番以降のボタンを押されるとエラー

------------------------------------------------

<トグルからボタンに変更する>---------------------
何かとトグルだと不便だったので、ボタンに変更する

[QuestPrefab]のトグル部分をButtonに変更。
また、[QuestToggle.cs]も[QuestButton.cs]に
名称変更
→これに伴い、他スクリプトでQuestToggleと
　書いているところやfindの書き方も変更すること

[QuestButton.cs]の内容もボタン用に修正する。
外部アタッチも[Button]をつけるようにする。
ButtonのOnClick()はQuestPrefabをヒエラルキーから
アタッチして、OnClickButton関数を入れる。

------------------------------------------------

<受注するボタンを用意する>----------------------
クエストを選択したあとなら受注ボタンを出現させて
クエスト受注できるようにする。

[QuestUI]の子に、[OrderButton(ボタン)]を作成。
画面右下にでてくるように調整する。

<QuestMng.cs>
questOrderButton変数を作成し、start関数から
findするように設定する。

ClickLookQuest関数に
questOrderButton.SetActive(false);
をつけたして、クエストを選択するまでは受注ボタンを非表示にしておく。

SetSelectQuest関数内でquestOrderButtonのアクティブをtrueにする。

※挨拶クエストを受けたら進行度を進める。
　受けないで他の建物に入ろうとしたら
　「今はギルドへ向かおう」と出す。
　(進行度2でギルド以外の建物に以降としたら。)

------------------------------------------------

<受注～クエストクリアまでの流れ>-----------------

とりあえず、ノートに書いた図の通りにやってみよ…

①空のゲームオブジェクトに、CompleteQuest.csを
　アタッチして、プレハブ化する。
　(ヒエラルキーからは削除)
  [CompleteQuestPrefab]

②受注ボタン押下時に①をインスタンスする。
　処理はQuestMng.csに記述する。
　ClickOrderQuest関数を作成し、中でインスタンス
　処理を書いてみる。
　
　ClickOrderQuest関数は、OrderButtonのOnClickに
　設定する。
　CompleteQuestPrefabを外部アタッチする

③CompleteQuest.csを書き換えて、
　Sceneを跨いでも消えないオブジェクトにする。
　(Awake関数内にDontDestroyOnLoad(this);と記述)

④受注ボタン押下時にインスタンスしたプレハブに
　クエスト番号を渡すようにする。

　CompleteQuest.csにSetMyNum関数を作成。
　QuestMng.csでインスタンスされた後に呼び出す。
　
　選択中のクエスト番号を保存する変数を
　QuestMng.csに作成しておく。

⑤[CompleteQuestPrefab]のタグを
　[Quest]にする。(新規作成)

⑥CompleteQuest.cs内で④の番号を使って、
　自分自身のプレハブの名前を番号に変更させる。

⑦QuestClearCheck.csを新規で作成する。
　中にリストを用意しておき、QuestMng.csで
　インスタンスしたものをそのままリストにいれる。

⑧QuestClearCheck.csに現在の受注中のクエストが
　何個あるかを確認する関数を用意する。
　受注ボタンを押したときに、その数が2以下なら
　新規受注を受け付けるようにする。

⑨Update関数で常にクリアフラグの立っているものが
　ないかを検索する(QuestClearCheck.cs)
　そのためにListをtuppleにしてboolを持てるように
　する。
　フラグがtrueならデバッグログを出力する。

-----------------------------------------------

<同じクエストが受けられないようにする>-----------
QuestClearCheck.csのCanOrderNewQuest関数に
引数を追加して、現在選択中のクエスト番号を取得する。

そして、foreach文でリスト内にあるものと同じ番号のクエストを受けようとしたらreturn falseを
返すように処理を追加した。
これで同じ数値のプレハブが複数個できることはない

------------------------------------------------

<QuestClearCheck.csと関連物の変更>--------------

QuestClearCheck.csのUpdateが呼ばれないことに気づいたため、SceneMngにアタッチするようにした。
※全てのSceneMngにアタッチしないといけない。

------------------------------------------------

<チュートリアルクエストのクリア条件を設定する>---
QuestClearCheck.csにSetBuildName関数を作成。
初回処理時に町長家とギルドとユニハウスを登録しておき、挨拶に関係のない建物を入れておく。

あとは、HouseInteriorMng.csからこの関数を呼び出して、まだ登録されていなければ登録するようにする。

登録建物が6になったら全ての建物に入ったということなのでクエストクリアフラグをtrueにする。

------------------------------------------------

<魔道具屋、書店、レストランのスクリプト作成>-----

HouseBaseを継承したScriptを作成する。
ギルドや町長の家と同じように作成して、
HouseInteriorMng.csのStart関数に

func_.Add("BookStore" , new BookStore().CheckEvent);
func_.Add("ItemStore" , new ItemStore().CheckEvent);
func_.Add("Restaurant", new Restaurant().CheckEvent);

と、登録する。

------------------------------------------------

<ギルドで0番のクエストを受けたらチャプターを2へ>-

受けた段階で進めないと、他建物に一切入れなくなる
Guild.csにGuildQuestEvent関数を作成し、
引数で受注したクエスト番号をもらい
現在の進行度とクエスト番号で進行させるか判断する

この関数はQuestMng.csのClickOrderQuest関数で
呼び出すようにする。

------------------------------------------------

<ギルド入室時に会話シーンへ飛ぶ前にボタンが見えて
 バグみたいに見えるバグ>------------------------

QuestMng.csにコルーチンを入れてButtonVisibleと
命名する。
最初にHouseInteriorMng.csで全てSetActiveをtrueに
されるが、コルーチン内でfalseにしたあと

yield return new WaitForSeconds(3.0f);

と処理を書いて3秒待機させる。
その後SetActive(true)にしなおす。

※ボタンを右から差し込む感じに今後修正する

------------------------------------------------

<クエストのExcelに、進行度欄を追加する>----------
QuestInfo.xlsにEventNumという項目を追加する。
「街の人に挨拶をしよう」には[2]を入れておくこと。
→現在の進行度が2であるだろうから。

QuestInfo.csにpublic int eventNumを追加する。
QuestInfo_importer.csの64行目付近に、
cell = row.GetCell(3); p.eventNum = (int)(cell == null ? 0 : cell.NumericCellValue);
を追加する。

<QuestMng.cs>
totalQuestNumを、QuestInfo.xlsの数に合わせる。
Start関数内で
totalQuestNum_ = popQuestInfo_.param.Count;

totalQuestNum_の数でfor文を回して、現在の進行度番号以下のクエスト数を一時変数に入れて記録する。

そして、totalQuestNum_の数でクエストボタンを作成していた場所を、一時変数の数で作成するように修正
→これで、まだ受けられないクエストが発生しないよ
　うにできる。

------------------------------------------------

<クエストのクリア報告ができるようにする>---------

QuestCanvasに[ReportQuest(Button)]を作成する。
文字は「クエストを報告」と打ち込んでおく。

<QuestMng.cs>
新規で[ClickReportQuest]関数を作成し、
[ReportQuest(Button)]のOnClickで呼ばれるように設定しておく。

関数内でCanvasの表示/非表示切替処理を行う

今のままだと、クエストを受注するのか報告するのか判定ができない
→enumを作成し、今どのボタンの処理中かがわかるよ　うにする

NOWPAGEというenumを作成した。
それぞれボタン押下時にenumの状態を変更するように記述し、SetSelectQuest関数で受注ボタンを表示する
のはLOOK_QUEST中だけという風にif文を追加した。

<報告するボタンの作成>
QuestUIの子に[ReportButton(Button)]を作成する。
「報告する」とテキストに入れておき、
CliclReportButton関数を作成しておいてOnClickに
設定する。

(ClickOrderQuest->ClickOrderButtonに名称変更)

questOrderButton_変数と同様にquestReportButton_
を作成し、表示/非表示切替をする

<QuestClearCheck.csの修正>
Update関数でフラグがtrueになっているものを発見したら、受注中リストからクリア済み用のリストへ移動させるようにする。

①clearedQuestsList_というリスト変数と、
　deleteNum_という削除予定番号を入れる変数を作る

②Update関数でフラグがtrueの要素があれば
　deleteNum_に代入する

③deleteNum_が初期値(-1)でない場合は、削除番号と　一致している名前のオブジェクトをリストから探し　出して、clearedQuestsList_にコピーした後、
　orderQuestsList_から削除する

リストの要素の削除方法の参考サイト↓
https://light11.hatenadiary.com/entry/2019/10/14/215209

<クエストを報告するボタン押下時の処理>
QuestClearCheck.csにGetClearedQuestsList関数を
用意しておき、QuestMng.csのClickReportQuest関数内で、クリアしたクエストのボタンを表示させる。

<ClickReportQuest関数での処理内容>
①クリアしたもののボタンが上に来るように、
　ヒエラルキー順を並び替える

②1度全てのボタンを表示にする

③クリアしたクエスト以外は非表示へするから
　for文でクリア個数以上のクエストは非表示にする
→①でヒエラルキー順を並び替えているから、
　個数を見てオーバーしたクエスト分を非表示にする
　だけで大丈夫になっている

※もし並び替えをしていなかったら、
　クリアしてないクエストが表示状態のままだったり
　クリアしたクエストが非表示状態にされたりする
　可能性がある

<ClickReportButton関数での処理内容>
最後に、達成報告ボタンを押したらクリアリストから
削除する処理を行う。

QuestClearCheck.csに、SetClearedQuestsList関数を
用意して、Updateに記載しているのと似た削除処理を
入れる。

引数に削除番号を入れれるようにしておき、
QuestMng.cs側ではそこにquestNum_を入れれば
たぶん大丈夫。

このときに、staticで生成していたプレハブも削除したほうがいいから、
タグ+番号で探してDestroyしてnullをいれる。

あと、報告したクエストは非表示組にいれないと
いつまでも画面にボタン表示が残ってしまう。
→さっきつくったClickReportQuest関数での処理内容
　という内容のところを、ClearQuestUpdate関数とし　て別の関数に切り分けて
　ClickReportQuest関数とClickReportButton関数の
　両方で呼び出せるようにしたら解決した。

これでクエストのクリア報告ができるようになった。

------------------------------------------------

<クエストの戻るボタンを設置>--------------------
仮の画像で戻るボタンを設置する。
QuestUIの子に[BackButton(Button)]を新規追加。

QuestMng.csにもClickBackButton関数を追加して、
OnClickに設定する。

questOrderButton_変数等と同様にfindしておいて
押下時には前の画面に戻るようにする。
また、LOOK_QUESTとREPORT_QUEST画面では表示状態に
しておき、NONのときは非表示にしておく。

------------------------------------------------

<ボタンUIアニメーションをつける>-----------------

InHouseCanvasの子につけていたExitButtonを、
QuestCanvasの子に持ってくる
→まだGuildのExitButtonのみ移動させておく

QuestCanvasに、金曜日に学校で作成した
UIMove.csをアタッチする。

QuestMng.csのコルーチンでCanvas表示を遅くしている
のを削除する

------------------------------------------------

<挨拶周りクエスト達成後のギルド会話を作成する>---

ギルドで達成報告をした後に発生する会話をExcelの
チャプター6として作成。

Chapter_importer.csに"6"を追加してreimportする。

QuestMng.csのClickReportButton関数内で
GuildQuestEvent関数を呼び出すようにする。

GuildQuestEvent関数に
EventMng.GetChapterNum() == 6 && questNum == 0
のif文を追加する。

いまのままではクエストを受けたときに発生する会話なのか達成したときに発生する会話なのかが見分けつかないので、GuildQuestEvent関数の引数にboolを
追加する。

boolのデフォルトはfalseにしておいて、
trueのときだけ引数にtrueをいれるようにする。

会話後はUniHouseのシーンに飛ばす予定だから、UniHouse.csを作成して
HouseInteriorMng.csのfunc_に登録する。

※最初から通しでプレイしてデバッグする

------------------------------------------------

<UIMove.csの修正>-------------------------------
ギルドに2回目以降入ったときに、ボタンが右から差し込まれるやつが発生しなかった。

(原因)
初回で中央に来た座標で止まっているから

(対処法)
UIMove.csのStart関数で、初期位置を右画面外にしておく必要がある。

<UIMove.cs>
Start関数にしていたところをOnEnable関数にして、
表示状態になったら毎回差し込まれるようにした。

コルーチンの時間や、子供の座標を毎回設定しなおす
ように修正した。

------------------------------------------------

<挨拶クエスト達成後の会話の後に進行度7にしたい>--
Chapter.xlsに新規で項目を増やすしかなさそう。
messageの横にeventNumを追加する。

Chapter6のタブで、
name1がSceneの所のeventNumに[7]をいれる。
※他の進行度が進まないところには[-1]を入れる。

<ChapterList.cs>
public int eventNumを追加する。
<Chapter_importer.cs>65行目
cell = row.GetCell(4); p.eventNum = 
(int)(cell == null ? 0 : cell.NumericCellValue);

<TextMng.cs>
ChangeScene関数の中で、eventNumが[-1]以外なら
EventMng.csを呼び出して設定するように処理を追加。

これで、進行度が[7]の時にユニが家に帰ったときの処理を書けるようになる。
※InHouseAndUniHouse.txtへ記載していくよ

------------------------------------------------

<QuestInfo.xlsの修正>---------------------------

num:1の所を、
info　　→ギルドテストへ挑戦！
eventNum→8

また、num:2のeventNumを9にずらしとく

------------------------------------------------

<クエスト関連の大幅修正>------------------------

そもそもバグとして、『クリア報告時にヒエラルキーの順序を入れ替えたら、再び受注するときに中身とボタン番号が一致しなくなる』という事態が発生してた

それを修正して、ついでにクエスト受注後は
受注中のクエストがリストに残らないようにする。
というのを実装した。

QuestClearCheck.csにGetOrderQuestsList関数追加

<ここからすべてQuestMng.cs>
①ClickLookQuest関数で、
　受注中のクエスト+報告待ちのクエストを合体させた
　リストを作成する

②QuestUIと、その子供の全部のクエストボタンを
　一度表示状態にする

③①のリストとボタンすうで2重for文を回し、
　リスト内にある＝再び受注できる状態ではない
　という判断の為、クエストボタンを非表示にする

つぎに、クエストクリア報告時処理
①ClearQuestUpdate関数で
　QuestUIは表示状態にし、その子供の全部のクエスト　ボタンは全て非表示にする

②QuestClearCheck.GetClearedQuestsList()で
　リストを取得してきて、リストに載っていたら
　報告ができるということだから、クエストボタンを
　表示状態にする

------------------------------------------------

<クエスト達成回数を記録する>---------------------

QuestMng.csに新規でmap変数を用意し、
キーにクエスト番号,値に達成回数を入れるようにする

継続してカウントしないといけないから、static変数
にする。

初回だけ0初期化が必要だから、
Start関数内で、Countが0のときだけAddするように
しておく。

あとは、クリアするたびにカウントを増やしていけば
いいのでClickReportButton関数で
questClearCnt_[questNum_]++;
とする。

------------------------------------------------

<QuestInfo.xlsからメインかサブか取得可能にする>--

QuestInfo.xlsに新規項目として[type]を追加する。
そこで[main]か[sub]かを記入する。

QuestInfo.csにpublic string type;を追加する。
QuestInfo_importer.csの65行目に
cell = row.GetCell(4); p.type =
(cell == null ? "" : cell.StringCellValue);
を追加してreimportする。

一度クリアしたメインクエストは複数回クリアできないようにするために、
ClickLookQuest関数に
popQuestInfo_.param[k].type == "main" && questClearCnt_[k] >= 1
という条件式の処理を書いて、該当するときは非表示にするようにした。

------------------------------------------------

<進行度2でユニハウスからタウンへ行くと、
 ギルド内に強制転送バグ>------------------------

(原因)
TownMng.csで会話シーンから戻ってきてるのか、
ユニハウスから来てるのか判断がついてない

(解決策)
TownMng.csで
if(str != "Mob")の処理に入ったときに、
最後の行で
SceneMng.SetHouseName("Mob");
を追加して、2回目以降は室内に飛ばされないように
した。

------------------------------------------------

<時間経過と空の色を合わせる>---------------------

新規ファイルの[SkyBox]にスカイボックスマテリアルを2つ入れた。

学校で作成したSkyBoxColor.csを各ディレクショナルライトにアタッチして、引数に[SkyBox]フォルダにあるマテリアルをアタッチするように変更。

あとは、SkyBoxColor.cs内の数値を微調整して
SceneMng.csから受け取った時間帯に合わせて
マテリアルの切替や値の入れ替えを行うだけ。

------------------------------------------------

<夜のTownとユニハウスのシーンにライトを置く>-----

Townの方は街頭とか建物にライトを置いて、
ユニハウスの方はDecorationに街頭を追加してから
ライト設置。

※図書館と魔道具屋の外見にライト1つ追加

魔道具屋のShaderがDiffuseのせいだと思うが
建物にライトが当たっても反射しない。
→Standardにしたらなんかおかしくなる。半透明??

魔道具屋の机の上にあるcrystalフラスコ(赤いやつ)が
おかしくなってた。プレハブから入れなおしたら治ったけど、さきちゃんのほうではどうだろうか？要確認

<TownMng.cs>
Start関数で、今が夜であれば、ライトを点灯させて
夜以外なら消灯するという処理を追加する。

シリアライズフィールドで外部アタッチ変数を作成し
NightLampLightsをアタッチする。
※このとき、NightLampLightsは非表示状態、
　その子供は全て表示状態にしとく。

<UniHouseMng.cs>
TownMng.csと同様に
シリアライズフィールドで外部アタッチ変数を作成し
NightLampLightsをアタッチ。
Start関数で、今が夜であれば、ライトを点灯させて
夜以外なら消灯するという処理を追加する。

------------------------------------------------

<DontDestroyCanvasにTimeCanvasを含める>---------
削除されないキャンバスものとして扱いたいので
含める事にした。

キャンバスの機能はいらないので空のオブジェクトに入れて中身を移動させる。

[TimeGear]という空のオブジェクト作成
そこに[Panel]と[Image]を子として追加。

TimeGear.csのAwake関数にあるFindを変更しないと
nullでエラーになる。

これでPrefabフォルダにパッケージしなおす。

------------------------------------------------

<会話から街に戻ってきたときに、TimeGear.csで
 エラーが発生する>------------------------------

(原因)
不明。
target = Quaternion.Euler(new Vector3(0.0f, 0.0f, rotateTimeGearMap_[SceneMng.GetTimeGear()]));でエラーがでる。。。

(対処法)
でるときとでないときがあるからまだわかってない

------------------------------------------------

<クエスト内容を詳細化>--------------------------

今は題名しかないから、詳細を書く

題名の部分のテキスト名を[TitleText]にする
※ヒエラルキーの方も変える
　HouseInterior-Guild-QuestMng-InfomationPanel
  -Textの部分

InfomationPanelに[DetailText]を追加する。

QuestInfo.xlsに[detail]という項目を追加する。

[QuestInfo.cs]
public string detail;を追加する。

[QuesInfo_importer.cs]
cell = row.GetCell(2); p.detail = (cell == null ? "" : cell.StringCellValue);
を追加する。

[DetailText]
Pos X:-160 Y:200 Z:0
FontSize:32

------------------------------------------------

<ステータス画面の調整をする>---------------------

アトリエ風ゲームフォルダに入れたステータス画面参考画像をみて、同じように配置していく
※まずはユニの画面分だけ

StatusInfoのX座標を300,Y座標を120にして、
そもそもの表示範囲枠(黄色い枠)をもう少し広げる。

立ち絵を用意する。
2Dの立ち絵をステータス値の左側に描画させるように
する。
portrait_kohaku_01_.pngをUni.pngという名前にして
Pictureフォルダに入れる。

StatusMngに[CharaImage(Image)]を用意して、
試しにUni.pngを入れてみる。
もともとのサイズがでかすぎたからペイント3Dで縮小
→縦横のパーセントを20%にする
(505*638)

[CharaImage]
Pos X:-8.5 Y:-98 Z:0
Width:505 Height:638

立ち絵の足部分が切れているから、下を模様か何かで
隠したほうがいい。
新規でStatusMngに[Panel(Panel)]を用意する。
[Panel]
アンカーポイント:中央
Pos   X:105 Y:-320 Z:0
Scale X:11  Y:1    Z:1
α値:0.698
(0.7にしようとしたら勝手にこの数値になる)

上部にも同じようにパネルを設置したいから複製して
PosYを320にする。

左側にキャラ切替用のボタンを設置する
[Topics]を複製してStatusMngの子にする。
[Topics]
Pos   X:-330 Y:235 Z:0
Scale X:0.7  Y:0.7 Z:1

[LeftBtn]
Pos   X:-100 Y:-20 Z:0
Scale X:0.7  Y:0.7 Z:1

[RightBtn]
Pos   X:300  Y:-20 Z:0
Scale X:0.7  Y:0.7 Z:1

アイテムとかそざいとかワードの切替と同じ要領で
やりたいから、ItemBagMng.csのOnClickLeftArrowと
OnClickRightArrowの関数に追加させてもらう

矢印の内容を切り替えたいから、
MenuActive.csのSelectCanvasActive関数のキャンバス状態を保存できるようにして、矢印の処理を切替れるようにしたい。

[MenuActive.cs]
新規で、private CANVAS nowCanvas_;を用意して
SelectCanvasActive関数で
nowCanvas_ = canvas;とする。
GetNowMenuCanvas関数を作成してreturn nowCanvas_;
とする。

[ItemBagMng.cs]
ステータス用のInit関数を別で作ったほうがよさそう
→StatusInit関数作成してMenuActive.csでステータス
　のときはこのinitを呼び出すようにする。

(どちらのInitでも行う処理)
menuActive_がnullならMenuActiveのついているSceneMngをFindする

OnClickRight/Leftそれぞれに現在のメニューがBAGか
STATUSかで処理を分けるようにする。

※Init関数は複数回呼ばれるのでnull処理をいれた方
　が処理回数を減らせる。

<矢印を押すとキャラ名が変わるようにする>
まず、そもそもキャラ名が入るようにする。
[ItemBagMng.cs]
charaNameTopicText_;
charaStringNum_;
charaTopicString_;
の変数を追加する。
StatusInit関数に処理をいれる。

あとはOnClickRight/Left関数でcharaStringNumの
増減処理をおこなう。

<キャラ名が変わったときに各キャラのステータス値
 がでるようにする>
STATUSで呼び出しているViewStatus関数を、ItemBagMng.csから呼び出すように変更する。
ViewStatus関数に引数でint charaNumを用意して、
publicにしておく。

ItemBagMng.csの
StatusInit関数で
menuActive_.ViewStatus(charaStringNum_);
を呼び出し。
OnClickRight/Left関数でも同様に呼び出す。

<ジャックの立ち絵に切り替わるようにする>
[ItemBagMng.cs]
立ち絵の切替をシリアライズフィールドのprivateで
外部アタッチするようにする。
※配列数を[2]にして[Uni.png][Jack.png]の順に
　アタッチする

charaStringNum_に合わせて立ち絵が変わるように、
charaImg_.sprite = CharaImage_[charaStringNum_];
とする。

新規でcharaImg_変数をつくり、findでCharaImageを取得する。

portrait_jack_01.pngを[Jack.png]として
Pictureフォルダに入れる。
(408*750)

画像に合わせて台紙側のサイズを変更しないとだめ。
private RectTransform charaImgRect_;変数を
用意し、StatusInit関数とOnClickRight/Left関数に

charaImgRect_.sizeDelta = new Vector2(CharaImage_[charaStringNum_].rect.width, CharaImage_[charaStringNum_].rect.height);
というのを追加する。

<ジャックがパーティに入るまで切り替えられないよう
 にしておく>
進行度番号が8になったときにジャックのステータスが
表示できるようにする。
→chapterNumを7にしてギルドに入り、会話して
　クエスト受けた後にステータス画面を開いたら
　ジャックのステータスも見れるようになる。

------------------------------------------------

<クエスト報告時にハンコが押される表現をする>-----

学校から持ち帰ってきたデータにCanvas.prefabと
Picture/test.pngがあるからそれを使って実装する。

まずはCanvasの内容をギルドの台紙に移動させる。
Guild/QuestMng/QuestUI/InfomationPanelに、
[RectMask2D]をアタッチする。
そして、その子として[Stamp]をアタッチして、
Imageをtest.pngにする。

[Stamp]
アンカーポイント:右下
Pos X:-65 Y:120 Z:0
Width:315 Height:309
Scaleは全て1

とりあえず最初からスタンプ押下状態にはなった。

次に、クエスト報告ボタンが押された時だけ出てくるようにする。

[QuestMng.cs]
private Image stampImg_変数を作成する。
Start関数内でFindする。
ClickLookQuest関数やClickReportQuest関数では、
関数の最後尾で
// ハンコを非アクティブにする
stampImg_.gameObject.SetActive(false);
そして、ClickReportButton関数では、
// ハンコをアクティブにする
stampImg_.gameObject.SetActive(true);
にする。

------------------------------------------------

<クエストクリア報酬について>---------------------
まず報酬内容をクエストの紙に記載するようにする。
そのために、QuestInfo.xlsに報酬の欄を追加する。

rewardという項目を追加して
各クエストに報酬を記入する。

<QuestInfo.cs>
public string reward;を追加する

<QuestInfo_importer.cs>
67行目に
cell = row.GetCell(6); p.reward = 
(cell == null ? "" : cell.StringCellValue);
を追加する。

これで報酬内容を読み込めるようになった。

QuestMng/QuestUI/InfomationPanelの子に、
[RewardText(Text)]を追加する。
[RewardText]
Pos X:-160 Y:-30 Z:0
Width:160 Height:30

[QuestMng.cs]
private Text questInfoText3_;
という変数を作成する。

Start関数で
questInfoText3_ = questUI.transform.Find("InfomationPanel/RewardText").
GetComponent<Text>();
とする。

SetSelectQuest関数に、
questInfoText3_.text =
"報酬\n" + popQuestInfo_.param[num].reward;
を追加する。

これでクリア報酬の内容を表示することができた。

<もっと報酬受け取りを目立たせたい>
ForestFieldで実装したポップアップをもってくる。
QuestUIの子として
PopUp -BackImage,TitleBackImage,GetReward,TitleInfo
という階層で実装する。

[QuestMng.cs]
private GameObject popUpReward_;と
private TMPro.TextMeshProUGUI rewardText_;
という変数を作成。

Start関数でFindする。

ClickReportButton関数で報酬内容を記載したあとに
ポップアップをアクティブにする
rewardText_.text =
popQuestInfo_.param[questNum_].reward;
popUpReward_.SetActive(true);

ポップアップ内容は時間経過でfalseにしたいから、
FieldMng.csのPopUpMessage関数をもってきて
ClickReportButton関数でコルーチンを呼ぶようにする

------------------------------------------------

<ポップアップのα値とか決めたい>-----------------
ほわんとだしてほわんと消したい。

新規でα値を調整するScriptを作成したほうがいい。
[AlphaChange.cs]というスクリプトを作成して、
PopUpにアタッチする。

[AlphaChange.cs]
3つのprivate変数を用意する。
private float alpha_ = 0.0f;
private float alphaChangeSpeed_ = 0.01f;
private (GameObject,bool)[] chiledObj_;

OnEnable関数内でalpha_変数を初期化し、
chiledObj_変数の設定をfor文内で行う。
→ここのfor文内でcolorの設定を(1,1,1,0)にして
　α値を0にする。

最後の行でコルーチンを呼び出す。
(PopUpAlpha関数)
alpha_変数が1.0fより小さい間はwhile文を回り続ける
内部ではalpha_変数を加算しつつ、ImageとTMProの見分けをboolでして、値を変更する。

<ForestFieldのPopUpにつけたらエラーでたわ>
(原因)
ImageでもTMProでもないやつがelseに入ってたから。
(対処法)
α値の加算を飛ばす子供の番号を入れるリストを作成する。

private List<int> notAlphaChangeList_ =
new List<int>();を用意する。

OnEnable関数でelseにきたものをAdd(i)とする。

コルーチンのfor文でnotAlphaChangeList_にいれた数字と一致したiならbreak処理をする。
→さらに、breakに入ったときにtmpFlgをfalseにして
　falseならα値加算処理に入らないようにif文を
　つける。

------------------------------------------------

<他の報告クエストを押したときにハンコが消えない>-

[QuestMng.cs]
SetSelectQuest関数のelse ifにある
REPORT_QUEST内に、ハンコを非アクティブにする処理を追加する。

ハンコの画像の名前を
[Stamp.png]に変更する。
------------------------------------------------

<チュートリアルクエスト達成報告後にChapter9の
 会話を発生させる>------------------------------
※Chapter8で回復アイテムをジャックから受け取る
　会話を追加する。
まずは会話文の作成。
[Chapter_importer.cs]
"9"を追加する。

[Guild.cs]
GuildQuestEvent関数に、
GetChapterが9でクエスト番号1をクリアしたら
チャプター9の会話が発生するように処理を追加。

デバッグ完了。

※報酬のポップアップが終わってから会話に遷移でき
　たほうがいいかも

[QuestMng.cs]
PopUpMessage関数でwhile文が終わったあとに
guild_.GuildQuestEvent(questNum_, true);
を呼び出すように変更する。
→ポップアップ中に外に出られたら次の会話文へ
　進めないので、PopUpMessageのtime >= 1.5f
  にする。

また、時間を夕方にして、次の日へ進めるようにする

------------------------------------------------

<アイテム&魔法クエストを発生>-------------------

ポーションの納品クエスト発生の会話と、
町長からのクエストとして入手したワードで
炎のマテリアを作成するクエストが出たことを会話
させる。

[Guild.cs]
CheckEvent関数で、現在のチャプターが10で時間が朝
のときに会話を発生させる。

※合成のチュートリアル

<Chapter.xls>
Chapter10の会話内容を作成する。

[Chapter_importer.cs]
"10"を追加する。

<QuestInfo.xls>
num 2,3を作成する
2にアイテム納品
3に魔法作成を作成する。
どちらもeventNumを11にする。

EventMngを10にして確認済み
2つともクリアしたら次へ話を進めるようにしないと
いけない。

------------------------------------------------

*重要*
タグの判別にはgameObject.tag == “string tag”もあるが、CompareTag()の方が早い

最後に、不使用だったものは消すようにしないと。