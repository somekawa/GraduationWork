新規に作成した、街をつくるテストのScene

ここに、さきちゃんから受け取った街のアセットを利用して作成していく。

<透過した画像をオブジェクトに貼りつける方法>-----

参照したもの↓
https://am1tanaka.hatenablog.com/entry/20120131/1328015837

①いつも通り、Pictureの画像のTextureTypeを
Sprite(2DandUI)にする

②Pictureフォルダ内にMaterialsフォルダを用意して
そこに新規でマテリアルを作成
(UnityLogoと命名)

③MaterialのShaderを
[Legacy Shaders/Transparent/Diffuse]にする

④Selectと書かれているところに、今回適用したい
　画像をアタッチする

⑤UnityLogoマテリアルを3DObjectのQuadとかに
　貼り付けたら完成

------------------------------------------------

<Terrainで地面づくり>---------------------------
参照したもの↓
①基本操作
https://qiita.com/yando/items/ef76c200bb50005170d5

②テクスチャの貼り方が変わったらしいので。
https://teratail.com/questions/173073

③草の生える量の調整について。
https://unity.moon-bear.com/3d%E3%82%A2%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8C%E3%83%A6%E3%83%8B%E3%83%86%E3%82%A3%E3%81%A1%E3%82%83%E3%82%93%E3%83%91%E3%83%AB%E3%82%AF%E3%83%BC%E3%83%AB%E3%80%8D/terrain%E3%81%A7%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8%E3%82%92%E4%BD%9C%E3%82%8B/#toc7

------------------------------------------------

<定点カメラ方式の実装>--------------------------

十字路の道で、左右の道に入ったとき、定点カメラに切り替わるようにする。
もともとCameraMng.csで切替の仕組みを用意しているため、ここを街のカメラも使えるように修正する。
UnitychanController.csの内容も追加するものが増える。

左右の定点カメラは、Unityちゃんの座標によって移動させれば、1台だけですむはず。


※往復してカメラが連続で切り替わるときにも
　不可視の当たり判定用のボックスを設置しといて、
　Exit関数通過時にそのボックスより左右どちらに
　いるかを判定してカメラの切替がありなりを決める

-----------------------------------------------

<街の定点カメラ準備>----------------------------
CameraMng.csでFindでカメラを探すようにしている所を、アタッチ方式に変更しなおす。
→どのSceneでも使えるようにするため。

CameraMng.csの、
buttleCameraという変数名をSubCameraに名前変更する

ヒエラルキーに新規カメラを追加して、
FixedPointCameraと命名する。
ヒエラルキーに空のオブジェクトを作成して、
CameraControllerと命名し、CameraMng.csをアタッチ
MainCamera→MainCamera
SubCamera →FixedPointCamera

また、FieldMng.csのnowModeの初期値をNONにし、
UtnichanController.csでのUpdate関数のreturn処理条件に、　&& nowMode != NONを追加した。

nowModeがNONということは、「街にいる」という
考え方にする！

[FixedPointCamera]
Position X:24 Y:3 Z:89

------------------------------------------------

<通過テストを始める>----------------------------

とりあえず、右通路のテストからしよう。
新規でキャラ通過確認用のCubeを追加する。
名前は、[GoThroughRight] 
Position X:19 Y:0.5 Z:95
Scale    X:2  Y:2   Z:10
BoxColliderのIsTriggerにチェックを付けておく
RigidBodyもつけて、IsKinematicにチェックする。

[GoThroughRight]につける新規Scriptを作成する。
名前は、[GoThroughCheck.cs]
このスクリプトで、キャラが通過したかを確認して、CameraMng.csにカメラ切り替えの指示を出す。

[GoThroughCheck.cs]で、
void OnTriggerEnter(Collider col)
{
    if(col.CompareTag("Player"))
    {
        Debug.Log("カメラ切替");
        cameraMng_.SetChangeFlg(true);
    }
}
という判定を行い、現在ログを出力しているところに
CameraMng.csで新規に用意したSetChangeFlg関数を
呼び出す。

これで右へ通過したときにカメラが切り替わるようになった。
-----------------------------------------------

<キャラがカメラに映らない位置に来たりする>-------

家のMeshCollider1つ1つは外して、大きいBoxColliderとかを別で用意したほうがよさそう。
カメラ替えたときに映らないところへは当たり判定で
移動できないようにしておいたほうがいい。
ヒエラルキーに追加した[House12-13Collider]という
のを参考に設定していくこと！

また、キャラのZ座標が、94以下の時には
95に設定するように[GoThroughCheck.cs]の
OnTriggerEnterに処理を追加した。

------------------------------------------------

<右の通路カメラから元のカメラに戻れるようにする>-
GoThroughCheck.csにて。

EnterとExitを使うことで、通り抜けしたときと
通り抜けずに引き返したときのカメラの処理を正しくできる。

EnterとExitでそれぞれキャラの座標を変数に入れて置き、Exitの方でExitPos - EnterPosのnormalizedの
X座標をみて、
1.0なら右への通過
-1.0なら左への通過と考えるようにした。

ただし、まだ左の住宅街の処理をつくっていないため
場合によってはまた修正をするかもしれない。

------------------------------------------------

<左の通過テストをする>--------------------------

右と同様に、[GoThroughLeft]という通過確認用の
Cubeを作成する。
Rightの方をコピーして、X座標をマイナス値にするだけでいい。
作ったCubeにGoThroughCheck.csとRigidbodyがあるのを確認しておくこと。

GoThroughCheck.csでOnTriggerExit関数に
オブジェクトの名前でカメラ位置や、SetChangeFlgの切替を分けるように処理を書いたら終了。

------------------------------------------------

<すり抜けてほしくない箇所に壁を設置していく>-----

当たり判定の精度を高めて、すり抜け防止のために
UniのRigidbodyにある[CollisionDetection]を
Continuousに変更した。

詳細は下のサイトで↓
https://ekulabo.com/rigidbody-collision-detection#outline__3

------------------------------------------------

<噴水の水について>------------------------------

噴水のアセット+StandardAssetsという中にある水のやつが必要らしい。
バージョンによってはStandardAssetsのインポート後にエラーがでるとのことなので、対処法を記載しているサイトを載せておく↓
https://nekojara.city/unity2020-standard-assets

噴水以外に水を設置するときに参考にできるサイト↓
https://xr-hub.com/archives/3452

とくにエラーはでなかった…

------------------------------------------------

<キャラが建物を貫通する>------------------------

2人で調べたところ、建物の判定で斜めの面とキャラが
当たり判定したときに貫通するようになっていると
わかった。そのため、判定位置を大きくしたり
ずらすことによって、多角面と判定が起こらないように調整して修正した。

-----------------------------------------------

<キャラの移動速度について>----------------------

斜め移動時に、速度が速くなりすぎておかしくなっていたため、UnitychanController.csに修正をいれた。

参照したもの↓
https://unity-senpai.hatenablog.com/entry/2020/10/13/010845#%E4%B8%89%E5%B9%B3%E6%96%B9%E3%81%AE%E5%AE%9A%E7%90%86%E3%81%AE%E5%BE%A9%E7%BF%92

上記のサイトで正規化して値をつくって使用する方法が書かれている。これと、もともと書いていた処理を組み合わせて

// 速度ベクトルを作成（3次元用）
var speed = new Vector3(movedir.x, 0.0f, movedir.z);

// 速度に正規化したベクトルに、移動速度をかけて代入する
rigid.velocity = speed.normalized * FieldMng.charaRunSpeed;

// 座標更新
// キャラクターを移動させる処理
rigid.MovePosition(rigid.position + rigid.velocity * Time.deltaTime);

最初のベクトル作成時にY座標を0.0fにしておかないと
障害物と当たったときに天高くunityちゃんが舞い上がってしまうから注意！

-----------------------------------------------

<Guildの室内を作成する>-------------------------
Assets/Furniture/PollyPrivattersのサンプルシーン
を一回丸コピしてきて、設置する。
カメラの角度的に映らない部分のオブジェクトを
取り除き、コライダー類を全てはずしてstaticに
すれば終了。
※ここのPrefabは魔道具屋にも使えそうなもの多い

------------------------------------------------

<Restaurantの室内を作成する>--------------------
Assets/Furniture/DiningSetのサンプルを引っ張って
くる。

壁が無いので、DarkFantasyの方から窓があるものを
持ってきてマテリアルを新規で作る
[RestauranWall]
Shader→Standard
Albedo→真っ白
NormalMap→DarkFantasiKitの、
           Steps,Floor,Ceiling/Materials/
           dfk_floor_01_normal.png

-----------------------------------------------

<BookStoreの室内を作成する>---------------------
壁のマテリアルとして、Assets/Furniture/BarChair/
Objects/Materials/Floor.mat
を利用した。

床のマテリアルとして新規に[BookStoreFloor]をつくり、Assets/Furniture/BarChair/
Objects/Materials/Floor.matをコピーして、内部の数値を調整したもの適用した。

-----------------------------------------------

<ItemStoreの室内を作成する>---------------------

ItemStoreWallというマテリアルを新規作成しました。
ワインボトル関連の棚のマテリアルの色を変更
[RusticWood]
R→0.56
G→0.37
B→0.2

------------------------------------------------

<TownMng.csを主軸とした修正>--------------------

会話文の終了後にその建物の中に画面遷移させるようにする関係で、広範囲のScriptに変更がでたので記載しておく。

[TownMng.cs]
①inHouseCanvasという外部アタッチ変数を用意した
　→HouseInteriorの子のInHouseCanvasをアタッチ

②①を使って該当する建物の室内キャンバスの表示を
　行うようにしている

③TownMng.csで該当する建物の前にキャラを飛ばす
　ようにしているが、Start関数のタイミングが、
　TownMng.cs→WarpTown.csとなっていて
　結果として直前につかったワープ座標が入るように
　なっていた。

　(解決方法)
　WarpTown.csのStart関数をInit関数と命名しなおし
　TownMng.csのStart関数内でInit関数を呼び出す
　ように修正した。
　→呼ばれるタイミングは、建物前に飛ばす処理より
　　前に必ずする必要がある

④建物内のカメラに最初からする必要があったので
　SetChangeCamera関数を呼び出すようにしていたが
　これも③と同じで、Start関数のタイミングが
　TownMng.cs→CameraMng.csとなっていた。

　(解決方法)
　そもそもCameraMng.csのStart関数を削除し、
　すべてSetChangeCamera関数を呼び出すようにした。
　※この関係で、UniHouseMng.csでも
　　cameraMng_.SetChangeCamera(false);
　　を呼び出すように修正した。

⑤室内カメラに遷移するときは、ワープ系の処理と
　キャラクター移動処理を切る必要があったため、
　HouseInteriorMng.csで新規に
　SetWarpCanvasAndCharaController関数を作成し
　これをTownMng.csでも呼び出せるようにした。
　※ただ、キャラアニメーションがnullでエラーに
　　なったため、UnitychanController.csの
　　StopUniRunAnim関数でthis.animetor_がnullかの
　　チェックをするif文をいれた。

これで会話終了後にそれまで話をしていた建物の中からスタートできるようになった。

------------------------------------------------

<ギルドのクエスト受注処理を作成する>-------------

参考サイト↓
https://gametukurikata.com/program/quest

上記サイトのように実装してから改良していく。

ギルド内に、「クエストを見る」のボタンを作成する
ヒエラルキーのHouseInterior/Guildの子に
[QuestCanvas(Canvas)]を新規作成し、更にその子として[LookQuest(Button)]を作る。※フォント変えとく

次に、プレハブにしておいた[QuestMng]も[Guild]の
子にする。(Unpackしておくこと)

<サイトからの変更点>
①ボタン操作でクエスト一覧がでるように、
<QuestMng.cs>にClickLookQuest関数を追加して
それを[LookQuest(Button)]のOnClickから呼び出すようにした。

②[QusetMng]にアタッチされている<QuestMng.cs>で
まだ非表示の[QuestUI]を取得しようとしてエラーに
なったため、外部アタッチで取得するようにした。


あとは、表示位置の座標とかをいろいろいじる。

スライドバー動かんやんけ。と思ったけど、
ちゃんとギルド内なら動く

------------------------------------------------

<ユニちゃんコントローラーの修正>-----------------

Animatorのパラメータ指定にはStringToHashしたものを使ったほうが良い。と書かれていたので、

private readonly int runParamHash = Animator.StringToHash("isRun");
という変数を用意しておき、
切り替えるときには
// WaitからRunに遷移する
this.animator_.SetBool(runParamHash, true);
みたいに書くように変更した。

------------------------------------------------

<HouseInterorMng.csの修正>----------------------

Start関数の呼び出し順序の関係で、TownMng.csから
SetWarpCanvasAndCharaController関数を呼び出した時にまだplayerController_情報がfindされてない事
があるらしい。

そのため、関数内でplayerController_のnull確認をして、nullならその場でfindするように修正した。

また、そのあとにStart関数が呼ばれると、
もう一度コントローラー情報をfindしようとするので
こっちにもnull確認を追加した。

<会話シーンから建物内を映してて、退出すると
 建物が非表示にならないバグ>

(原因)
HouseInteriorMng.csのExitButtonに、
全ての建物の内装を非表示にする処理が書かれていなかった。

(対処法)
// 建物オブジェクトの非表示(名前部分を""にすることで、全て非表示にできる)
ChangeObjectActive(this.gameObject.transform.childCount, this.transform, "");

上の文章を追加すれば解決した。

------------------------------------------------

<Toggleチェック時にクエストの説明を画面に出す>---

画面右側には最初からパネルを用意しておき、
そこに書き出す情報はトグルにチェックが入ったもの
みたいな感じにしたほうが、それぞれにパネルをつける必要もなくなるからいいかもしれない。

<QuestPrefabの変更点>
[InfomationPanel]を削除する。
→かわりにQuestUIの子として[InfomationPanel]を
　設置するから

[QuestToggle.cs]を新規作成し、[QuestPrefab]に
アタッチする。
(引数)
Toggle→Toggle

ToggleのOnValueChangedに[QuestPrefab]のアタッチ
をしてQuestToggle.OnToggleChanged関数を設定する

<QuestToggle.csの内容>
public変数でトグルの情報を持つようにする。
OnToggleChanged関数でトグルの状態を確認して
OnならQuestMng.csのSetSelectQuest関数に
自分の番号を渡す。

<QuestMng.cs>
[QuestPrefab]をインスタンス時に、[QuestPrefab]にクエスト番号を持たせるようにする。
// クエスト番号を設定する
questUIInstance.GetComponent<QuestToggle>().SetQuestNum(i);

private Text questInfoText;
という変数を新規で用意して、questUIからfindで読み込むようにstart関数に記載した。

SetSelectQuest関数で受けとったら、Excelから読み込んでおいた情報からクエスト情報をInfomationPanelのTextに書き込むようにする。

※ここまで、Excelからの読み込み以外は終了。

------------------------------------------------

<クエスト情報をExcelで作成する>-----------------
新規でExcelを作成し、
[Sheet1]を[Quest0]に変更する。

1行目に、num(int),info(string),clear(int)
というのを作成する。
今回はテストとして
num  →0,1,2
info →表示メッセージを3つ用意する
clear→すべて0にする

このExcelを[QuestInfo.xls]としてExcelDataファイルに保存する。
unity側でExcelをインポートするときに
class nameを[QuestInfo]にして他設定を行いcreate

いつもの\→/にするエラーを直してからreinportを
おして.assetファイルを作成。Resourcesファイルに
いれる。

※あとで追加で必要になるタブ[報酬][進行度]
　進行度は、画面にそもそも表示させるかとかの
　判定に必要になる

<QuestMng.cs>
TextMng.csを参考にしながらExcelデータを読み込めるようにStart関数に処理を追加する。

SetSelectQuest関数では、        questInfoText.text = popQuestInfo_.param[num].info;
という処理を行うように修正する。
※受け取ったExcelのinfo情報を代入する

<PopList.cs>
enumの数が増えてきたのでswitch文に変更
クエスト情報が来ても対応できるように追加変更

※現状では2番以降のボタンを押されるとエラー

------------------------------------------------

<トグルからボタンに変更する>---------------------
何かとトグルだと不便だったので、ボタンに変更する

[QuestPrefab]のトグル部分をButtonに変更。
また、[QuestToggle.cs]も[QuestButton.cs]に
名称変更
→これに伴い、他スクリプトでQuestToggleと
　書いているところやfindの書き方も変更すること

[QuestButton.cs]の内容もボタン用に修正する。
外部アタッチも[Button]をつけるようにする。
ButtonのOnClick()はQuestPrefabをヒエラルキーから
アタッチして、OnClickButton関数を入れる。

------------------------------------------------

<受注するボタンを用意する>----------------------
クエストを選択したあとなら受注ボタンを出現させて
クエスト受注できるようにする。

[QuestUI]の子に、[OrderButton(ボタン)]を作成。
画面右下にでてくるように調整する。

<QuestMng.cs>
questOrderButton変数を作成し、start関数から
findするように設定する。

ClickLookQuest関数に
questOrderButton.SetActive(false);
をつけたして、クエストを選択するまでは受注ボタンを非表示にしておく。

SetSelectQuest関数内でquestOrderButtonのアクティブをtrueにする。

※挨拶クエストを受けたら進行度を進める。
　受けないで他の建物に入ろうとしたら
　「今はギルドへ向かおう」と出す。
　(進行度2でギルド以外の建物に以降としたら。)

------------------------------------------------

<受注～クエストクリアまでの流れ>-----------------

とりあえず、ノートに書いた図の通りにやってみよ…

①空のゲームオブジェクトに、CompleteQuest.csを
　アタッチして、プレハブ化する。
　(ヒエラルキーからは削除)
  [CompleteQuestPrefab]

②受注ボタン押下時に①をインスタンスする。
　処理はQuestMng.csに記述する。
　ClickOrderQuest関数を作成し、中でインスタンス
　処理を書いてみる。
　
　ClickOrderQuest関数は、OrderButtonのOnClickに
　設定する。
　CompleteQuestPrefabを外部アタッチする

③CompleteQuest.csを書き換えて、
　Sceneを跨いでも消えないオブジェクトにする。
　(Awake関数内にDontDestroyOnLoad(this);と記述)

④受注ボタン押下時にインスタンスしたプレハブに
　クエスト番号を渡すようにする。

　CompleteQuest.csにSetMyNum関数を作成。
　QuestMng.csでインスタンスされた後に呼び出す。
　
　選択中のクエスト番号を保存する変数を
　QuestMng.csに作成しておく。

⑤[CompleteQuestPrefab]のタグを
　[Quest]にする。(新規作成)

⑥CompleteQuest.cs内で④の番号を使って、
　自分自身のプレハブの名前を番号に変更させる。

⑦QuestClearCheck.csを新規で作成する。
　中にリストを用意しておき、QuestMng.csで
　インスタンスしたものをそのままリストにいれる。

⑧QuestClearCheck.csに現在の受注中のクエストが
　何個あるかを確認する関数を用意する。
　受注ボタンを押したときに、その数が2以下なら
　新規受注を受け付けるようにする。

⑨Update関数で常にクリアフラグの立っているものが
　ないかを検索する(QuestClearCheck.cs)
　そのためにListをtuppleにしてboolを持てるように
　する。
　フラグがtrueならデバッグログを出力する。

-----------------------------------------------

<同じクエストが受けられないようにする>-----------
QuestClearCheck.csのCanOrderNewQuest関数に
引数を追加して、現在選択中のクエスト番号を取得する。

そして、foreach文でリスト内にあるものと同じ番号のクエストを受けようとしたらreturn falseを
返すように処理を追加した。
これで同じ数値のプレハブが複数個できることはない

------------------------------------------------

<QuestClearCheck.csと関連物の変更>--------------

QuestClearCheck.csのUpdateが呼ばれないことに気づいたため、SceneMngにアタッチするようにした。
※全てのSceneMngにアタッチしないといけない。

------------------------------------------------

<チュートリアルクエストのクリア条件を設定する>---
QuestClearCheck.csにSetBuildName関数を作成。
初回処理時に町長家とギルドとユニハウスを登録しておき、挨拶に関係のない建物を入れておく。

あとは、HouseInteriorMng.csからこの関数を呼び出して、まだ登録されていなければ登録するようにする。

登録建物が6になったら全ての建物に入ったということなのでクエストクリアフラグをtrueにする。

------------------------------------------------

<魔道具屋、書店、レストランのスクリプト作成>-----

HouseBaseを継承したScriptを作成する。
ギルドや町長の家と同じように作成して、
HouseInteriorMng.csのStart関数に

func_.Add("BookStore" , new BookStore().CheckEvent);
func_.Add("ItemStore" , new ItemStore().CheckEvent);
func_.Add("Restaurant", new Restaurant().CheckEvent);

と、登録する。

------------------------------------------------

<ギルドで0番のクエストを受けたらチャプターを2へ>-

受けた段階で進めないと、他建物に一切入れなくなる
Guild.csにGuildQuestEvent関数を作成し、
引数で受注したクエスト番号をもらい
現在の進行度とクエスト番号で進行させるか判断する

この関数はQuestMng.csのClickOrderQuest関数で
呼び出すようにする。

------------------------------------------------

<ギルド入室時に会話シーンへ飛ぶ前にボタンが見えて
 バグみたいに見えるバグ>------------------------

QuestMng.csにコルーチンを入れてButtonVisibleと
命名する。
最初にHouseInteriorMng.csで全てSetActiveをtrueに
されるが、コルーチン内でfalseにしたあと

yield return new WaitForSeconds(3.0f);

と処理を書いて3秒待機させる。
その後SetActive(true)にしなおす。

※ボタンを右から差し込む感じに今後修正する

------------------------------------------------

※ボタンを右から差し込む感じに今後修正する
チュートリアルクエスト以外非表示になるようにする

※あとで追加で必要になるタブ[報酬][進行度]
　進行度は、画面にそもそも表示させるかとかの
　判定に必要になる

*重要*
タグの判別にはgameObject.tag == “string tag”もあるが、CompareTag()の方が早い

最後に、不使用だったものは消すようにしないと。