新規に作成した、街をつくるテストのScene

ここに、さきちゃんから受け取った街のアセットを利用して作成していく。

<透過した画像をオブジェクトに貼りつける方法>-----

参照したもの↓
https://am1tanaka.hatenablog.com/entry/20120131/1328015837

①いつも通り、Pictureの画像のTextureTypeを
Sprite(2DandUI)にする

②Pictureフォルダ内にMaterialsフォルダを用意して
そこに新規でマテリアルを作成
(UnityLogoと命名)

③MaterialのShaderを
[Legacy Shaders/Transparent/Diffuse]にする

④Selectと書かれているところに、今回適用したい
　画像をアタッチする

⑤UnityLogoマテリアルを3DObjectのQuadとかに
　貼り付けたら完成

------------------------------------------------

<Terrainで地面づくり>---------------------------
参照したもの↓
①基本操作
https://qiita.com/yando/items/ef76c200bb50005170d5

②テクスチャの貼り方が変わったらしいので。
https://teratail.com/questions/173073

③草の生える量の調整について。
https://unity.moon-bear.com/3d%E3%82%A2%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8C%E3%83%A6%E3%83%8B%E3%83%86%E3%82%A3%E3%81%A1%E3%82%83%E3%82%93%E3%83%91%E3%83%AB%E3%82%AF%E3%83%BC%E3%83%AB%E3%80%8D/terrain%E3%81%A7%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8%E3%82%92%E4%BD%9C%E3%82%8B/#toc7

------------------------------------------------

<定点カメラ方式の実装>--------------------------

十字路の道で、左右の道に入ったとき、定点カメラに切り替わるようにする。
もともとCameraMng.csで切替の仕組みを用意しているため、ここを街のカメラも使えるように修正する。
UnitychanController.csの内容も追加するものが増える。

左右の定点カメラは、Unityちゃんの座標によって移動させれば、1台だけですむはず。


※往復してカメラが連続で切り替わるときにも
　不可視の当たり判定用のボックスを設置しといて、
　Exit関数通過時にそのボックスより左右どちらに
　いるかを判定してカメラの切替がありなりを決める

-----------------------------------------------

<街の定点カメラ準備>----------------------------
CameraMng.csでFindでカメラを探すようにしている所を、アタッチ方式に変更しなおす。
→どのSceneでも使えるようにするため。

CameraMng.csの、
buttleCameraという変数名をSubCameraに名前変更する

ヒエラルキーに新規カメラを追加して、
FixedPointCameraと命名する。
ヒエラルキーに空のオブジェクトを作成して、
CameraControllerと命名し、CameraMng.csをアタッチ
MainCamera→MainCamera
SubCamera →FixedPointCamera

また、FieldMng.csのnowModeの初期値をNONにし、
UtnichanController.csでのUpdate関数のreturn処理条件に、　&& nowMode != NONを追加した。

nowModeがNONということは、「街にいる」という
考え方にする！

[FixedPointCamera]
Position X:24 Y:3 Z:89

------------------------------------------------

<通過テストを始める>----------------------------

とりあえず、右通路のテストからしよう。
新規でキャラ通過確認用のCubeを追加する。
名前は、[GoThroughRight] 
Position X:19 Y:0.5 Z:95
Scale    X:2  Y:2   Z:10
BoxColliderのIsTriggerにチェックを付けておく
RigidBodyもつけて、IsKinematicにチェックする。

[GoThroughRight]につける新規Scriptを作成する。
名前は、[GoThroughCheck.cs]
このスクリプトで、キャラが通過したかを確認して、CameraMng.csにカメラ切り替えの指示を出す。

[GoThroughCheck.cs]で、
void OnTriggerEnter(Collider col)
{
    if(col.CompareTag("Player"))
    {
        Debug.Log("カメラ切替");
        cameraMng_.SetChangeFlg(true);
    }
}
という判定を行い、現在ログを出力しているところに
CameraMng.csで新規に用意したSetChangeFlg関数を
呼び出す。

これで右へ通過したときにカメラが切り替わるようになった。
-----------------------------------------------

<キャラがカメラに映らない位置に来たりする>-------

家のMeshCollider1つ1つは外して、大きいBoxColliderとかを別で用意したほうがよさそう。
カメラ替えたときに映らないところへは当たり判定で
移動できないようにしておいたほうがいい。
ヒエラルキーに追加した[House12-13Collider]という
のを参考に設定していくこと！

また、キャラのZ座標が、94以下の時には
95に設定するように[GoThroughCheck.cs]の
OnTriggerEnterに処理を追加した。

------------------------------------------------

<右の通路カメラから元のカメラに戻れるようにする>-
GoThroughCheck.csにて。

EnterとExitを使うことで、通り抜けしたときと
通り抜けずに引き返したときのカメラの処理を正しくできる。

EnterとExitでそれぞれキャラの座標を変数に入れて置き、Exitの方でExitPos - EnterPosのnormalizedの
X座標をみて、
1.0なら右への通過
-1.0なら左への通過と考えるようにした。

ただし、まだ左の住宅街の処理をつくっていないため
場合によってはまた修正をするかもしれない。

------------------------------------------------

<左の通過テストをする>--------------------------

右と同様に、[GoThroughLeft]という通過確認用の
Cubeを作成する。
Rightの方をコピーして、X座標をマイナス値にするだけでいい。
作ったCubeにGoThroughCheck.csとRigidbodyがあるのを確認しておくこと。

GoThroughCheck.csでOnTriggerExit関数に
オブジェクトの名前でカメラ位置や、SetChangeFlgの切替を分けるように処理を書いたら終了。

------------------------------------------------

<すり抜けてほしくない箇所に壁を設置していく>-----

当たり判定の精度を高めて、すり抜け防止のために
UniのRigidbodyにある[CollisionDetection]を
Continuousに変更した。

詳細は下のサイトで↓
https://ekulabo.com/rigidbody-collision-detection#outline__3

------------------------------------------------

<噴水の水について>------------------------------

噴水のアセット+StandardAssetsという中にある水のやつが必要らしい。
バージョンによってはStandardAssetsのインポート後にエラーがでるとのことなので、対処法を記載しているサイトを載せておく↓
https://nekojara.city/unity2020-standard-assets

噴水以外に水を設置するときに参考にできるサイト↓
https://xr-hub.com/archives/3452

とくにエラーはでなかった…

------------------------------------------------

<キャラが建物を貫通する>------------------------

2人で調べたところ、建物の判定で斜めの面とキャラが
当たり判定したときに貫通するようになっていると
わかった。そのため、判定位置を大きくしたり
ずらすことによって、多角面と判定が起こらないように調整して修正した。

-----------------------------------------------

<キャラの移動速度について>----------------------

斜め移動時に、速度が速くなりすぎておかしくなっていたため、UnitychanController.csに修正をいれた。

参照したもの↓
https://unity-senpai.hatenablog.com/entry/2020/10/13/010845#%E4%B8%89%E5%B9%B3%E6%96%B9%E3%81%AE%E5%AE%9A%E7%90%86%E3%81%AE%E5%BE%A9%E7%BF%92

上記のサイトで正規化して値をつくって使用する方法が書かれている。これと、もともと書いていた処理を組み合わせて

// 速度ベクトルを作成（3次元用）
var speed = new Vector3(movedir.x, 0.0f, movedir.z);

// 速度に正規化したベクトルに、移動速度をかけて代入する
rigid.velocity = speed.normalized * FieldMng.charaRunSpeed;

// 座標更新
// キャラクターを移動させる処理
rigid.MovePosition(rigid.position + rigid.velocity * Time.deltaTime);

最初のベクトル作成時にY座標を0.0fにしておかないと
障害物と当たったときに天高くunityちゃんが舞い上がってしまうから注意！

-----------------------------------------------

<Guildの室内を作成する>-------------------------
Assets/Furniture/PollyPrivattersのサンプルシーン
を一回丸コピしてきて、設置する。
カメラの角度的に映らない部分のオブジェクトを
取り除き、コライダー類を全てはずしてstaticに
すれば終了。
※ここのPrefabは魔道具屋にも使えそうなもの多い

------------------------------------------------

<Restaurantの室内を作成する>--------------------
Assets/Furniture/DiningSetのサンプルを引っ張って
くる。

壁が無いので、DarkFantasyの方から窓があるものを
持ってきてマテリアルを新規で作る
[RestauranWall]
Shader→Standard
Albedo→真っ白
NormalMap→DarkFantasiKitの、
           Steps,Floor,Ceiling/Materials/
           dfk_floor_01_normal.png

-----------------------------------------------

<BookStoreの室内を作成する>---------------------
壁のマテリアルとして、Assets/Furniture/BarChair/
Objects/Materials/Floor.mat
を利用した。

床のマテリアルとして新規に[BookStoreFloor]をつくり、Assets/Furniture/BarChair/
Objects/Materials/Floor.matをコピーして、内部の数値を調整したもの適用した。

-----------------------------------------------

<ItemStoreの室内を作成する>---------------------

ItemStoreWallというマテリアルを新規作成しました。
ワインボトル関連の棚のマテリアルの色を変更
[RusticWood]
R→0.56
G→0.37
B→0.2

------------------------------------------------

<TownMng.csを主軸とした修正>--------------------

会話文の終了後にその建物の中に画面遷移させるようにする関係で、広範囲のScriptに変更がでたので記載しておく。

[TownMng.cs]
①inHouseCanvasという外部アタッチ変数を用意した
　→HouseInteriorの子のInHouseCanvasをアタッチ

②①を使って該当する建物の室内キャンバスの表示を
　行うようにしている

③TownMng.csで該当する建物の前にキャラを飛ばす
　ようにしているが、Start関数のタイミングが、
　TownMng.cs→WarpTown.csとなっていて
　結果として直前につかったワープ座標が入るように
　なっていた。

　(解決方法)
　WarpTown.csのStart関数をInit関数と命名しなおし
　TownMng.csのStart関数内でInit関数を呼び出す
　ように修正した。
　→呼ばれるタイミングは、建物前に飛ばす処理より
　　前に必ずする必要がある

④建物内のカメラに最初からする必要があったので
　SetChangeCamera関数を呼び出すようにしていたが
　これも③と同じで、Start関数のタイミングが
　TownMng.cs→CameraMng.csとなっていた。

　(解決方法)
　そもそもCameraMng.csのStart関数を削除し、
　すべてSetChangeCamera関数を呼び出すようにした。
　※この関係で、UniHouseMng.csでも
　　cameraMng_.SetChangeCamera(false);
　　を呼び出すように修正した。

⑤室内カメラに遷移するときは、ワープ系の処理と
　キャラクター移動処理を切る必要があったため、
　HouseInteriorMng.csで新規に
　SetWarpCanvasAndCharaController関数を作成し
　これをTownMng.csでも呼び出せるようにした。
　※ただ、キャラアニメーションがnullでエラーに
　　なったため、UnitychanController.csの
　　StopUniRunAnim関数でthis.animetor_がnullかの
　　チェックをするif文をいれた。

これで会話終了後にそれまで話をしていた建物の中からスタートできるようになった。

------------------------------------------------

<ギルドのクエスト受注処理を作成する>-------------

参考サイト↓
https://gametukurikata.com/program/quest

上記サイトのように実装してから改良していく。

ギルド内に、「クエストを見る」のボタンを作成する
ヒエラルキーのHouseInterior/Guildの子に
[QuestCanvas(Canvas)]を新規作成し、更にその子として[LookQuest(Button)]を作る。※フォント変えとく

次に、プレハブにしておいた[QuestMng]も[Guild]の
子にする。(Unpackしておくこと)

<サイトからの変更点>
①ボタン操作でクエスト一覧がでるように、
<QuestMng.cs>にClickLookQuest関数を追加して
それを[LookQuest(Button)]のOnClickから呼び出すようにした。

②[QusetMng]にアタッチされている<QuestMng.cs>で
まだ非表示の[QuestUI]を取得しようとしてエラーに
なったため、外部アタッチで取得するようにした。


あとは、表示位置の座標とかをいろいろいじる。

スライドバー動かんやんけ。と思ったけど、
ちゃんとギルド内なら動く

------------------------------------------------

<ユニちゃんコントローラーの修正>-----------------

Animatorのパラメータ指定にはStringToHashしたものを使ったほうが良い。と書かれていたので、

private readonly int runParamHash = Animator.StringToHash("isRun");
という変数を用意しておき、
切り替えるときには
// WaitからRunに遷移する
this.animator_.SetBool(runParamHash, true);
みたいに書くように変更した。

------------------------------------------------

<HouseInterorMng.csの修正>----------------------

Start関数の呼び出し順序の関係で、TownMng.csから
SetWarpCanvasAndCharaController関数を呼び出した時にまだplayerController_情報がfindされてない事
があるらしい。

そのため、関数内でplayerController_のnull確認をして、nullならその場でfindするように修正した。

また、そのあとにStart関数が呼ばれると、
もう一度コントローラー情報をfindしようとするので
こっちにもnull確認を追加した。

<会話シーンから建物内を映してて、退出すると
 建物が非表示にならないバグ>

(原因)
HouseInteriorMng.csのExitButtonに、
全ての建物の内装を非表示にする処理が書かれていなかった。

(対処法)
// 建物オブジェクトの非表示(名前部分を""にすることで、全て非表示にできる)
ChangeObjectActive(this.gameObject.transform.childCount, this.transform, "");

上の文章を追加すれば解決した。

------------------------------------------------

<Toggleチェック時にクエストの説明を画面に出す>---

画面右側には最初からパネルを用意しておき、
そこに書き出す情報はトグルにチェックが入ったもの
みたいな感じにしたほうが、それぞれにパネルをつける必要もなくなるからいいかもしれない。

<QuestPrefabの変更点>
[InfomationPanel]を削除する。
→かわりにQuestUIの子として[InfomationPanel]を
　設置するから

[QuestToggle.cs]を新規作成し、[QuestPrefab]に
アタッチする。
(引数)
Toggle→Toggle

ToggleのOnValueChangedに[QuestPrefab]のアタッチ
をしてQuestToggle.OnToggleChanged関数を設定する

<QuestToggle.csの内容>
public変数でトグルの情報を持つようにする。
OnToggleChanged関数でトグルの状態を確認して
OnならQuestMng.csのSetSelectQuest関数に
自分の番号を渡す。

<QuestMng.cs>
[QuestPrefab]をインスタンス時に、[QuestPrefab]にクエスト番号を持たせるようにする。
// クエスト番号を設定する
questUIInstance.GetComponent<QuestToggle>().SetQuestNum(i);

private Text questInfoText;
という変数を新規で用意して、questUIからfindで読み込むようにstart関数に記載した。

SetSelectQuest関数で受けとったら、Excelから読み込んでおいた情報からクエスト情報をInfomationPanelのTextに書き込むようにする。

※ここまで、Excelからの読み込み以外は終了。

------------------------------------------------

<クエスト情報をExcelで作成する>-----------------
新規でExcelを作成し、
[Sheet1]を[Quest0]に変更する。

1行目に、num(int),info(string),clear(int)
というのを作成する。
今回はテストとして
num  →0,1,2
info →表示メッセージを3つ用意する
clear→すべて0にする

このExcelを[QuestInfo.xls]としてExcelDataファイルに保存する。
unity側でExcelをインポートするときに
class nameを[QuestInfo]にして他設定を行いcreate

いつもの\→/にするエラーを直してからreinportを
おして.assetファイルを作成。Resourcesファイルに
いれる。

※あとで追加で必要になるタブ[報酬][進行度]
　進行度は、画面にそもそも表示させるかとかの
　判定に必要になる

<QuestMng.cs>
TextMng.csを参考にしながらExcelデータを読み込めるようにStart関数に処理を追加する。

SetSelectQuest関数では、        questInfoText.text = popQuestInfo_.param[num].info;
という処理を行うように修正する。
※受け取ったExcelのinfo情報を代入する

<PopList.cs>
enumの数が増えてきたのでswitch文に変更
クエスト情報が来ても対応できるように追加変更

※現状では2番以降のボタンを押されるとエラー

------------------------------------------------

<トグルからボタンに変更する>---------------------
何かとトグルだと不便だったので、ボタンに変更する

[QuestPrefab]のトグル部分をButtonに変更。
また、[QuestToggle.cs]も[QuestButton.cs]に
名称変更
→これに伴い、他スクリプトでQuestToggleと
　書いているところやfindの書き方も変更すること

[QuestButton.cs]の内容もボタン用に修正する。
外部アタッチも[Button]をつけるようにする。
ButtonのOnClick()はQuestPrefabをヒエラルキーから
アタッチして、OnClickButton関数を入れる。

------------------------------------------------

<受注するボタンを用意する>----------------------
クエストを選択したあとなら受注ボタンを出現させて
クエスト受注できるようにする。

[QuestUI]の子に、[OrderButton(ボタン)]を作成。
画面右下にでてくるように調整する。

<QuestMng.cs>
questOrderButton変数を作成し、start関数から
findするように設定する。

ClickLookQuest関数に
questOrderButton.SetActive(false);
をつけたして、クエストを選択するまでは受注ボタンを非表示にしておく。

SetSelectQuest関数内でquestOrderButtonのアクティブをtrueにする。

※挨拶クエストを受けたら進行度を進める。
　受けないで他の建物に入ろうとしたら
　「今はギルドへ向かおう」と出す。
　(進行度2でギルド以外の建物に以降としたら。)

------------------------------------------------

<受注～クエストクリアまでの流れ>-----------------

とりあえず、ノートに書いた図の通りにやってみよ…

①空のゲームオブジェクトに、CompleteQuest.csを
　アタッチして、プレハブ化する。
　(ヒエラルキーからは削除)
  [CompleteQuestPrefab]

②受注ボタン押下時に①をインスタンスする。
　処理はQuestMng.csに記述する。
　ClickOrderQuest関数を作成し、中でインスタンス
　処理を書いてみる。
　
　ClickOrderQuest関数は、OrderButtonのOnClickに
　設定する。
　CompleteQuestPrefabを外部アタッチする

③CompleteQuest.csを書き換えて、
　Sceneを跨いでも消えないオブジェクトにする。
　(Awake関数内にDontDestroyOnLoad(this);と記述)

④受注ボタン押下時にインスタンスしたプレハブに
　クエスト番号を渡すようにする。

　CompleteQuest.csにSetMyNum関数を作成。
　QuestMng.csでインスタンスされた後に呼び出す。
　
　選択中のクエスト番号を保存する変数を
　QuestMng.csに作成しておく。

⑤[CompleteQuestPrefab]のタグを
　[Quest]にする。(新規作成)

⑥CompleteQuest.cs内で④の番号を使って、
　自分自身のプレハブの名前を番号に変更させる。

⑦QuestClearCheck.csを新規で作成する。
　中にリストを用意しておき、QuestMng.csで
　インスタンスしたものをそのままリストにいれる。

⑧QuestClearCheck.csに現在の受注中のクエストが
　何個あるかを確認する関数を用意する。
　受注ボタンを押したときに、その数が2以下なら
　新規受注を受け付けるようにする。

⑨Update関数で常にクリアフラグの立っているものが
　ないかを検索する(QuestClearCheck.cs)
　そのためにListをtuppleにしてboolを持てるように
　する。
　フラグがtrueならデバッグログを出力する。

-----------------------------------------------

<同じクエストが受けられないようにする>-----------
QuestClearCheck.csのCanOrderNewQuest関数に
引数を追加して、現在選択中のクエスト番号を取得する。

そして、foreach文でリスト内にあるものと同じ番号のクエストを受けようとしたらreturn falseを
返すように処理を追加した。
これで同じ数値のプレハブが複数個できることはない

------------------------------------------------

<QuestClearCheck.csと関連物の変更>--------------

QuestClearCheck.csのUpdateが呼ばれないことに気づいたため、SceneMngにアタッチするようにした。
※全てのSceneMngにアタッチしないといけない。

------------------------------------------------

<チュートリアルクエストのクリア条件を設定する>---
QuestClearCheck.csにSetBuildName関数を作成。
初回処理時に町長家とギルドとユニハウスを登録しておき、挨拶に関係のない建物を入れておく。

あとは、HouseInteriorMng.csからこの関数を呼び出して、まだ登録されていなければ登録するようにする。

登録建物が6になったら全ての建物に入ったということなのでクエストクリアフラグをtrueにする。

------------------------------------------------

<魔道具屋、書店、レストランのスクリプト作成>-----

HouseBaseを継承したScriptを作成する。
ギルドや町長の家と同じように作成して、
HouseInteriorMng.csのStart関数に

func_.Add("BookStore" , new BookStore().CheckEvent);
func_.Add("ItemStore" , new ItemStore().CheckEvent);
func_.Add("Restaurant", new Restaurant().CheckEvent);

と、登録する。

------------------------------------------------

<ギルドで0番のクエストを受けたらチャプターを2へ>-

受けた段階で進めないと、他建物に一切入れなくなる
Guild.csにGuildQuestEvent関数を作成し、
引数で受注したクエスト番号をもらい
現在の進行度とクエスト番号で進行させるか判断する

この関数はQuestMng.csのClickOrderQuest関数で
呼び出すようにする。

------------------------------------------------

<ギルド入室時に会話シーンへ飛ぶ前にボタンが見えて
 バグみたいに見えるバグ>------------------------

QuestMng.csにコルーチンを入れてButtonVisibleと
命名する。
最初にHouseInteriorMng.csで全てSetActiveをtrueに
されるが、コルーチン内でfalseにしたあと

yield return new WaitForSeconds(3.0f);

と処理を書いて3秒待機させる。
その後SetActive(true)にしなおす。

※ボタンを右から差し込む感じに今後修正する

------------------------------------------------

<クエストのExcelに、進行度欄を追加する>----------
QuestInfo.xlsにEventNumという項目を追加する。
「街の人に挨拶をしよう」には[2]を入れておくこと。
→現在の進行度が2であるだろうから。

QuestInfo.csにpublic int eventNumを追加する。
QuestInfo_importer.csの64行目付近に、
cell = row.GetCell(3); p.eventNum = (int)(cell == null ? 0 : cell.NumericCellValue);
を追加する。

<QuestMng.cs>
totalQuestNumを、QuestInfo.xlsの数に合わせる。
Start関数内で
totalQuestNum_ = popQuestInfo_.param.Count;

totalQuestNum_の数でfor文を回して、現在の進行度番号以下のクエスト数を一時変数に入れて記録する。

そして、totalQuestNum_の数でクエストボタンを作成していた場所を、一時変数の数で作成するように修正
→これで、まだ受けられないクエストが発生しないよ
　うにできる。

------------------------------------------------

<クエストのクリア報告ができるようにする>---------

QuestCanvasに[ReportQuest(Button)]を作成する。
文字は「クエストを報告」と打ち込んでおく。

<QuestMng.cs>
新規で[ClickReportQuest]関数を作成し、
[ReportQuest(Button)]のOnClickで呼ばれるように設定しておく。

関数内でCanvasの表示/非表示切替処理を行う

今のままだと、クエストを受注するのか報告するのか判定ができない
→enumを作成し、今どのボタンの処理中かがわかるよ　うにする

NOWPAGEというenumを作成した。
それぞれボタン押下時にenumの状態を変更するように記述し、SetSelectQuest関数で受注ボタンを表示する
のはLOOK_QUEST中だけという風にif文を追加した。

<報告するボタンの作成>
QuestUIの子に[ReportButton(Button)]を作成する。
「報告する」とテキストに入れておき、
CliclReportButton関数を作成しておいてOnClickに
設定する。

(ClickOrderQuest->ClickOrderButtonに名称変更)

questOrderButton_変数と同様にquestReportButton_
を作成し、表示/非表示切替をする

<QuestClearCheck.csの修正>
Update関数でフラグがtrueになっているものを発見したら、受注中リストからクリア済み用のリストへ移動させるようにする。

①clearedQuestsList_というリスト変数と、
　deleteNum_という削除予定番号を入れる変数を作る

②Update関数でフラグがtrueの要素があれば
　deleteNum_に代入する

③deleteNum_が初期値(-1)でない場合は、削除番号と　一致している名前のオブジェクトをリストから探し　出して、clearedQuestsList_にコピーした後、
　orderQuestsList_から削除する

リストの要素の削除方法の参考サイト↓
https://light11.hatenadiary.com/entry/2019/10/14/215209

<クエストを報告するボタン押下時の処理>
QuestClearCheck.csにGetClearedQuestsList関数を
用意しておき、QuestMng.csのClickReportQuest関数内で、クリアしたクエストのボタンを表示させる。

<ClickReportQuest関数での処理内容>
①クリアしたもののボタンが上に来るように、
　ヒエラルキー順を並び替える

②1度全てのボタンを表示にする

③クリアしたクエスト以外は非表示へするから
　for文でクリア個数以上のクエストは非表示にする
→①でヒエラルキー順を並び替えているから、
　個数を見てオーバーしたクエスト分を非表示にする
　だけで大丈夫になっている

※もし並び替えをしていなかったら、
　クリアしてないクエストが表示状態のままだったり
　クリアしたクエストが非表示状態にされたりする
　可能性がある

<ClickReportButton関数での処理内容>
最後に、達成報告ボタンを押したらクリアリストから
削除する処理を行う。

QuestClearCheck.csに、SetClearedQuestsList関数を
用意して、Updateに記載しているのと似た削除処理を
入れる。

引数に削除番号を入れれるようにしておき、
QuestMng.cs側ではそこにquestNum_を入れれば
たぶん大丈夫。

このときに、staticで生成していたプレハブも削除したほうがいいから、
タグ+番号で探してDestroyしてnullをいれる。

あと、報告したクエストは非表示組にいれないと
いつまでも画面にボタン表示が残ってしまう。
→さっきつくったClickReportQuest関数での処理内容
　という内容のところを、ClearQuestUpdate関数とし　て別の関数に切り分けて
　ClickReportQuest関数とClickReportButton関数の
　両方で呼び出せるようにしたら解決した。

これでクエストのクリア報告ができるようになった。

------------------------------------------------

<クエストの戻るボタンを設置>--------------------
仮の画像で戻るボタンを設置する。
QuestUIの子に[BackButton(Button)]を新規追加。

QuestMng.csにもClickBackButton関数を追加して、
OnClickに設定する。

questOrderButton_変数等と同様にfindしておいて
押下時には前の画面に戻るようにする。
また、LOOK_QUESTとREPORT_QUEST画面では表示状態に
しておき、NONのときは非表示にしておく。

------------------------------------------------

<ボタンUIアニメーションをつける>-----------------

InHouseCanvasの子につけていたExitButtonを、
QuestCanvasの子に持ってくる
→まだGuildのExitButtonのみ移動させておく

QuestCanvasに、金曜日に学校で作成した
UIMove.csをアタッチする。

QuestMng.csのコルーチンでCanvas表示を遅くしている
のを削除する

------------------------------------------------

<挨拶周りクエスト達成後のギルド会話を作成する>---

ギルドで達成報告をした後に発生する会話をExcelの
チャプター6として作成。

Chapter_importer.csに"6"を追加してreimportする。

QuestMng.csのClickReportButton関数内で
GuildQuestEvent関数を呼び出すようにする。

GuildQuestEvent関数に
EventMng.GetChapterNum() == 6 && questNum == 0
のif文を追加する。

いまのままではクエストを受けたときに発生する会話なのか達成したときに発生する会話なのかが見分けつかないので、GuildQuestEvent関数の引数にboolを
追加する。

boolのデフォルトはfalseにしておいて、
trueのときだけ引数にtrueをいれるようにする。

会話後はUniHouseのシーンに飛ばす予定だから、UniHouse.csを作成して
HouseInteriorMng.csのfunc_に登録する。

※最初から通しでプレイしてデバッグする

------------------------------------------------

<UIMove.csの修正>-------------------------------
ギルドに2回目以降入ったときに、ボタンが右から差し込まれるやつが発生しなかった。

(原因)
初回で中央に来た座標で止まっているから

(対処法)
UIMove.csのStart関数で、初期位置を右画面外にしておく必要がある。

<UIMove.cs>
Start関数にしていたところをOnEnable関数にして、
表示状態になったら毎回差し込まれるようにした。

コルーチンの時間や、子供の座標を毎回設定しなおす
ように修正した。

------------------------------------------------

<挨拶クエスト達成後の会話の後に進行度7にしたい>--
Chapter.xlsに新規で項目を増やすしかなさそう。
messageの横にeventNumを追加する。

Chapter6のタブで、
name1がSceneの所のeventNumに[7]をいれる。
※他の進行度が進まないところには[-1]を入れる。

<ChapterList.cs>
public int eventNumを追加する。
<Chapter_importer.cs>65行目
cell = row.GetCell(4); p.eventNum = 
(int)(cell == null ? 0 : cell.NumericCellValue);

<TextMng.cs>
ChangeScene関数の中で、eventNumが[-1]以外なら
EventMng.csを呼び出して設定するように処理を追加。

これで、進行度が[7]の時にユニが家に帰ったときの処理を書けるようになる。
※InHouseAndUniHouse.txtへ記載していくよ

------------------------------------------------

<QuestInfo.xlsの修正>---------------------------

num:1の所を、
info　　→ギルドテストへ挑戦！
eventNum→8

また、num:2のeventNumを9にずらしとく

------------------------------------------------

<クエスト関連の大幅修正>------------------------

そもそもバグとして、『クリア報告時にヒエラルキーの順序を入れ替えたら、再び受注するときに中身とボタン番号が一致しなくなる』という事態が発生してた

それを修正して、ついでにクエスト受注後は
受注中のクエストがリストに残らないようにする。
というのを実装した。

QuestClearCheck.csにGetOrderQuestsList関数追加

<ここからすべてQuestMng.cs>
①ClickLookQuest関数で、
　受注中のクエスト+報告待ちのクエストを合体させた
　リストを作成する

②QuestUIと、その子供の全部のクエストボタンを
　一度表示状態にする

③①のリストとボタンすうで2重for文を回し、
　リスト内にある＝再び受注できる状態ではない
　という判断の為、クエストボタンを非表示にする

つぎに、クエストクリア報告時処理
①ClearQuestUpdate関数で
　QuestUIは表示状態にし、その子供の全部のクエスト　ボタンは全て非表示にする

②QuestClearCheck.GetClearedQuestsList()で
　リストを取得してきて、リストに載っていたら
　報告ができるということだから、クエストボタンを
　表示状態にする

------------------------------------------------

<クエスト達成回数を記録する>---------------------

QuestMng.csに新規でmap変数を用意し、
キーにクエスト番号,値に達成回数を入れるようにする

継続してカウントしないといけないから、static変数
にする。

初回だけ0初期化が必要だから、
Start関数内で、Countが0のときだけAddするように
しておく。

あとは、クリアするたびにカウントを増やしていけば
いいのでClickReportButton関数で
questClearCnt_[questNum_]++;
とする。

------------------------------------------------

<QuestInfo.xlsからメインかサブか取得可能にする>--

QuestInfo.xlsに新規項目として[type]を追加する。
そこで[main]か[sub]かを記入する。

QuestInfo.csにpublic string type;を追加する。
QuestInfo_importer.csの65行目に
cell = row.GetCell(4); p.type =
(cell == null ? "" : cell.StringCellValue);
を追加してreimportする。

一度クリアしたメインクエストは複数回クリアできないようにするために、
ClickLookQuest関数に
popQuestInfo_.param[k].type == "main" && questClearCnt_[k] >= 1
という条件式の処理を書いて、該当するときは非表示にするようにした。

------------------------------------------------

<進行度2でユニハウスからタウンへ行くと、
 ギルド内に強制転送バグ>------------------------

(原因)
TownMng.csで会話シーンから戻ってきてるのか、
ユニハウスから来てるのか判断がついてない

(解決策)
TownMng.csで
if(str != "Mob")の処理に入ったときに、
最後の行で
SceneMng.SetHouseName("Mob");
を追加して、2回目以降は室内に飛ばされないように
した。

------------------------------------------------

<時間経過と空の色を合わせる>---------------------

新規ファイルの[SkyBox]にスカイボックスマテリアルを2つ入れた。

学校で作成したSkyBoxColor.csを各ディレクショナルライトにアタッチして、引数に[SkyBox]フォルダにあるマテリアルをアタッチするように変更。

あとは、SkyBoxColor.cs内の数値を微調整して
SceneMng.csから受け取った時間帯に合わせて
マテリアルの切替や値の入れ替えを行うだけ。

------------------------------------------------

<夜のTownとユニハウスのシーンにライトを置く>-----

Townの方は街頭とか建物にライトを置いて、
ユニハウスの方はDecorationに街頭を追加してから
ライト設置。

※図書館と魔道具屋の外見にライト1つ追加

魔道具屋のShaderがDiffuseのせいだと思うが
建物にライトが当たっても反射しない。
→Standardにしたらなんかおかしくなる。半透明??

魔道具屋の机の上にあるcrystalフラスコ(赤いやつ)が
おかしくなってた。プレハブから入れなおしたら治ったけど、さきちゃんのほうではどうだろうか？要確認

<TownMng.cs>
Start関数で、今が夜であれば、ライトを点灯させて
夜以外なら消灯するという処理を追加する。

シリアライズフィールドで外部アタッチ変数を作成し
NightLampLightsをアタッチする。
※このとき、NightLampLightsは非表示状態、
　その子供は全て表示状態にしとく。

<UniHouseMng.cs>
TownMng.csと同様に
シリアライズフィールドで外部アタッチ変数を作成し
NightLampLightsをアタッチ。
Start関数で、今が夜であれば、ライトを点灯させて
夜以外なら消灯するという処理を追加する。

------------------------------------------------

<DontDestroyCanvasにTimeCanvasを含める>---------
削除されないキャンバスものとして扱いたいので
含める事にした。

キャンバスの機能はいらないので空のオブジェクトに入れて中身を移動させる。

[TimeGear]という空のオブジェクト作成
そこに[Panel]と[Image]を子として追加。

TimeGear.csのAwake関数にあるFindを変更しないと
nullでエラーになる。

これでPrefabフォルダにパッケージしなおす。

------------------------------------------------

<会話から街に戻ってきたときに、TimeGear.csで
 エラーが発生する>------------------------------

(原因)
不明。
target = Quaternion.Euler(new Vector3(0.0f, 0.0f, rotateTimeGearMap_[SceneMng.GetTimeGear()]));でエラーがでる。。。

(対処法)
でるときとでないときがあるからまだわかってない

------------------------------------------------

<クエスト内容を詳細化>--------------------------

今は題名しかないから、詳細を書く

題名の部分のテキスト名を[TitleText]にする
※ヒエラルキーの方も変える
　HouseInterior-Guild-QuestMng-InfomationPanel
  -Textの部分

InfomationPanelに[DetailText]を追加する。

QuestInfo.xlsに[detail]という項目を追加する。

[QuestInfo.cs]
public string detail;を追加する。

[QuesInfo_importer.cs]
cell = row.GetCell(2); p.detail = (cell == null ? "" : cell.StringCellValue);
を追加する。

[DetailText]
Pos X:-160 Y:200 Z:0
FontSize:32

------------------------------------------------

<ステータス画面の調整をする>---------------------

アトリエ風ゲームフォルダに入れたステータス画面参考画像をみて、同じように配置していく
※まずはユニの画面分だけ

StatusInfoのX座標を300,Y座標を120にして、
そもそもの表示範囲枠(黄色い枠)をもう少し広げる。

立ち絵を用意する。
2Dの立ち絵をステータス値の左側に描画させるように
する。
portrait_kohaku_01_.pngをUni.pngという名前にして
Pictureフォルダに入れる。

StatusMngに[CharaImage(Image)]を用意して、
試しにUni.pngを入れてみる。
もともとのサイズがでかすぎたからペイント3Dで縮小
→縦横のパーセントを20%にする
(505*638)

[CharaImage]
Pos X:-8.5 Y:-98 Z:0
Width:505 Height:638

立ち絵の足部分が切れているから、下を模様か何かで
隠したほうがいい。
新規でStatusMngに[Panel(Panel)]を用意する。
[Panel]
アンカーポイント:中央
Pos   X:105 Y:-320 Z:0
Scale X:11  Y:1    Z:1
α値:0.698
(0.7にしようとしたら勝手にこの数値になる)

上部にも同じようにパネルを設置したいから複製して
PosYを320にする。

左側にキャラ切替用のボタンを設置する
[Topics]を複製してStatusMngの子にする。
[Topics]
Pos   X:-330 Y:235 Z:0
Scale X:0.7  Y:0.7 Z:1

[LeftBtn]
Pos   X:-100 Y:-20 Z:0
Scale X:0.7  Y:0.7 Z:1

[RightBtn]
Pos   X:300  Y:-20 Z:0
Scale X:0.7  Y:0.7 Z:1

アイテムとかそざいとかワードの切替と同じ要領で
やりたいから、ItemBagMng.csのOnClickLeftArrowと
OnClickRightArrowの関数に追加させてもらう

矢印の内容を切り替えたいから、
MenuActive.csのSelectCanvasActive関数のキャンバス状態を保存できるようにして、矢印の処理を切替れるようにしたい。

[MenuActive.cs]
新規で、private CANVAS nowCanvas_;を用意して
SelectCanvasActive関数で
nowCanvas_ = canvas;とする。
GetNowMenuCanvas関数を作成してreturn nowCanvas_;
とする。

[ItemBagMng.cs]
ステータス用のInit関数を別で作ったほうがよさそう
→StatusInit関数作成してMenuActive.csでステータス
　のときはこのinitを呼び出すようにする。

(どちらのInitでも行う処理)
menuActive_がnullならMenuActiveのついているSceneMngをFindする

OnClickRight/Leftそれぞれに現在のメニューがBAGか
STATUSかで処理を分けるようにする。

※Init関数は複数回呼ばれるのでnull処理をいれた方
　が処理回数を減らせる。

<矢印を押すとキャラ名が変わるようにする>
まず、そもそもキャラ名が入るようにする。
[ItemBagMng.cs]
charaNameTopicText_;
charaStringNum_;
charaTopicString_;
の変数を追加する。
StatusInit関数に処理をいれる。

あとはOnClickRight/Left関数でcharaStringNumの
増減処理をおこなう。

<キャラ名が変わったときに各キャラのステータス値
 がでるようにする>
STATUSで呼び出しているViewStatus関数を、ItemBagMng.csから呼び出すように変更する。
ViewStatus関数に引数でint charaNumを用意して、
publicにしておく。

ItemBagMng.csの
StatusInit関数で
menuActive_.ViewStatus(charaStringNum_);
を呼び出し。
OnClickRight/Left関数でも同様に呼び出す。

<ジャックの立ち絵に切り替わるようにする>
[ItemBagMng.cs]
立ち絵の切替をシリアライズフィールドのprivateで
外部アタッチするようにする。
※配列数を[2]にして[Uni.png][Jack.png]の順に
　アタッチする

charaStringNum_に合わせて立ち絵が変わるように、
charaImg_.sprite = CharaImage_[charaStringNum_];
とする。

新規でcharaImg_変数をつくり、findでCharaImageを取得する。

portrait_jack_01.pngを[Jack.png]として
Pictureフォルダに入れる。
(408*750)

画像に合わせて台紙側のサイズを変更しないとだめ。
private RectTransform charaImgRect_;変数を
用意し、StatusInit関数とOnClickRight/Left関数に

charaImgRect_.sizeDelta = new Vector2(CharaImage_[charaStringNum_].rect.width, CharaImage_[charaStringNum_].rect.height);
というのを追加する。

<ジャックがパーティに入るまで切り替えられないよう
 にしておく>
進行度番号が8になったときにジャックのステータスが
表示できるようにする。
→chapterNumを7にしてギルドに入り、会話して
　クエスト受けた後にステータス画面を開いたら
　ジャックのステータスも見れるようになる。

------------------------------------------------

<クエスト報告時にハンコが押される表現をする>-----

学校から持ち帰ってきたデータにCanvas.prefabと
Picture/test.pngがあるからそれを使って実装する。

まずはCanvasの内容をギルドの台紙に移動させる。
Guild/QuestMng/QuestUI/InfomationPanelに、
[RectMask2D]をアタッチする。
そして、その子として[Stamp]をアタッチして、
Imageをtest.pngにする。

[Stamp]
アンカーポイント:右下
Pos X:-65 Y:120 Z:0
Width:315 Height:309
Scaleは全て1

とりあえず最初からスタンプ押下状態にはなった。

次に、クエスト報告ボタンが押された時だけ出てくるようにする。

[QuestMng.cs]
private Image stampImg_変数を作成する。
Start関数内でFindする。
ClickLookQuest関数やClickReportQuest関数では、
関数の最後尾で
// ハンコを非アクティブにする
stampImg_.gameObject.SetActive(false);
そして、ClickReportButton関数では、
// ハンコをアクティブにする
stampImg_.gameObject.SetActive(true);
にする。

------------------------------------------------

<クエストクリア報酬について>---------------------
まず報酬内容をクエストの紙に記載するようにする。
そのために、QuestInfo.xlsに報酬の欄を追加する。

rewardという項目を追加して
各クエストに報酬を記入する。

<QuestInfo.cs>
public string reward;を追加する

<QuestInfo_importer.cs>
67行目に
cell = row.GetCell(6); p.reward = 
(cell == null ? "" : cell.StringCellValue);
を追加する。

これで報酬内容を読み込めるようになった。

QuestMng/QuestUI/InfomationPanelの子に、
[RewardText(Text)]を追加する。
[RewardText]
Pos X:-160 Y:-30 Z:0
Width:160 Height:30

[QuestMng.cs]
private Text questInfoText3_;
という変数を作成する。

Start関数で
questInfoText3_ = questUI.transform.Find("InfomationPanel/RewardText").
GetComponent<Text>();
とする。

SetSelectQuest関数に、
questInfoText3_.text =
"報酬\n" + popQuestInfo_.param[num].reward;
を追加する。

これでクリア報酬の内容を表示することができた。

<もっと報酬受け取りを目立たせたい>
ForestFieldで実装したポップアップをもってくる。
QuestUIの子として
PopUp -BackImage,TitleBackImage,GetReward,TitleInfo
という階層で実装する。

[QuestMng.cs]
private GameObject popUpReward_;と
private TMPro.TextMeshProUGUI rewardText_;
という変数を作成。

Start関数でFindする。

ClickReportButton関数で報酬内容を記載したあとに
ポップアップをアクティブにする
rewardText_.text =
popQuestInfo_.param[questNum_].reward;
popUpReward_.SetActive(true);

ポップアップ内容は時間経過でfalseにしたいから、
FieldMng.csのPopUpMessage関数をもってきて
ClickReportButton関数でコルーチンを呼ぶようにする

------------------------------------------------

<ポップアップのα値とか決めたい>-----------------
ほわんとだしてほわんと消したい。

新規でα値を調整するScriptを作成したほうがいい。
[AlphaChange.cs]というスクリプトを作成して、
PopUpにアタッチする。

[AlphaChange.cs]
3つのprivate変数を用意する。
private float alpha_ = 0.0f;
private float alphaChangeSpeed_ = 0.01f;
private (GameObject,bool)[] chiledObj_;

OnEnable関数内でalpha_変数を初期化し、
chiledObj_変数の設定をfor文内で行う。
→ここのfor文内でcolorの設定を(1,1,1,0)にして
　α値を0にする。

最後の行でコルーチンを呼び出す。
(PopUpAlpha関数)
alpha_変数が1.0fより小さい間はwhile文を回り続ける
内部ではalpha_変数を加算しつつ、ImageとTMProの見分けをboolでして、値を変更する。

<ForestFieldのPopUpにつけたらエラーでたわ>
(原因)
ImageでもTMProでもないやつがelseに入ってたから。
(対処法)
α値の加算を飛ばす子供の番号を入れるリストを作成する。

private List<int> notAlphaChangeList_ =
new List<int>();を用意する。

OnEnable関数でelseにきたものをAdd(i)とする。

コルーチンのfor文でnotAlphaChangeList_にいれた数字と一致したiならbreak処理をする。
→さらに、breakに入ったときにtmpFlgをfalseにして
　falseならα値加算処理に入らないようにif文を
　つける。

------------------------------------------------

<他の報告クエストを押したときにハンコが消えない>-

[QuestMng.cs]
SetSelectQuest関数のelse ifにある
REPORT_QUEST内に、ハンコを非アクティブにする処理を追加する。

ハンコの画像の名前を
[Stamp.png]に変更する。
------------------------------------------------

<チュートリアルクエスト達成報告後にChapter9の
 会話を発生させる>------------------------------
※Chapter8で回復アイテムをジャックから受け取る
　会話を追加する。
まずは会話文の作成。
[Chapter_importer.cs]
"9"を追加する。

[Guild.cs]
GuildQuestEvent関数に、
GetChapterが9でクエスト番号1をクリアしたら
チャプター9の会話が発生するように処理を追加。

デバッグ完了。

※報酬のポップアップが終わってから会話に遷移でき
　たほうがいいかも

[QuestMng.cs]
PopUpMessage関数でwhile文が終わったあとに
guild_.GuildQuestEvent(questNum_, true);
を呼び出すように変更する。
→ポップアップ中に外に出られたら次の会話文へ
　進めないので、PopUpMessageのtime >= 1.5f
  にする。

また、時間を夜にして、次の日へ進めるようにする

------------------------------------------------

<アイテム&魔法クエストを発生>-------------------

ポーションの納品クエスト発生の会話と、
町長からのクエストとして入手したワードで
炎のマテリアを作成するクエストが出たことを会話
させる。

[Guild.cs]
CheckEvent関数で、現在のチャプターが10で時間が朝
のときに会話を発生させる。

※合成のチュートリアル

<Chapter.xls>
Chapter10の会話内容を作成する。

[Chapter_importer.cs]
"10"を追加する。

<QuestInfo.xls>
num 2,3を作成する
2にアイテム納品
3に魔法作成を作成する。
どちらもeventNumを11にする。

EventMngを10にして確認済み
2つともクリアしたら次へ話を進めるようにしないと
いけない。

<2つのクエストのクリア回数が1になったらイベントを
 進めて会話を発生させる>
num2,3のクリア回数が1になったらChapter11の会話を
発生させる。
[Guild.cs]
GuildQuestEvent関数の引数にDictionary<int, int>
を追加する。
questClearCnt_変数を受け取って、
その中のクエスト番号2,3が両方とも1なら会話を発生させる。

// クエスト2,3番のクリア状態が1以上であるとき
if(clearNum[2] >= 1 && clearNum[3] >= 1)
{
　SceneMng.SetTimeGear(SceneMng.TIMEGEAR.NOON);  
  EventMng.SetChapterNum(11, 　　　　　　　　　SceneMng.SCENE.CONVERSATION);
}

あとは、クエスト後の会話を作成するだけ。
<Chapter.xls>
Chapter11の会話内容を作成する。

[Chapter_importer.cs]
"11"を追加する。

------------------------------------------------

<「水」のワード探しクエストを発生させる>---------
オアシスの水をもとにもどせみたいな
水のエレメントの話にして、
クリアするまでは水と周りの木を非表示にする。
→Oasisという空のオブジェクトにまとめて、非表示へ

<QuestInfo.xls>
num 4
info オアシスを甦らせて
detail オアシス枯れたから原因調査しようね
clear 0
eventNum 12
type main
reward とりあえず3000バイト

アイテム作成と魔法合成のイベント後に表示されるか
確認する。

<受注直後に会話イベントをはさむ>
<Chapter.xls>
Chapter12の会話内容を作成する。

[Chapter_importer.cs]
"12"を追加する。

[Guild.cs]
GuildQuestEvent関数に、
オアシス復興のクエストを受注したタイミングで
会話を発生させる。
※会話後に進行度が13になるので、
　13になったらField2を選択できるようにしてもらう

------------------------------------------------

<フィールドからどこかへ移動するタイミングでは
 時間経過をはさむようにする>---------------------

①フィールドから街
②フィールドからユニハウス
③フィールドからフィールド
この3種類の移動時には、時間を経過させる

[SceneMng.cs]
SetNowScene関数で、sceneでnowSceneを上書き前に、今まで動いていたシーンがフィールドであれば時間経過させる。

あとは、SetTimeGear関数で夜なら朝にし、
それ以外は通常通り時間経過させるようにif文処理を
かく。

------------------------------------------------

<ギルドのボタンを変更する>----------------------
デフォルトのボタンから[InHouseButton.png]に変更
※UniHouseSceneも同様に画像変更する。

ついでに文字フォントもTextからTMPに変更していく
FontSize:15
Alignment:両方とも中央にする
(QuestCanvasを一時保存ファイルで更新)

さらについでに建物名の表示位置も調整していく
右上を原点にして
Pos X:455 Y:270 Z:0
全ての建物に関して
(InHouseCanvasとUniHouseを一時保存ファイルで更新)

クエストボタンも変更する
(QuestPrefabをプレハブフォルダで更新)
TMPのTextにするからQuestMng.csでFindの部分を処理変更が必要
[QuestPrefabのButton]
Pos   X:30 Y:0 Z:0
Scale X:1.5 Y:1.5 Z:1

<クエストのタイトル名を変更する>
今は「クエスト+番号」になってるから
ここを各クエストのタイトル名に変更する

toggleTextCom.text =
　　　　　 popQuestInfo_.param[i].info;
とする。

ただ、このままでは文字数を超えたときに段になってしまうから、最初の5文字だけ表示して
あとは「・・」にしたい。

// 5文字以上のタイトル情報のとき
if(popQuestInfo_.param[i].info.Length >= 5)
{
   // コンポーネントを取得して情報を反映させる
   questUIInstanceList_[i].Find  ("TitlePanel/Button/Text").
  GetComponent<TMPro.TextMeshProUGUI>().text =
  popQuestInfo_.param[i].info.Substring(0, 5) 
  + "・・";
}
else
{
   questUIInstanceList_[i].Find   ("TitlePanel/Button/Text").
   GetComponent<TMPro.TextMeshProUGUI>().text =
   popQuestInfo_.param[i].info;
}

<受注/報告ボタンも変更する>
ボタンの色は他と違うほうがいいから
赤っぽいのをPictureフォルダに追加して
「SomeButton.png」と命名する。

一時保存ファイルに
OrderButtonとReportButtonをいれる。

さいごに、
もともと使用していなかったQuest.csを削除する

------------------------------------------------

<ポーションクエストと
 魔法作成クエストのクリア判定を作成>---------------
納品クエストのときには、どのアイテムを納品するか選択できるようにしないといけない。
→「成功」のアイテムなのか、「大成功」のアイテムな　 のか
※そもそも、今、成功と大成功の同種類アイテムは
　別々で鞄に入っているのかわからない。


進行度を11にしてギルドに入る。
とりあえず順番にゆっくり考えるべし。。。

<ポーション納品クエスト>
まずは成功/大成功を区別せずに考える。
プレイヤーに任意でアイテムを選択してもらえるように
画面上に鞄みたいな枠をだして、納品可能アイテムを
表示するようにする。

アイテム画像をクリックして、個数を指定して、確定ボタンを押したら個数を確認してクエスト達成状態に移行するようにする

そもそも別ウィンドウを出すかどうかとかの判断をするために、クエストタイプみたいなenumがあった方がいい

納品 delivery(0)
討伐 Subjugation(1)
その他(ほとんどのメインクエスト) other(2)
これらをQuestInfo.xlsに
新項目(questType)として追加する
→現在あるクエストのうち、ポーションを届けてだけ0に
　して、他は全部2とする

また、何を納品するかもExcelから読み込めるようにしとかないといけない。
名前を使えるはずだから項目でdeliveryを追加し、
HPポーション(小)と入力しておく。

[QuestInfo.cs]
public int questType;
public string delivery;
を追加する。

[QuestInfo_importer.cs]
cell = row.GetCell(7); p.questType = (int)(cell == null ? 0 : cell.NumericCellValue);
と、
cell = row.GetCell(8); p.delivery = (cell == null ? "" : cell.StringCellValue);
を追加する。

[QuestMng.cs]
enumでQUESTTYPEを作成する。

ClickOrderButton関数の中で受注できたときに、
そのクエストのタイプを見て、0(=納品)かどうかみる。

0以外だったら今まで通り受注するようにelse側に書いて
0だったら、納品画面みたいなのを用意してそれを表示。

QuestUIに[DeliveryPanel(Panel)]を追加する。
[DeliveryPanel]
アンカーポイント：中心
Width:750,Height:500

ImageのColor(R:1 G:0.97 B:0.47 A:1)
非表示にしておく。

private GameObject deliveryBack_;を作成して、
Start関数で、deliveryBack_ = transform.Find("QuestUI/DeliveryPanel").gameObject;
とする。

納品クエスト受注時にSetActiveをtrueにする。
ここに、自分の持っているアイテムで納品に該当するアイテムを所持している場合は画面上にアイコン表示するように設定する。

自分が所持しているアイテムはBag_Item.csから見れる。
itemState変数
画像はPrefabフォルダにあるItemBoxが使えそう。
動的に生成しようかと思ったけど、よく考えて。
納品してほしいアイテムは1種類であることを考えたら、
その1種類の成功or大成功の2つのボックスで足りる。
→DeliveryPanelの子として2つItemBoxを付けたらok

[ItemBox]
Pos X:-285 Y:150 Z:0

[ItemBox(1)]
Pos X:-100 Y:150 Z:0

この2つのアイテムボックスに手持ちの情報をいれないと
いけない。

private GameObject[] deliveryItemBox_ =
new GameObject[2];
を用意して、
Start関数で
deliveryItemBox_[0] = deliveryBack_.transform.Find("ItemBox").gameObject;

deliveryItemBox_[1] = deliveryBack_.transform.Find("ItemBox (1)").gameObject;

とする。

納品クエストだったときの処理に、
所持アイテム数でfor文を回して、納品アイテムと名前が一致しているものを見つけたら
deliveryItemBox_[0].transform.Find("ItemIcon").GetComponent<Image>().sprite = Bag_Item.itemState[i].image.sprite;

deliveryItemBox_[0].transform.Find("ItemNum").GetComponent<Text>().text = Bag_Item.itemState[i].cntText.text;

という処理をするようにしておく。

※ItemNumは未所持だった時を考えて最初のテキストを
  0にしておく(プレハブのままだったら99になってる)

スライドバーみたいなのを作って、
納品個数を決められるようにしたい。

ItemBoxの子として[Slider(Slider)]を追加する。
[Slider]
Pos X:0 Y:-100 Z:0
Scale X:1 Y:1.5 Z:1
FillのColorを青っぽくする

SliderのValueを取得して、Sliderの下に現在納品しようとしている数を表示するようにしたい。

ItemBoxの子として[DeliveryNum(Text)]を追加する。
[DeliveryNum]
Pos X:0 Y:-125 Z:0
FontSize:48
Alignment:左の設定を中央にする
Overflowにしとく。

納品を決定、もしくは、やめるのボタンを押すまで
コルーチンが回るようにしておいて
その中でValueの取得とか最大値の変更とかしたい。
※Bag_Item.csの所持数を5にしてテストする

コルーチンを作成する。
コルーチンの中で、現在のSliderのvalueを
DeliveryNumに反映させる処理をまずは書く。
※floatになっているので、WholeNumbersにチェックしてintに直すこと！
スライダーのmax値を現在所持しているアイテム数にする
→ただし、納品数 < 所持アイテム数ならば
　納品数がmax値の優先になるようにしたい。

納品をクエスト情報から取り出す必要がある。
string str = Regex.Replace(popQuestInfo_.param[questNum_].detail, @"[^0-9]", "");
として、infoから納品数字を取り出す

あとは、アイテム画像の右下の所持数を
スライダーが増える分だけマイナスしていく。

次に、納品確定ボタンをつくる。
DeliveryPanelの子に[Button(Button)]を作成する。

[Button]
Pos X:0 Y:-200 Z:0
Scale X:2 Y:2 Z:1
画像はSomeButton

[Buttonの子のText(TMP)]
FontSize:15

確定ボタンは、成功と大成功のスライドバーのvalueが
納品数と同じときにしか押せないようにする。
→α値を0.5にしておいて押せない感は出しとこ
　ぴったりのときには押せる感出しとこ

やめるボタンの処理をつくる。
DeliveryPanelを非表示にすればokだとおもう。

大成功のバーとか数字もつくる。

<確定ボタンの処理をつくる>
[QuestMng.cs]
ClickKakuteiButton関数を作成する。
ButtonのOnClickにQuestMngにアタッチして
ClickKakuteiButtonを呼び出すようにする。

button.interactableを
納品数がぴったりのときにtrue
合わないときにfalse
としてボタンを押下できないようにする

確定ボタンを押したら
納品するアイテム分手持ちから減らして
コルーチンを止める。
→ただStopするのではなくて完全に初期化させる
そしてパネルを非表示にしてクエストをクリア状態にする。

※戻るボタン押したときにスライダーのvalueが0に
　初期化されるようにしておく。

やめるボタンの作成
納品をやめるときに押すボタン。
パネルを非表示にするだけでok

<Backボタンもついでにデザイン修正する>
茶色い丸枠の中に▽矢印をいれて、戻れそうな雰囲気をだす。設置位置も画面左下にする

<魔法作成クエストのクリア判定>
Bag_Magic.csにあるmagicObject変数が現在プレイヤーが持っている魔法。
①クエストを受けた時点ですでに魔法を所持している
②後から魔法を作成した場合

この両方でクエストクリアの確認をする必要がある。

①の場合、
numが3のとき、Bag_Magic.csにあるmagicObject変数でfor文を回してMagic_番号の番号部分を見る。
ここに1があれば炎単体小魔法なのでクリア状態にする。

また、空白だったら抜ける処理も追加しておく。

②の場合、
作成された魔法は
こちらを作りたかったけど、
ユニの家で魔法作成した後にTownに戻るとエラーがでるから、さきちゃんの修正まち。

修正完了で、②のクリア条件を確認できた。

-------------------------------------------------

<Field3へ行くためのメインクエストを発生させる>----

Chapter.xlsにChapter15の会話を追加する。
[Chapter_importer.cs]
"15"を追加する。

[Guild.cs]
受注時に会話を発生させるようにする。

// 現在の進行度が15で、クエスト5番を受注したら
case 15:
if (questNum == 5)
{
　　　EventMng.SetChapterNum(15, 　　　SceneMng.SCENE.CONVERSATION);
}
break;

を入れる。

現在の進行度を15にして確認する。

-------------------------------------------------

<納品クエストの個数表示を一部変更する>-------------
[QuestMng.cs]
いままでは名前で判定していたけどnumがitemのほうの項目に加わったのでnumで判定するようにする。

通常の回復ポーション(小)は0番で、大成功は12番

QuestInfo.xlsのdeliveryに[0,12]といれる。
カンマ区切りにして、前の数値と後ろの数値で判断する

これでfor文で回してたところがなくなって
直でアイテムを検索できるようになる
処理回数削減！

また、大成功のアイテムとの合計で納品数とする計算が
できていなかったので、修正する。

private変数で配列のintを用意して、
いまの各、納品予定数を保存するようにしておく。

コルーチンのwhile文の中で
for文を回して合計の納品予定数を確認するようにする。

ClickDeliveryButton関数の修正も必要
→メニューのアイテムの所持数が減っていない
ClickDeliveryButton関数のhaveCntは減っているから
問題はメニューの方だと思う。
※さきちゃんに明日聞く。もしかしたらText側も変更が
　いるのかもしれない

<メニュー画面のアイテムが減らない問題について>
さきちゃんに修正をお願いして完了した。

<納品キャンセルボタンの一部変更>
関数名がcansel->cancelに修正したので
CancelボタンのOnClickがmissingになる部分を直す

-------------------------------------------------

<大成功アイテムを納品した時の処理を作る>-----------
大成功の個数に応じて報酬をupさせる。
納品個数と大成功数で全体の何％が大成功のアイテムなのかを調べてその％で報酬up度を決める。




-------------------------------------------------

<レストラン処理を作成する>------------------------

[レストランで必要な選択肢]
・料理を注文する
・外に出る

[料理を注文する]
前に作ったレイアウト通りに並べていく
左側にはクエストみたいに料理名をインスタンスする。
→料理数はゲームの進行度によって増えていく。

<ヒエラルキーにオブジェクトを追加する>
・RestaurantCanvas->料理を注文する/外に出るのボタン
・RestaurantMng->RestanrantMng.csをアタッチする所
・RestaurantMenuUI->メニューとかの詳細を出すところ

<RestaurantCanvas>
UIMove.csをアタッチしておく。
・ExitButtonのオブジェクトをアタッチ
※InHouseCanvasのRestaurantに入れている
　ExitButtonを削除する
・OrderButtonを作成する。

<RestaurantMng.csを用意する>
新規で[RestaurantMng.cs]を作成する。

[RestaurantMng.cs]
    [SerializeField]
    // レストランのメニューを表示するUI
    private GameObject restaurantMenuUI;

    [SerializeField]
    //　一つ一つの料理情報を表示するプレハブ
    private Transform cookPrefab;
を用意しておく。
→restaurantMenuUIはRestaurantMenuUIをアタッチする
→cookPrefabはまだ。

OnClickOrderButton関数を作成して、
OrderButtonにアタッチする。

OrderButton関数の中で
restaurantMenuUIを表示状態になるようにする。
それと交代で、RestaurantCanvasを非表示にする。

<クエストみたいに左側のボタン類を用意する>
QuestButton.csをギルドでもレストランでも
使えるようにしたい。

[QuestButton.cs]
TestRButton関数を用意しておいて、
Debug.Log(questNum_ + "の番号を渡します");
GameObject.Find("HouseInterior/Restaurant/RestaurantMng").GetComponent<RestaurantMng>().SetSelectOrder(questNum_);
を書く。

[RestaurantMng.cs]
SetSelectOrder関数を用意しておく。

RestaurantMngのCookPrefabの場所に
PrefabフォルダにあるQuestPrefabを複製してつくった
CookPrefabをアタッチする

[CookPrefab]
プレハブの中にあるButtonのOnClick部分に
TestRButton関数をアタッチする

インスタンスの仕組みを作る
[RestaurantMng.cs]
private Transform content_;の変数を作成する。
Start関数で
content_ = restaurantMenuUI.transform.Find("Background/Scroll View/Viewport/Content");
と
var uIInstance = Instantiate(cookPrefab, content_);
を呼び出すようにする。

RestaurantMenuUIの方にギルドで使っていたBackground
を子としてアタッチする。

※ここまでで、「ああああ…」と書かれた
　ボタンをインスタンスするところまではできた

<Excelを作成する>
新規で[CookList.xls]を作成する

必要になる情報としては、
num,name,info,statusUp,
needFood,needMoney,eventNum
となる。
(注意点)
statusUp・・・キャラのステータスと照合できるように
　　　　　　　する必要がある
needFood・・・素材の番号と数字を合わせる必要あり

インポート処理をしてResourcesフォルダに入っているのを確かめておく。

<表示処理をする>
該当するボタンを押下したら名前と説明を出すようにする。
Resourcesファイルから検索する部分を書き、
PopList.csにも処理を追加する。

Excelから読み込んだ文字を表示させるようにした。
サイズ調整とかが必要

次に、該当するボタンを押下したらステータスアップ効果を出すようにする。

・上がるステータスの内容は、StatusUpInfoText
・いくつアップするかの数字は、StatusUpInfoNumText
内容と数字に分けるには、ExcelのStatusUp項目の
データを分解する必要がある。

そして、必要な素材(食材になるもの系(?))を
表示するのをつくる。
→素材が必要のないものをあるからそのときには
　なしと表示する
・必要な素材はNeedFoodText
→数字から素材名をとるようにする
・個数系はNeedFoodNumText

needFoodText_.text = Bag_Materia.materiaState[popCookInfo_.param[num].needFood].name;
として素材名を取り出す。
キノコのときは3

最後に必要なお金の表示をする
MoneyText
→Alignmentを中央に設定しておく

最後に進行度を見てfor文でボタンを生成するようにしておく。
→QuestMng.csのStart関数を参考にしてつくる。

素材必要数をExcelに項目作るの忘れてた。
追加しておく。

これで右の説明部分は画像以外できた。
あとはOrderボタンを押された時の処理だけ

<Order押下時>
・素材をつかうやつ
→素材数が足りているか確認して、
　足りないなら押せなくする
→足りるときはお金処理とステータスアップと素材減ら　す
→所持金が足りるかも確認！

・素材をつかわないやつ
→お金処理
→ステータスアップ
→所持金が足りるかも確認！

[RestaurantMng.cs]
OnClickMenuOrderButton関数を作成する
→RestaurantMenuUIの中にあるOrderButtonにアタッチ

OnClickMenuOrderButton関数の中の処理を作成する。
お金の減少は、お金の管理をどこでしているかによる
→正式にSceneMng.csで管理することに決定
(使うときはGet/Setを通してね)

キャラのステータスアップは難易度高そう。。
・キャラクターの情報をSceneMng経由で取得
・一時アップ変数を用意しとくべきかも
・SetCharaSetting関数を参考に考えてみる

[Chara.cs]
SetStatusUpByCook関数をつくる。
※これの引数が悩む・・・
配列で受け取るようにする(順番命！！)
一時アップの数字を保存しておく変数も用意する。
→時間経過で下げるときにつかう。

[RestaurantMng.cs]
private (string, int)[] statusUp_ =
 new (string, int)[5];
という変数を用意して、あらかじめAttack,MagicAttack
とかのstringを入れておく。

メニューボタンを押した時に名前が一致したステータスのところにアップ値を入れるようにしておき。

実際に注文ボタンを押したらそのアップ値が配列になってChara.csの方に渡せるようにしておく。

素材を減らす処理について
Bag_Materia.materiaState[tmppop.needFood].haveCnt -= tmppop.needNum;
で解決できたとおもう。

-------------------------------------------------

<ワープ時にカメラが追従しなくなった>--------------

おそらくCameraSample.csのStart関数をInit関数に
変更したせいだと思う。

Init関数をTownMng.csで呼び出せるように、
CameraMng.csをFindするようにしよう。

[TownMng.cs]
Start関数のSetNowScene関数のあとに、

GameObject.Find("CameraController").GetComponent<CameraMng>().MainCameraPosInit();

を呼び出すようにする。
-------------------------------------------------

<建物から出たあとにワープすると、カメラがついてこないバグが発生>-------------------------------------

[CameraMng.cs]
SetChangeCamera関数に
mainCameraがactiveになるときはInit関数を呼び出すようにする。

何回か移動するとエラーでてるから、
コルーチンの初期化処理をInit関数内でやったほうが
良さそう。

[CameraSanple.cs]
QuestMng.csのコルーチン初期化うんぬんを見ながら処理をかく。

-------------------------------------------------

<レストランのメニュー画面中に戻るボタンをつける>---

RestaurantMenuUIの子として[BackButton]を追加する。
このボタンはギルドのやつと同じ

[BackButton]
アンカーポイントを左下にして
Pos   X:50 Y:50 Z:0
Scale X:2  Y:2  Z:1
色はそのままにする。

あとは内部処理をScriptに書いてアタッチさせる。

[RestaurantMng.cs]
OnClickBackButton関数を作成する。
中でSetActiveの切替とステータス値の初期化を行う。
これをBackButtonのOnClickにアタッチする。

-------------------------------------------------

<店に入ったときからお金を右上に表示しておく>-------

配置は店名の下らへん。
お金のマークを作っておきたい。

<お金のマークについて>
https://www.ac-illust.com/main/detail.php?id=830600&word=%E9%87%91%E3%83%A1%E3%83%80%E3%83%AB_02&searchId=1593258780
上記のサイトからコインの画像は落としてきた。
あとは中のマークだけ。
中のマークと枠はさきちゃんが書いてくれる。

画像の名前を[HaveMoneyFrame.png]とする。
※サイズを245*48に変更してもらう

必要な店では各HouseInfoの子としてもらって、
(レストランの例)
Pos X:0 Y:-60 Z:0
等としてもらう

<所持金表示が必要なお店では、出せるようにする>
[UIMove.cs]
"HouseInfo"を検索したついでに、
さらにその子として"HaveMoneyText"というオブジェクトがついていたら、その子のTextに所持金を代入する。

[HaveMoneyText(TMP)]
Pos X:14.3 Y:-58 Z:0
FontSize:36
Alignment:右寄せ中段


-------------------------------------------------

<メニュー注文後は、前の画面に戻るようにする>-------

[RestaurantMng.cs]
OnClickMenuOrderButton関数の一番下に、
SetActive処理を入れる。
→OnClickBackButton関数と処理が丸被りなので
private関数でBackMenu関数をつくり、そこにまとめて
その関数を呼び出すようにする。

-------------------------------------------------

<一定時間新しい料理を食べられないようにしたい>-----

料理の効果が切れるのを、食べたときから
「2つ先の時刻」とする。

(例)
朝食べる->夕方切れる
夕方切れる->朝切れる
フィールド1つ分の効果時間しかない
※フィールドをハシゴしたら、2つ目以降のフィールドで
　はステータスアップなし

[SceneMng.cs]
TIMEGEAR finStatusUpTime_変数をstaticで作成する。
Get/Set関数で呼び出せるようにする

Set関数の中で2つ先の時刻を設定する
※2つ先の時刻が夜を超えた数字なら[-4]すればいい

[RestaurantMng.cs]
OnClickMenuOrderButton関数の一番下でSetFinStatusUpTime関数を呼び出すようにする。


※切れたあとに食べに来ないで食べれない時刻と同じに
　来ることを考えないとダメ
　効果が切れたときにフラグをfalseにするとかを
　したほうがいい

時刻はboolの入れ替えの為に使うようにして、
実際食べれるか食べれないかはboolで判断するようにする

[SceneMng.cs]
SetTimeGear関数で
// 料理の効果が切れる時間ならフラグをfalseにする
if(timeGrar_ == finStatusUpTime_.Item1)
{
    finStatusUpTime_.Item2 = false;
}
というのを書く。

[RestautrantMng.cs]
OrderButtonを押したときに
最初の行に

// フラグがtrueなら食べれないようにする
if(SceneMng.GetFinStatusUpTime())
{
   Debug.Log("お腹がいっぱいで食べられないヨ！！");
   return;
}
というのを書く。

-------------------------------------------------

<料理効果がきれたときにステータスアップ分を消す>---

[Chara.cs]
DeleteStatusUpByCook関数を作成する。
中でstatusUp変数から各ステータス値をマイナスする。
最後に値を0に初期化しておく

[TownMng.cs][FieldMng.cs][UniHouseMng.cs]
Start関数の中でSceneMng.csの
GetFinStatusUpTime関数を呼び出してフラグを確認し、
falseになっていたらChara.csの
DeleteStatusUpByCook関数を呼び出すようにする。

-------------------------------------------------

<街やユニハウスからフィールドに行ったとき、
 メニューボタンが動かない>------------------------

TABキーを押せなくしている場所に問題がありそう

[MenuActive.cs]
Update関数のreturn処理にある
warpField_.GetWarpNowFlag関数がtrueなら
returnに入る処理を書いてあるところで、

探索中も常にtrueになっているからreturnされている。
WarpField.csの処理に問題がありそうなので
さきちゃんに修正を依頼中

修正完了。

-------------------------------------------------

<ギルドとレストランの店名を
 HouseInteriorCanvasから取り出す>-----------------

HouseInteriorCanvasというゲームオブジェクト自体を
削除して、Canvas数を減らすようにしたい。

[TownMng.cs]
外部アタッチのInHouseCanvasが不要になる。

[HouseInfo]はボタンが右から挿入されるやつと
一緒に動かないように設定しなおす。

[UIMove.cs]
[HouseInfo]という名前のオブジェクトは動かさない
ようにする。

OnEnable関数
for文の中で"HouseInfo"だったら
localPositionを(500.0f,320.0f,0.0f)とする。
※アンカーポイントが中央からしか計算できないみたい

Easingのコルーチン内
while文の中にあるfor文の最初に、
// 既にフラグがtrueなら飛ばして、次を回す
if(flag[i])
{
  continue;
}

// HouseInfoならすぐにtrueにして飛ばす
if (transform.GetChild(i).name == "HouseInfo")
{
  flag[i] = true;
  continue;
}
と追加する。

<注意点>
・店名は、UIMove.csがついているオブジェクトの子に
　必ずすること
・子の名前は"HouseInfo"固定とし、その子に"Text"を
　つけること(例はレストランとか見てください)
・"HouseInfo"のアンカーポイントは、
　必ず中央にしておくこと

-------------------------------------------------

<各店に、該当するキャラを設置する>----------------

<ギルド>
HouseInteriorのGuildに配置する

Position X:-0.6 Y:-0.5 Z:1
Rotation X:0    Y:150  Z:0

<レストラン>
Position X:0.7  Y:1.9  Z:-6.5
Rotation X:0    Y:150  Z:0

<書店>と<魔道具屋>
Position X:0.5  Y:-0.5 Z:1
Rotation X:0    Y:-150 Z:0

同様に、他の建物にも配置する
とりあえずいまはこれだけ。
最終的にボイスとか動きとか表情遷移とかできたらいいな

-------------------------------------------------

<新たなセーブ用のcsvをつくる>---------------------

[セーブ内容]otherData.csv
①進行度
②お金
③クエストのクリア状態
④宝箱と強制戦闘壁の取得済み&クリア状態

[SaveCSV.cs]を改良する。
public enum SAVEDATAをつくり、
キャラデータの保存か、その他データの保存かを
分けられるようにする。

SaveStart関数を引数付き(SAVEDATAのenum)にして、
data.csに書き込むのか、otherData.csvに書き込むのか
判断できるようにする。

if文で中で判定して、処理を分けるようにする。

[SaveCSV.cs]
OtherSaveData関数を用意して、そこにSaveData関数を似たような処理を書く。
※注意点として、項目の間にデータを入れていくように
　しないといけない
①の保存
EventMng.csからGetChapterNumを呼び出す
②の保存
SceneMng.csからGetHaveMoneyを呼び出す
③の保存
QuestMng.csのquestClearCnt_変数をprivateからpublic
にして呼び出す
④の保存
これが厄介。
まずは、FieldMng.csで宝箱と壁の情報を入れておく
リストを作成する。

[FieldMng.cs]
public staticで宝箱と強制戦闘壁用のListを別々で
つくり、初めて行くField時にAddして増やす方式にする
→Listはstringとboolのpair
(初めていくFieldかの判定方法はその名前で登録が
 あるかどうか)
CheckWallAndChestActive関数を大幅に修正し、
2つのリストのboolからSetActiveを切り替えさせる。

boolをtrueにする処理を書く場所を決めないといけない
宝箱->とったときだから、LootBox.cs
壁->中での敵を倒したらだから、

[LootBox.cs]
Open関数の中に、
        // リストの中のbool部分をtrue(=取得済み)にする
        var tmp = FieldMng.treasureList;
        for(int i = 0; i < tmp.Count; i++)
        {
            if(tmp[i].Item1 == name)
            {
                // flagをtrueに上書きする
                (string, bool) content = (name, true);
                tmp[i] = content;
            }
        }
といれる。

壁の処理はちょっと遠回りになるけど必要な処理がある
からそっちからはじめる。
[FieldMng.cs]
MODEenumに、FORCEDBUTTLEを追加する。
[ForcedButtle.cs]
「はい」を選択したときにFORCEDBUTTLEに設定する。

[CharacterMng.cs]
FORCEDBUTTLEのときは逃げるが押せないようにする。

<強制戦闘に勝利したとき>
[ButtleMng.cs]
public static string forcedButtleWallName;
という変数を用意しておいて、
戦闘終了時にその戦闘がFORCEDBUTTLEだったときは
LootBox.csに書いたようなリストのboolを更新するようにする。(nameのところにforcedButtleWallNameを使う)

[ForcedButtle.cs]
「はい」を選択したときにforcedButtleWallNameに
オブジェクト名を入れるようにする。

[MenuActive.cs]
DataSave関数でSaveStart関数とOtherSaveData関数と
SaveEnd関数を呼び出すようにする。

<強制戦闘に敗北したとき>
[CharacterMng.cs]
全滅時の処理の中に、forcedButtleWallNameに入れている名前を""にするようにかく。

ようやく保存処理にはいる。
[SaveCSV.cs]
// 宝箱と強制戦闘壁の取得とクリア状態の項目名
sw.WriteLine(string.Join("\n", "Treasure"));

// 宝箱と強制戦闘壁の取得とクリア状態
var treasure = FieldMng.treasureList;
foreach (var pair in treasure)
{
    sw.WriteLine(string.Join("\n", pair.Item1.ToString() + "," + pair.Item2.ToString()));
}

sw.WriteLine(string.Join("\n", "ForcedButtle"));

var wall = FieldMng.forcedButtleWallList;
foreach (var pair in wall)
{
    sw.WriteLine(string.Join("\n", pair.Item1.ToString() + "," + pair.Item2.ToString()));
}
という処理を追加する。

これで、宝箱、壁の順番に保存できた。

明日からロード処理しよう。

6~10
・進行度、お金、宝箱の取得状態、強制戦闘の終了状態　のロード処理  6,7
・Field4の雑魚とボスを追加 7,8
・Field4クリア後の会話を追加 7,8
・Field5の作成 8,9,10
・回復魔法の処理を追加 8,9
・補助魔法の処理を追加 8,9

-------------------------------------------------

<otherData.csvのロード処理を行う>-----------------
[ロード内容]otherData.csv
①進行度
②お金
③クエストのクリア状態
④宝箱と強制戦闘壁の取得済み&クリア状態

[SaveCSV.cs]
名前を、「SaveLoadCSV.cs」に変更する
この中でキャラのロードも、otherData.csvも読み込むようにする。

<キャラの情報ロードを修正>
LoadData関数をつくり、
MenuActiveに直接書いているロード処理を移植してくる

<①～④の情報をロードする>
①について、
[EventMng.cs]
chapterNumの変数を、privateからpublicに変更する

[SaveLoadCSV.cs]
ロード処理で行分けしたときにEventNumという項目を
みつけたら、次の行を読み込んで
EventMng.chapterNum = int.Parse(texts[i + 1]);
とする。

②について、
SceneMng.SetHaveMoney(int.Parse(texts[i + 1]));
として、項目のある次の行の数字を入れるようにする。

③について、
QuestMng.questClearCnt[a] = int.Parse(split[1]);
みたいにして、データを代入していく
※情報が連続で入らないように判定が必要

④について、
ロードするときに無条件でAdd処理しているから同じ
情報が連続で入らないように判定が必要

あとは似たような処理をまとめて短くする
→④についてはまとめることができた。

[MenuActive.cs]
DataLoad関数を呼び出す

-------------------------------------------------

さきちゃんに伝える注意点
・店名は、UIMove.csがついているオブジェクトの子に
　必ずすること
・店名オブジェクトの名前は"HouseInfo"固定とし、
　その子に"Text"をつけること
　(例はレストランとか見てください)
・"HouseInfo"のアンカーポイントは、
　必ず中央にしておくこと
・所持金の表示処理もUIMove.csで行っているので、
　所持金を出すテキストはかならずTextMeshProで
　オブジェクト名を"HaveMoneyText"とすること
　(例はレストランを見てください)


料理効果中は、左上の時計の横に料理マークというか
アイコンを置いておきたい

*重要*
タグの判別にはgameObject.tag == “string tag”もあるが、CompareTag()の方が早い

最後に、不使用だったものは消すようにしないと。