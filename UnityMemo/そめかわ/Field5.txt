<谷の地形にユニを設置してみる>--------------------

谷の形をしたアセットをいれてみたので
そこに最低限ユニが動けるように環境をつくる。
LANDオブジェクトの子に区画毎のテラインがあるので
カメラに映らなさそうな所は消していく。

LAND
Pos X:-856 Y:-135.5 Z:1040

-------------------------------------------------

<ユニの足元にrayを飛ばして足場を取得する>----------

いままではユニの座標の高さが一定以上ならposyを
下げるようにしていたけど、それを変更する。

足元にraycastでレイを飛ばして地面と接触しているか
確かめるようにする。

参考にしたサイト↓
①https://gametukurikata.com/program/scriptisgrounded
②http://negi-lab.blog.jp/archives/12265684.html
③https://getabakoclub.com/2020/05/11/unity%E3%81%A7%E5%9C%B0%E9%9D%A2%E3%81%AE%E5%BD%93%E3%81%9F%E3%82%8A%E5%88%A4%E5%AE%9A%E3%82%92%E8%B6%B3%E5%85%83%E3%81%A0%E3%81%91%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E3%80%903d%E3%80%91/

これをもとにUnitychanController.csに処理を書く。
多少坂道でがたつくけど許容範囲かな。。

-------------------------------------------------

<仮で敵情報を用意する>
Field3の敵を丸コピして、Enemy.xlsに情報をいれる。
TerawareのEnemyの方も追加して、reimportする。

<Field5に入ってすぐの会話を作成する>--------------

Chapter_importer.csに"22"をついかする。
FieldMng.csに進行度22 かつ Field5のとき会話が
発生するように処理を書く。

会話内容自体はつくってあるので、
あとは会話の時のおばあちゃんのシルエットと
背景画像を探してChapter22を作成する。

背景画像↓
https://www.photo-ac.com/main/detail/2877166#goog_rewarded
写真から絵画風にするオンラインツールをつかって編集
→Valley.pngとして保存

シルエット↓
https://www.ac-illust.com/main/detail.php?id=2501594&word=%E6%9D%96%E3%82%92%E3%81%A4%E3%81%84%E3%81%9F%E3%81%8A%E3%81%B0%E3%81%82%E3%81%A1%E3%82%83%E3%82%93%EF%BC%88%E3%82%B7%E3%83%AB%E3%82%A8%E3%83%83%E3%83%88%EF%BC%89#goog_rewarded

おばあちゃんのシルエットが会話で出せるようにしない
といけない。

PictureフォルダにダウンロードしたGrandMother.pngを
いれる。
townの樽につけてるやつのようにしたいので、
Picture-MaterialsのUnityLogoを複製してGrandMother.pngを設定できる奴をつくる。
あとはそれをconversationdataのsceneに配置できるようにCharacterListにQuadでオブジェクトを作成。
アタッチする。

Excelではname2のところにせっていすればでてくるはず
できた！

-------------------------------------------------

<Field5の道>-------------------------------------

歩く場所がだいぶわかりにくいからどうにかしたい所。

grass_diffの画像をMetaric[1]にして色を濃ゆくする。
道幅分grass_diff2で色をぬる。(こっちはMetaric[0])

最後のフィールドは、もうドラゴンだけでいいかな。。

<戦闘する位置について>
下り坂が多くて、モンスターの位置もキャラの位置も決めにくい。
なので、新規Terrainをつくる。
その周囲に既存の山つきのTerrainを2つぐらい配置。

<強制戦闘前に「いいえ」をえらぶと地面に埋まる>
下り坂から後ろに戻すだけだから埋まってしまう
[ForcedField.cs]
いいえを選択したのがField5のとき、
若干Y座標に+補正をいれる。

<Field5では雑魚戦を発生しないようにする>
[FieldMng.cs]
SEARCH中にField5の場合はreturnするようにして
time_ += Time.deltaTime;
がはっせいしないようにする

移動範囲ギリギリにコライダーを設置していく

-------------------------------------------------

<ドラゴン討伐後のストーリー作成>------------------

Chapter23を作成。
Chapter_importer.csに"23"を追加してreimportする。

[Guild.cs]
現在の進行度が23で、クエスト7番を達成したときに
chapter23の会話が発生するようにする。

-------------------------------------------------

<ボスを配置する>----------------------------------
<アニメーションについて>
TurtleShellからコピーしてきて、アニメーションの中身を入れ替える。
→不必要なアニメーションは削除する

BasicAttackとGetHitがループになっているので、LoopTimeのチェックを外す。

(できれば物理も魔法もしてくるタイプにしたい)

<Enemy.xls>
いい感じに付け加える
Enemy.xlsに"Field4"のタブを付けくわえておく
→Enemy_importer.csに"Field4"を足す

<モデルにつけるコンポーネント>
本体の名前を[Enemy_Dragon]にする
→Rigidbody
→BoxCollider(被ダメージ用)
をついか(詳細設定はSlimeのモデルを参照して)
また、TagをEnemyにする

<近距離攻撃型にする>
[Dragon]のほうに
→BoxCollier(ダメージ用)
→CheckAttackHit.cs
をついか
また、TagをWeaponにする
IsTriggerにチェックをいれる

サイズが大きい敵だから移動距離を調整する
なぜか空中に戻っていく。。。
→もともとの地面とかのY座標を0にしていなかったせい
地面とキャラと敵の配置するY座標を0に合わせれば治る

敵が大きいから、近接攻撃の時に目標地点につく前に
コライダー同士が衝突してしまう
→PoisonSlimeのように、後ろに当たり判定位置をずらす

ジャックの動きがおかしくなる。
元の位置に戻りきれないで数秒ガクガクなる
→Chara.csのBackMove関数の誤差の許容を0.5fにする

-------------------------------------------------

<シナリオ終了後の処理>----------------------------

シナリオ後にFinをだしてデータをセーブし、
タイトルへ戻す

新規SceneでEndSceneを作成する

参考サイト↓
https://goodlucknetlife.com/unity-rpg-ending/

画面右のスタッフロール処理がかけたら、
左側にStreamingAssets内のChapterBackの画像を
順番に表示させるようにする。

若干サイトと違う部分としては、
CanvasにEndroll.csをアタッチしていること
→画像の切替処理の関係で。

<ボタン処理の作成>
・セーブしてタイトルへ戻る
・セーブしないでタイトルへ戻る
この2つをつくる。
処理は全てEndroll.csへ

とりあえず単体のシーンテストは終わったので、
Chapter24終了後にエンドロールへ遷移するテストをする
→Chapter24のExcelの最後にENDと記述する

Excelからロード先を決定することによって
2週目プレイ時にエンド後、
24のチャプター番号でセーブして、次ロードした直後にエンドロールがながれるのを防げる

Sceneとビルドの順番がずれる点に注意が必要
TitleをNONの次にいれて、
EndをCancelの前にいれる

-------------------------------------------------

<ロードボタンをおしたら強制的に街から始めさせる>---

また、その際にはメニュー画面を閉じる処理をいれる

[MenuActive.cs]
キャンセルボタンの処理をMenuClose関数にまとめた。
それをDataLoad関数でも使用する。
呼び出したあとに、
SceneMng.SceneLoad((int)SceneMng.SCENE.TOWN);
を記述しておく。

-------------------------------------------------

<各ステージに宝箱の配置>--------------------------
中にワードが入っている宝箱の設定をする
arr[0]:クエスト番号
arr[1]:(そのフィールド上の)宝箱番号

[Field1]
arr[0] == "1" && arr[1] == "1"のとき、

・「単体」「炎」「小」が1セット
                    bagWord_.WordGetCheck(InitPopList.WORD.HEAD, 0, 0);//単体
                    bagWord_.WordGetCheck(InitPopList.WORD.ELEMENT_ATTACK, 0, 5);// 炎
                    bagWord_.WordGetCheck(InitPopList.WORD.TAIL, 0, 9);// 小

[Field2]
arr[0] == "200" && arr[1] == "1"

・「回復」
WordGetCheck(InitPopList.WORD.ELEMENT_HEAL, 0, 3);// 回復

ChestInfo.xlsに書く

[Field3]
arr[0] == "200" && arr[1] == "2"

・「中」
WordGetCheck(InitPopList.WORD.TAIL, 1, 10);// 中

ChestInfo.xlsに書く

[Field4]
・「大」
arr[0] == "200" && arr[1] == "3"

WordGetCheck(InitPopList.WORD.TAIL, 2, 11);// 大

ChestInfo.xlsに書く

[Field5]
・「極大」
arr[0] == "200" && arr[1] == "4"

WordGetCheck(InitPopList.WORD.TAIL, 3, 12);// 極大

ChestInfo.xlsに書く

[LootBox.cs]
現在のフィールドと
自分がアタッチされてるオブジェクト番号を確認して、
WordGetCheck関数を呼び出すようにする。

-------------------------------------------------

<ユニが死亡して戦闘から逃げたときに立ち上がらない>-

[ButtleMng.cs]
ButtleInit関数の呼び出しタイミングをCallDeleteEnemy関数の中に書くようにする

→逃げるときも戦闘終了の時も呼び出されるから

-------------------------------------------------

<フィールド名を正式につける>----------------------

Field1->豊作の森
Field2->ヴェステ砂漠
Field3->ドウー岩石地帯(ドウー=硬い)
Field4->不浄の洞窟
Field5->竜の谷

DontDestroyCanvasのLocationSelMngにあるTextの
文字サイズを小さめに変更(36)して、
WarpFieldのSceneNameを各ステージ名にかえる

-------------------------------------------------

<フィールドから戻ってきたときに、メニューが
 開けない>---------------------------------------

MenuActive.csのUpdateのreturn条件に当てはまって
いるのかもしれない。
→調べた感じだと、GetWarpNowFlagが遷移後も
　trueになっていてメニューが開けなくなっている
　
falseにするタイミングを用意する必要がある。
Initでfalseにしてみたけど、Getでなぜかtrueが
とれる。

(原因判明)
画面遷移したときにWarpOutが各シーンでおかれてるから
前のシーンのやつがnullになってて、強制的にtrueが入っているみたい

[MenuActive.cs]
warpField_がnullになったら
GetComponentする処理をUpdate関数にいれる。

-------------------------------------------------

<戦闘中にステータスアップ処理が入るまでは　
　画像を非表示にする処理をいれる>------------------

非表示に見えるようにα値をいじったほうがよさそう。

<キャラクター側>
バステ系
[BadStatusMng.cs]
SetBstIconImage関数でcolorの透過/非透過の
設定をする

バフ系と反射/吸収系
[CharacterMng.cs]
ButtleSetCallOnce関数で全て透過にしておく
その後、効果がきれたり付与されたらまた透過の切替をする

<敵側>
デバフ系
[EnemyInstanceMng.cs]
CharacterMng.csと似たような処理で、
最初は透過しておき、効果がついたら切り替える

-------------------------------------------------

<連続でLoadするとふっとぶ>------------------------

SaveLoadCSV.csのクエスト関連のロードで失敗してた。
int.Parseがうまくいってない感じ。

すでにデータがある場合、
のときに_cとかが数字変換できずにいた。
数字部分だけを取り出すように変更する。

-------------------------------------------------

<魔法発動後に左下のウィンドウを閉じるようにする>--

[CharacterMng.cs]
buttleMagicInfoFrame_.SetActive(false);を
IDLEで入れるようにした。

-------------------------------------------------

<UniHouseのショートカットアイコン変更>------------

Townと同様のアイコンに変更する。
SetNativeSizeを押すこと

-------------------------------------------------

<戦闘でジャックがユニより行動早いときの処理を追加>-

[CharacterMng.cs]
ButtleSetCallOnce関数で、ユニとジャックの速度を
比べてあげて値が大きいほうをnowTurnChar_変数に
いれてあげればいい。
→同値ならユニが先に動くようにする

-------------------------------------------------

<魔法発動時にMPをいくつ使うか表示させる>----------

ButtleUICanvasのMagicInfoFrameに
同じものを複製して小さくしたものを用意。
それをUseMPとする。
魔法説明の右側に小さく表示する。

[CharacterMng.cs]
magicUseMPText_変数を作成する。
Start関数で、
buttleMagicInfoFrame_.transform.Find("UseMP/MPText").GetComponent<TMPro.TextMeshProUGUI>();
としておき、魔法コマンド選択時に
magicUseMPText_.text = " MP -" + useMagic_.MPdecrease(magicNum).ToString();
としてあげる。

-------------------------------------------------

<レベルが上がり続けるバグについて>-----------------

(原因)
ButtleMng.cs
何回もリザルト処理に入るから

(解決方法)
一度処理を行ったらtrueになるフラグを用意する。
→戦闘開始時に設定される項目で最初にfalseにする。

それでも値がおかしい

-------------------------------------------------

<会話中には鞄を消す>------------------------------
TextMng.csのStart関数に

SceneMng.SetNowScene(SceneMng.SCENE.CONVERSATION);
を記述する
→呼び出された関数の中でメニューをfalseにする
　処理が書かれている

-------------------------------------------------

<BGMの追加>--------------------------------------

利用サイトについては「制作メモ」のほうに記述

[Title]
Audioという空のゲームオブジェクトを作成
それにAudioSorceをアタッチする。
AudioClipにTitleBGMをいれて

PlayOnAwake
Loop
にチェックをいれる

Volumeを[0.5]にして
Pitchを[0.8]にする

[Town][UniHouse]
Audioという空のゲームオブジェクトを作成
それにAudioSorceをアタッチする。
AudioClipにTitleBGMをいれて

PlayOnAwake
Loop
にチェックをいれる

Volumeを[0.2]にして
Pitchを[0.8]にする

[conversationdata]
TownBGMをつかう

PlayOnAwake
Loop
にチェックをいれる

Volumeを[0.1]にして
Pitchを[0.5]にする

[EndScene]
TitleBGMをつかう

PlayOnAwake
Loop
にチェックをいれる

Volumeを[0.5]にして
Pitchを[0.5]にする

[各フィールド]
フィールドでは、
・探索中
・雑魚戦闘
・ぼす戦闘
で3曲必要になる。

切替の目印としてFieldMngのnowModeをみる

わかりやすそうだから[FieldMng]オブジェクトに
AudioSorceをアタッチする。

PlayOnAwakeのチェックは外す
Loopにチェックをいれる

Volumeを[0.2]にして
Pitchを[1]にする
※Field5だけPitchを[0.8]にする

一番重要なのは、ButtleCameraにもAudioListenerを
アタッチすること！！
[FieldMng.cs]
    public AudioClip BGM_search;
    public AudioClip BGM_normalButtle;
    public AudioClip BGM_bossButtle;
と用意する。

ChangeMode関数に、
audios.Stop();
audios.clip = BGM_search;
audios.Play();
とする。

[CameraMng.cs]
AudioListenerがmainにもsubにもついているので
mainCamera.GetComponent<AudioListener>().
enabled = !flag;

subCamera.GetComponent<AudioListener>().
enabled = flag;
としてAudioListenerを切り替えるようにする

-------------------------------------------------

<各シーンのButtleWallの色調整>--------------------

うっすら見えたほうがいいかも。
半透明な赤い壁にする。

Assets/Field/Mapの中に新規マテリアルを作成
[ButtleWallMat]とする。

RenderingModeを[Fade]にし、
MetaricとSmoothnessを[1]にする。
Albedoを赤でalpha値を0.5にしておく
これを各ButtleWallのオブジェクトにアタッチする

-------------------------------------------------

<Tagに[Drop]を追加する>--------------------------

いままではユニの前のボックスがなににぶつかっても
テキストを表示していたけどそれをなおす

DropというタグをMaterialPointsの子と
宝箱につける

OtherCollider.csはさきちゃんが更新してくれる

-------------------------------------------------

<ボスを倒したときに入手できるワードについての
 処理をする>-------------------------------------

[KnockDownEnemy.cs]
OnDisable関数の中に
GetWordの処理をいれる

WordGetCheck
(InitPopList.WORD.ELEMENT_ATTACK, 1, 6);// 水
            
WordGetCheck(InitPopList.WORD.ELEMENT_ATTACK, 2, 7);// 土
            
WordGetCheck(InitPopList.WORD.ELEMENT_ATTACK, 3, 8);// 風

あとはデバッグする
→ボスを倒したあとのDropCheck関数でエラーがでてる
　さきちゃんに報告したから修正待ち

-------------------------------------------------

<進行度に合わせていけるフィールドをふやす>---------

[WarpField.cs]
activeField_変数を配列で作成し、
タイトルから順に進行度解放番号をいれていく。

ボタンの表示・非表示処理の中に
chapterNumとactiveField_を比べるif文を追加して
終了


private int[] activeField =
new int[(int)SceneMng.SCENE.MAX] 
{ -1, -1,-1,-1,8,13,16,19,22,-1,-1 };

-------------------------------------------------

<レストランメニューを大量生産する>----------------

そもそも注文時にエラーがでた
→hp,mp,expの上昇処理がないから

配列の項目に3つを追加する
(Chara.csとRestaurantMng.cs)

素材が不要なメニューをとりあえず10個ぐらい作成する
→そのぶん値段で差をだす

<料理効果中というのがわかるようにする>
DontDestroyCanvasにTimeGearの近くに
お料理マークをだすようにする
(TimeGearの子とする)

イラストACでもってきたアイコンをアタッチして
透過/非透過で制御する。

[SceneMng.cs]
SetTimeGearで透過

[RestauranMng.cs]
料理を購入時に非透過

-------------------------------------------------

<ボスを倒したあとのワード取得でエラーがでる>-------

(原因)
KnockDownEnemy.csのOnDisable関数でFind関数を使っていたから。
→非表示になったときの処理でfindはよくないみたい

(解決方法)
Start関数を用意し、
bagWordを予めfindしておくことにした

-------------------------------------------------

<家で寝たら料理バフを解除にする>------------------

[UniHouseMng.cs]
ClickSleepButton関数
DontDestroyCanvas/TimeGear/CookPowerIconをfindして
colorでα値を透過する。
その際DeleteStatusUpByCook関数も呼び出す

-------------------------------------------------

<家で寝たら体力回復する>--------------------------

[UniHouseMng.cs]
ClickSleepButton関数内で、
DeleteStatusUpByCook関数を呼び出したときに
SetHPとSetMPも呼び出してMaxの値を設定する。

-------------------------------------------------

<進行度7までは寝るボタンが押せない雰囲気を出す>----

[UniHouseMng.cs]
Start関数内で現在の進行度を調べて、
7未満だったらSleepButtonの
interactableをfalseにする
→これで半透明になるからわかりやすくなる

-------------------------------------------------

<ジャックをフィールドに表示させない>--------------

[FieldMng.cs]
private GameObject jackObj_;
を用意して
Start関数でJackをfindしておく

ChangeMode関数でSEARCHのときはSetActiveをfalse
BUTTLEとFORCEBUTTLEのときはtrueにする

-------------------------------------------------

<最初の会話の後、ユニの操作ができないバグ>---------

左シフトキーを押した後にうごけなくなるので
メニューを開いているときにうごけないことがわかった

ただメニューのアイコンが最初から表示されていない
ので、そっちのバグだと思われる。

→[UniHouseMng.cs]に        　SceneMng.MenuSetActive(true);を追加する

また、メニューボタンの反応がないのは
conversationdataのシーンのdontdestroycanvasに
onclickの設定がぬけてるから。
→設定しなおしたら動くようになった

-------------------------------------------------

<セーブデータがないときはLoadボタンが
 押せないようにする>------------------------------

[MenuActive.cs]
ButtonStateColorChange関数をLoadでも使えるように
引数を増やしておく。

data.csvがResourceファイルにないときは
ロードが押せないようにしておく。

よく考えたらゲームを止めるまでデータが保存されない
からいつまでも押せないままになる
→仕様です・・・
戻りたかったら一度ゲームを閉じてもらうしかない
っていうのを操作方法に書いといたほうがいいかも((

-------------------------------------------------

<アイテムの大成功処理をつくる>--------------------

その前に、HaveItemList.csvとUseItem.csの順番が
一部ずれていたのでそれを修正した
→HaveItemList.csvに合わせた

[UseItem.cs]
大成功の処理についてかく

[CharacterMng.cs]
即死身代わりアイテムの番号をpairにしてあげて
身代わりアイテム消費の処理で
普通->大成功アイテムの順に所持しているか調べる。

-------------------------------------------------

<ストーリー中でもらえるアイテム/素材類>-----------

Chapter3->空のマテリア*5
[ItemStore.cs]
CheckEvent関数でtmpFlgがfalseのときに
 GameObject.Find("DontDestroyCanvas/Managers").GetComponent<Bag_Materia>().MateriaGetCheck(34,5);
を呼び出すようにする

Chapter4->アイテム合成レシピ(初級)
※さきちゃんに任せてる

[EventMng.cs]
SetChapterNumに記述する
注意点として、eventNumで判断するから
Chapter8のeventNumは9であるというところ。
Chapter8->回復ポーション(小)*3

-------------------------------------------------

<DropFieldMateria.csのバグ>----------------------

素材のドロップが範囲外になる
fieldNumber_ = (int)SceneMng.nowScene - (int)SceneMng.SCENE.FIELD0;
というのを、

fieldNumber_ = (int)SceneMng.nowScene
に変更した

-------------------------------------------------

<newGameのときに、本の情報だけ初期化できない>-----

data.csvやotherData.csvと同じSaveLoadCSV.csに
初期化処理を記述するようにした。

[SaveLoadCSV.cs]
NewGameInit関数を作成してExcelから本の名前をとりだし、読んだかどうかのintのほうは固定で「０」にする。

よく考えたらセーブしてるだけで、bookState_自体の
初期化ができてなかったわ

[BookStoreMng.cs]
bookState_変数がnullかどうかで判断してあげる
→newかloadかの区別をつけられる

-------------------------------------------------

<敵のランダム数出現>------------------------------

[ButtleMng.cs]
public にしているdebugEnemyNumをコメントアウトし、

// 敵のインスタンス(1～4)
var debugEnemyNum = Random.Range(0, 5);
// イベント戦闘の場合、敵の数が異なる場合があるので返り値で正しい値を受け取るようにする
var correctEnemyNum = enemyInstanceMng_.EnemyInstance(debugEnemyNum, buttleUICanvas);

とする。
-------------------------------------------------

<ローディング画面を作成する>----------------------

参考にしたサイト↓
https://gametukurikata.com/program/nowloading

loadingscene
->ボタンを押すと記述したシーンに飛ぶ

titlescene(今)
・newgame ->conversationdata
・loadgame->town

各シーンにローディング機能を持たせたほうが早いかな

MainCamera系にLoading.csをアタッチして
Canvas-Backgroundを持っていけばいい

LoadSceneの関数を変える必要がある
LoadSceneAsyncにする

[Title->次のシーンにロードをはさむ]

<TitleSceneに追加したもの>
・LoadingCamera
   -Loading.csをアタッチ
      -BackGroundにLoadingCanvasのBackground
      -SliderにLoadingCanvasのSlider
   -AudioListener(チェックを外しておく)
   -Depthを「-2」にする

・LoadingCanvas
   -CanvasのSortOrderを「50」とする
　　(そのシーン内で一番値を大きくする)

・NewGameBtnとLoadGameBtnのOnClickを2つにする
   -TitleMng.csのOnClickGameStart
   -Loading.csのNextScene
    (Newは「１」,Loadは「２」という数値をいれる)
　　(数字の意味は、ビルド番号)

<TitleSceneMng.cs>
今までOnClickNew/Loadで分けていたものを
OnClickGameStartに統一する
中の処理ではMainCamera/SubCameraの
ゲームオブジェクトを非表示にし、
MoveCameraのコルーチンを止めるようにしている

<Loading.cs>
NextScene関数では
LoadDataのコルーチンを呼ぶ処理をしている
(ここの引数がLoadDataにビルド番号を渡すもの)

LoadData関数ではbackGroundの表示と
AudioListenerのenableをtrueにする処理と
シーンの読み込みと
読み込み速度に合わせたスライダーの増加処理をしてる

[Title以外->次のシーンにロードをはさむ]
LoadingCameraだけDontDestroyCanvasの子にする。
LoadingCanvasは各シーン配置
→プレハブにする

<CameraMng.cs>
SetChangeCamera関数の引数にallfalseFlagを追加。
通常は=でfalseにしておく

<SceneMng.cs>
SceneLoad関数で
・CameraControllerにあるCameraMng.csの
　SetChangeCamera(true,true)と、
　DontDestroyCanvasにあるLocationCameraにアタッチ　しているLoading.csのNextScene関数を呼び出す処理を　書く

-------------------------------------------------

<ロードが2回走るバグ>-----------------------------

(原因)
タイトルからのロードで、
LoadGameをクリックして1回と
MenuActive.csのDataLoad関数を呼び出したときに
街に強制的にロードされる処理で1回

(解決方法)
[MenuActive.cs]
DataLoad関数の引数に(bool isWarp = true)
と書いておき、TownMng.csで呼び出しているほうに
falseとしておく

あとはisWarpがtrueのときは
// 強制的にゲームスタート先をTOWNにする
SceneMng.SceneLoad((int)SceneMng.SCENE.TOWN);
が発生するようにしておく

※AudioLisnerをfalseにしても遷移したらtrueになる
　バグも、これを直したら修正できた

[Loading.cs]に、
void OnEnable()
{
   gameObject.GetComponent<AudioListener>().
                                 enabled = false;
}
を書いておく

-------------------------------------------------

<ローディング中に、ユニちゃんが走るようにする>-----

「ユニティちゃん 2Dデータ」
をダウンロードしてくる。
(Vol.2は、ユニが意外と大きくてちょっと
　かわいくなかった)

2Dのためパッケージを開くには新規のプロジェクトで
開かないといけない。

このなかにあったUnityChan.pngをデスクトップに取り出して保存し、走るモーションだけに切り取る。
その後StreamingAssetsフォルダにいれる。

<ItemImageMng.cs>
IMAGE.LOADING_UNIを追加して、
spriteMap[IMAGE.LOADING_UNI] =
　　　　　　　　 ImageMng(1, 8, "/sprite_uni");
とする。

[TitleSceneへの追加]
・TitleMngにItemImageMng.csを追加する
・LoadingCanvas-Backgroundの子にImageをつける

[そもそものロード処理を大幅変更]
<Loading.cs>
用意した変数
private Image uniImage_;        // ユニの2D画像
private int uniAnimNum_ = 0;    // ユニの画像番号
private int nowTimeCnt_ = 0;    // 現在の時間
private int buildNum_;          // ビルド番号
private bool onceFlg_;		// シーン読み込み

OnEnable関数
・AudioListenerのenabledをfalse
・buildNum_ = -1;
・uniAnimNum_ = 0;

NextScene関数
・AudioListenerのenabledをtrue
・backGroundのSetActiveをtrue
・buildNum_ = buildNum;


Update関数
・backGroundのactiveSelfがfalseならreturnする
・uniImage_にfind処理
・LoadSceneAsync処理(onceFlg_をつかう)
・nowTimeCnt_を%20で割って0のときには
　uniAnimNum_を++する(画像上限のときは0に戻す)
　そしてuniImage_.spriteを更新
・nowTimeCnt++
・ロード状態がわかるバーのスライダーを増加

(結論)
いままでコルーチンでやっていた処理をupdate関数で
やるようにした。

(理由)
コルーチンやwhile文では、うまく画像の更新と
スライダーの増加ができなかったから。

[最終的な状態]
(さらに変更した点)
・外部アタッチでBackgroundとSliderを取得するのを
　やめた
　→Findするようにした
・OnEnable関数の使用をやめた
　→うまく機能していなかった
・ロードの終わりかけで数秒待つ処理を追加した
　→ロード時間の均一化
・Update関数でbackGroundがnullだったらfindするよう
　にした
・backGroundが非表示のときはAudioListenerのenable
  をfalseにするようにした
　→ここ以外でfalseにする処理ができるところがない

-------------------------------------------------

<newGame->conversationdataでエラー>--------------

(修正点)
[TextMng.cs]
textStateNum_変数を追加した。
→最初は0
  現在0のとき、会話終了で1
  現在1のとき、画面遷移で2
　こうすることで何度もシーン遷移を呼ばなくなる

またAudioListenerのenable処理が必要になるので
Main Cameraをfindして処理を足しておく

-------------------------------------------------

<newGame時にdata.csvとotherdata.csvが
 初期値で生成されるようにする>--------------------

[SceneLoadCSV.cs]
NewGameInit関数で、MenuActive.csのセーブと同じ
処理を書き、セーブデータを作成する。

-------------------------------------------------

<レストランの子の動きをどうにかする>--------------

腕を振り始めたら止まらないのを修正する。

(修正箇所)
・Restaurant.cs
・RestaurantMng.cs
・TokoのAnimator部分

[Restaurant.cs]
private Animator animator_;
private int key_Move =
               Animator.StringToHash("Move");
ChangeMotion関数を作成し、
if (animator_ == null)
{
    animator_ = GameObject.Find　　   ("HouseInterior/Restaurant/Toko").
    GetComponent<Animator>();
}
animator_.SetBool(key_Move,flag);

を記述しておく。

[RestanrantMng.cs]
コルーチンでモーションの変更をする。
Motion関数を作成し、一定時間の経過で
腕を振る/やめるを繰り返すようにした。

OnClickOrderButton関数の中に、
ienumerator_ = null;
ienumerator_ = Motion();
StartCoroutine(ienumerator_);
を追加する。

→料理を注文するボタンを押すまで、
　モーションの切替はスタートしない。

[TokoのAnimator]
Parametersのところに
boolで[Move]を追加する。
通常モーションと腕振るモーションに矢印を追加し、
Moveでtrue/falseをする。

-------------------------------------------------

<Chapter11の会話文修正>---------------------------

・敵の中には弱点属性をもつ敵がいることを知らせる
　今はまったくその説明がない
・炎のマテリアの作成後、クエスト達成会話で
　装備の仕方を教えるようにする

この2つに関する説明の会話を追加した。

-------------------------------------------------

<料理の数を増やす>--------------------------------

フィールドのボスを見て増加ステータスを決める事。
needFoodで複数の素材が必要な時の処理を追加する。
素材が必要なほうのneedMoneyは少なめにする。

まずはCookList.xlsに料理情報を追加する。
needFoodとneedNumが複数になるところは
「,」で区切る。
※素材番号と素材数がずれないように注意

[RestaurantMng.cs]
TextSetting関数を作成し、
複数の素材が必要な料理に対する処理をかく。

OnClickMenuOrderButton関数
こっちも複数の素材に対応しておく。

-------------------------------------------------

<敵とのレベル差で命中率を下げる処理をいれる>-------

ボスレベル - 適正レベル

15
15-5=10
10*[10]=100
191-100=91%

20
20-15=5
5*[10]=50
135-50=85%

25
25-20=5
5*[10]=50
208-50=自動命中

30
30-20=10
10*[10]=100
191-100=91%

40
40-30=10
10*[10]=100
186-100=86%

調べた感じだと、
「ボスレベル - ユニのレベル * 10(固定値)」
で出た値を命中率からマイナスする。

※雑魚戦闘でも使ってよさそう

[Chara.cs][CharaBase.cs]
Level関数をいれる

[EnemyInstanceMng.cs]
Hpdecrease関数の命中判定で、
var level =
enemyList_[num].
Item1.Level() - 
SceneMng.charasList_
[(int)SceneMng.CHARACTERNUM.UNI].Level();

if(level > 0)   // ユニの方が、敵より低いとき
{
   level *= 10;
}
とする。

-------------------------------------------------

<Field毎に出現する敵の数の上限を変更する>---------

[ButtleMng.cs]
instanceEnemyNum_変数を作成する。
現在のフィールド番号を受け取って、
敵のインスタンスをするときに
Random.Range(1, instanceEnemyNum_)
となるようにする。

注意点として、1からじゃないとmapのほうが対応しない
また、Rangeは未満で計算されるから5にしないと最大4体
を出現させられない

あと、Start関数で書くとシーンが移動しきれていなくて
数の上限があわなくなる。

-------------------------------------------------

<HPが0のとき、回復無効にする>---------------------

<回復魔法について>
[CharacterMng.cs]
SelectToHealMagicChara関数で回復処理に入る前に、
対象のdeathFlgを確認するようにした。
→エフェクトはでるけど、キャラは蘇生されなくした
※バステ回復と、バフ魔法についても同様の処理をした

<回復アイテムについて>
[UseItem.cs]
OnClickCharaButton関数で、GetDeathFlg関数を呼び出してfalseなら回復処理とかバフとかの処理に入り、
trueなら蘇生処理に入るようにした。

-------------------------------------------------

<次やる事>
・逃走成功/不成功をつくる

・セーブ内容に
　「時間」
　「一時パワーアップ中のデータ」
　「そのパワーアップがいつまでか」
　の保存をする


置き換えましたの連絡をする！！！！

 //@ ボスとのレベル差で命中率を下げる処理をいれる
同値だったときにどっちから攻撃がスタートするか