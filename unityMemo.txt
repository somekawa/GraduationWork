最初のブレークポイントが置けるようになるまで

①VisualStudioInstollerでUnityのツールが
　入っているか確認する

②Edit>Preferences>Generalの、
　Code Optimization On SetUpの項目が
　Debugになっているか確認する

③Edit>Preferences>External Toolsの、
　External Script EditorにVisualStudioのやつが
　設定されているか確認する

④VisualStudio側で、
　デバッグ>Unityデバッガーのアタッチを押して、
　出てくるかを確認して押下する

この4つでだいたいおわるはず

------------------------------------------------
<Animationの切替>
[Wait->Run]
isRunのフラグがtrueのとき、とする
[Run->Wait]
isRunのフラグがfalseのとき、とする

<お目目をぱちくりさせる方法>
Unityちゃんに、AutoBlinkforSD.csをアタッチする
引数の、Ref_faceという場所には「_face」を入れる

アニメーションで参考にしたサイト↓---------------

FaceUpdate.csの、「Invalid Layer Index」の警告についての対処法
https://thinkit.co.jp/story/2014/11/06/5372?page=0%2C1

コライダーの大きさと、キャラクターコントローラーを使った移動制御について
https://goodlucknetlife.com/unity-how-to-charactorcontroller/

特に、アニメーションの切替方法について
https://www.eda-inc.jp/unitychan/

------------------------------------------------

<五芒星のイラスト>
https://www.ac-illust.com/main/detail.php?id=1890670&word=%E4%BA%94%E8%8A%92%E6%98%9F%E9%AD%94%E6%B3%95%E9%99%A3#
※イラストACから拝借


<キャラの方向転換について>
参照したもの↓
https://www.hanachiru-blog.com/entry/2019/02/20/183552

transform.rotation = Quaternion.LookRotation(movedir);
と書くことで、ボタン押下時にmovedirに値が入るから
移動させたい方向というのが決められる

<他のモーションアセットを、unityちゃんにつける>
参照したもの↓
https://unity-shoshinsha.biz/archives/987

https://obenkyolab.com/?p=2112

AnimaterにしっかりStateを追加して設定すれば
動いてくれました。
※Has Exit Timeにチェックを付ける/付けないは
ちゃんと考えたほうがいい
(例)Wait->Attackについては、
Waitのアニメーションが終わってからAttackに移動するとボタン押下時に即座に反応してくれないと困るから、チェックは外して合ったほうがいい
逆に、Attack->Waitは、
Attackのアニメーションが最後まで再生されてから
Waitに戻ってほしいので、チェックがついていたほうがいい

<Unityちゃんに武器をもたせる>-------------------
参照したもの↓
https://unity-shoshinsha.biz/archives/987

武器アセットをいれて、上記のサイト通りに右手の子供として設定。そのあとにCharacter1_RightHandのTransform値を武器にコピペしたらいけそう
後はちょっとした座標調整と、サイズの変更

武器の    X      Y     Z
Position 0.06  -0.2   0.04
Rotation -10    0     180
Scale    0.5    0.5   0.5

-----------------------------------------------

<武器を振るモーションの後>----------------------
少しずつ座標がずれているから、ずれないようにしないといけない

参照したもの↓
https://indie-du.com/entry/2016/05/14/095612

UnityちゃんについてるAnimatorのApplyRootMotionのチェックをはずしたら座標がずれなくなった

ただそうすると、床をすり抜けて落下していくようになった。UnityちゃんにつけてるRigidBodyのUseGravityのチェックをはずしたら落下はしなくなったけど、根本的な解決にはなってなさそう。。。

<CharactorControllを使わないでキャラ操作>
参照したもの↓
https://gametukurikata.com/program/rigidbodyandcollider

CharactorControllをRemoveして、
RigidBodyとCapsuleColliderをつける。
値は上記のサイトをマネする。

一部違う所だけ抜粋↓
CapsuleColliderのCenterは、
(X)0,(Y)0.5,(Z)0にする
Radiusは0.5で、Heightは1にする

以上で、UseGravityを入れてもすり抜けないし、
コライダー同士で接触しておかしくなることもない。

-----------------------------------------------

<Apply Root Motionについての追加知識>-----------
参照したもの↓
https://light11.hatenadiary.com/entry/2019/04/18/003100

特定のMotionのみチェックを外した状態にする。
ということも可能らしい。

------------------------------------------------

<MainCameraをUnityちゃんに追従させる>-----------
参照したもの↓
https://xr-hub.com/archives/7057
なぜか、MainCameraをunityちゃんの子オブジェクトに
する方法は全部失敗した。
CameraSample.csの方法でやった
-----------------------------------------------

<MainCameraとButtleCameraを切り替える>----------
参照したもの↓
https://xr-hub.com/archives/6038
この記事の中では、MainとSubで切替の説明をしている

MainCameraの文字のMainとCameraの間に空白があるのを消したほうがバグを生まないですむ。

CameraControllerという空のオブジェクトを用意しておいて、そこに新規Scriptで[CameraMng]をつくって
アタッチするようにしたらいい。
[CameraMng]の内容は上記のURLに記載されている。

制作するゲームはランダムな値でエンカウントして、
エンカウントしたらカメラを切り替わるようにしたい
------------------------------------------------

<MainCameraにはUnityちゃんの武器を映さない>------
まず、新規で[Weapon]というLayerを追加する。
次にUnityちゃんの右手の子供にした[Staff]のLayerに
[Weapon]を設定する。

MainCameraのインスペクター内にCameraがあって
そこにCullingMaskがある。
最初の設定では[Everything]になって全てのレイヤーを映すようにしているが、ここから[Weapon]を除外。
その結果、MainCamera上には映らなくなる。

ButtleCameraは[Everything]のままなので武器も映る

※ついでに書いとくと、unityちゃんは、武器以外
　[Player]というLayerを新規で用意して付けている
------------------------------------------------

<Unityちゃんの通常モードと戦闘モードを分ける>----
新規でButtleUnitychanControllerを作成し、
ButtleCameraがONのときのみUpdate処理を続行し、
SPACEキーを押下すると杖を振るモーションを行う。

ButtleUnitychanControllerはUnityちゃんにアタッチした。

ついでに、バトルカメラもunityちゃんに追従するようにButtleCameraにもCameraSample.csをアタッチした

他キャラと一緒に戦う仕組みならunityちゃん専用の攻撃Scriptではなく、ちゃんと親をつくって、
ポリモーフィズムにしたほうがいい。
汎用性を高めること！

(例)攻撃ボタンを押す(親クラス)→敵選択(親クラス)→攻撃モーションとダメージ計算をする(子クラス)

いまのうちからキャラを複製して検証したほうがいい
------------------------------------------------

<ButtleMngで全てのキャラのアクションを操作する>--
キャラ1体1体にButtleUnitychanControllerをつけるのは馬鹿だな。と思ったので、修正。

ヒエラルキーに空のオブジェクトをつくって、
ButtleMngと命名。同じくScriptを新規作成して、
そちらにもButtleMng.csと命名。新規Scriptを空のオブジェクトにアタッチする。

使用するにあたって、CharListにキャラオブジェクトを登録する必要がある。Script内にキャラ名のenumが
あるため、それと同じ順番でキャラオブジェクトをアタッチしないといけない。

それを利用してcharMap_を作成。
charMapは、キーをenum,値をキャラオブジェクトにしている。
foreachで回して、構造体に登録していく方針にした。

構造体を使うことで、キャラ1体1体の情報を差別化できる。

攻撃モーションの途中で、次のキャラの操作に移行してしまい。モーションが途切れるバグがあったため、

構造体にisMoveとanimTimeを追加して、モーションに
間をつくるようにした。
ただし、Scriptにも記載しているが、キャラによってモーションの間を調整する必要があるかもしれない。
その場合は、maxAnimTime等を外部データからもってこれるようにしたほうが効果的だと思う。

以上の実装方法により、キャラクター毎にコントローラースクリプトを用意する必要がなくなった。

------------------------------------------------



これより下は、0831パッケージに入っていない所。

<バトルUIの回転するUIの作り方>------------------
参照したもの↓
https://scrapbox.io/remi-tech/Unity%E3%81%A7%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%9F%E8%A7%92%E5%BA%A6%E3%81%BE%E3%81%A7%E5%9B%9E%E3%81%97%E3%81%A6%E6%AD%A2%E3%82%81%E3%82%8B%E6%96%B9%E6%B3%95

まず、ButtleCanvasをヒエラルキーに作成して、
中にImageを追加する。UIにしたい画像のTexture Type
をSprite(2D and UI)にしてから、Imageにアタッチ

Imageには新規ScriptでImageRotate.csを作成して、
アタッチする。
このスクリプト内で回転処理を行っていく。

回転処理については上記の参照サイトと全く同じ。

①キー入力によって回転させたい角度を決める
②①をクォータニオンに直す
③画像の現在のクォータニオンを調べる
④Quaternion.Angleという関数を使い、②と③の角度
　の差を求める
⑤④の差が一定値以下なら回転終了し、
　規定値を満たしていなかったら回転を続行する。

まだActiveの切替とかしてないからバトル中以外でも
出てきちゃうけど、明日からまた修正頑張ろう。

FieldMngをつくって、戦闘と通常を切り替えられるようにします。
CameraMngでAキー操作でカメラ切替にしているところ
から修正。
enumつくって参照できるようにしてあげる。

毎回戦闘モードの最初が同じコマンドを上に出すようにしないといけないから、ImageRotateにResetRotateという関数を追加。呼び出し先は、ButtleMngです。
関数の中で、0,0,0の初期値に戻るようにした。
また、そのさいにはちゃんとtargetRotate_も0.0fに
初期化しないと、バグが発生する。

-----------------------------------------------

<FieldMngでMODEの管理をする>--------------------
MODEというのは、探索モード/戦闘モード/メニュー
とかの、フィールド上で遷移するもの。

今は、時間経過で戦闘モードになるようにしてテスト
している。

空のオブジェクトを作成して、FieldMngと命名。
それに新規Scriptをアタッチして、その名前も
FieldMng.csにした。

FieldMng.cs内ではさっき書いた通り、時間経過で遷移するようにswitch文を書いている。

MODEが切り替わる事でCameraMng内のカメラ切替や、
ButtleMng内の攻撃モーション操作ができるようにならないといけないから、static変数でnowModeをつくり、
どのクラスからでもFieldMng.nowModeで現在の状態を
見れるようにした。

また、ButtleUICanvasについては、ButtleMngで
表示/非表示を管理するために、ButtleMng.csにpublic変数を追加して、アタッチできる場所を用意した。
missingに注意すること！！

これからも「複数クラスからの参照」があり、
「唯一の変数」で良いならstaticにしたほうがいい。
情報も持ち越せるだろうしね。

------------------------------------------------

<MODEがButtleなら、UnitychanControllerをoffに>--

UnitychanController.csに、MODEがSEARCHなら動く
ようにしたらいいね。それ以外ならreturnさせれば早い。

MODEが切り替わる時に走っていると、走りモーション
が終わらなくなる為、returnの前に、is_Runをfaseに
する処理を入れておく。

また、戦闘モードで行動する順を毎回守る為に、
returnの前に、nowTurnChar_ = CharcterNum.UNI;
を入れる。

町の中でもSEARCHにしておけばいいかな？

------------------------------------------------

<戦闘用ワープポイント>--------------------------
実際のゲームフィールドでは、ひらけた空間を1ヶ所は
用意しておき、そこに戦闘では一時的にワープさせる
→ゲームフィールド毎に、戦闘用ポイントを設置する

あとはモードが切り替わったときにキャラの向きと位置の所定位置をきめとく。

ButtleMngでキャラを取得してるから、場所と向きを
予め設定できる何かを用意しておく。

<テストでポイントを作ってみる>
以下、バトルワープポイントのことをBWPと記載する。

キャラが2体なので、2つ設置する必要がある。
まず、BWPをまとめる空のオブジェクトを作成して、
ButtleWarpPointPackと命名。(座標0,0,0にする)
その後、それの子供に2つCubeで、BWP0,BWP1を作成。
(必要がない、BoxColliderをremoveしておく。)

ButtleMng.csにバトルワープポイントの取得を書く。
そのために、public変数で、BWPPackをアタッチできる所をつくる。
マップ毎にSceneを分けるのであれば、この方法で問題ない…はず。

BWPPackの子の座標をStart関数内で別の変数に保存する。
戦闘モードに切り替わるときに、その座標をキャラに入れてあげたらよい。
キャラの向きは、実際のマップをつくってみないとわからないが、全て進行方向を、統一する必要がある。

メモリーリークを防ぐ書き方の参考↓
https://madnesslabo.net/utage/?page_id=11109#i-17

基本的に、Sceneを丸ごと削除したらメモリーリークの
発生は起きにくい。(削除＝アンロード)
ただ、Sceneを跨いでも残る情報(シングルトンとかMng系の何か)とかがあると、
参照次第ではメモリーリークになるかもしれないからDestroyのあとにnullを代入する注意が必要。

------------------------------------------------

<戦闘用ワープポイントでのキャラの向き>-----------

戦闘用UIの回転方法と類似している。はず。
①buttleWarpPointsRotate_という配列変数を用意する
②buttleWarpPointsPos_と同じタイミングでStart関数でワープポイントの回転角をクォータニオンで取得
③戦闘モードになったとき、キャラクターの回転角に
②のクォータニオンを代入するだけ。

BWPの箱を回転させれば、その向きにキャラも変更できるはず。できました。
------------------------------------------------

<敵とのエンカウントまでの色変化の作り方>---------
テストとして、普通の3DオブジェクトにEncountColorという新規Scriptで作成したものをアタッチして行った。

参照したもの↓
https://teratail.com/questions/302182

今回は、255とかのbyte単位で変化させるのを使用した

色合いの変化を
青→青緑→緑→黄色→オレンジ→赤
と変化させた。

まず、青の値を減算して緑の値を加算する
加算：green * (time_ / toButtleTime_)
減算：255 - (blue * (time_ / toButtleTime_))

time_ / toButtleTime_は、
(現在値 / エンカウント発生時間)なので
0～1の値にできる。
これに255を乗算するとその時間に適した値を出せる。
減算したい時はさらに先頭に255 - をつけると良い。

time_ / toButtleTime_が0.5fを超えたら
redStartFlg_をtrueにして、赤の加算を始める。
このとき、青の減算を早めて、緑も減算を行う。

これで、色の変化は完成した。

次に、time_ / toButtleTime_の計算をFieldMng.cs
で行い、EncountColor.csに引っ張ってくる方法を考える。

------------------------------------------------

<EncountColor.csがFieldMng.csの値を参照する>----

EncountColor.csで変数追加して、
(private FieldMng fieldMng_;)

Start関数で名前検索をかけて、中のコンポーネントの
FieldMngを取得する。

fieldMng_ =　GameObject.Find("FieldMng").
　　　　　　  GetComponent<FieldMng>();

あとは、Update関数で毎回取得して、
float time = fieldMng_.GetNowEncountTime();

いままで、(time_ / toButtleTime_)と書いて計算式を書いていたところをtimeに変更する。

最後に、戦闘が終了したら、また青からスタートするように戻す方法を考えないととと・・・

nowModeがMODE.BUTTLEなら計算をせずreturnにして
値を初期化する。

------------------------------------------------

<[Field]をバトルカメラから除外する>-

新規でレイヤーを作成[Field]
MainCameraのCullingMaskでは、[Field]に
チェックをつける。

ButtleCameraのCullingMaskでは、[Field]に
チェックをつけない。

他にも映したくないものが増えてきたら[Field]に
レイヤーを設定すればいい

------------------------------------------------

<FieldUICanvasを作成して、画像の色を変更させる>--

素材を入手したときのアナウンスとかも入れられるように、新規にヒエラルキーにFieldUICanvasを作った。

レイヤーはFieldに設定し、さっきまで色変化のテストにつかっていたものを修正していく。

①FieldUICanvas内にImageを作成。
　テストでつくったwhite.pngを入れる。
　Colorをクリックすると、色相環がでてくるが、
　色相環の右下に[RGB0-255]とか書いてるやつがある　これを[RGB0-1.0]に変更しておく。

②EncountColor.csではマテリアルだったところを
  Imageにしたり変更を行う
　特に注意する点は、①で0～1.0にしたため、

image_.color = 
new Color(r/255.0f , g/255.0f , b/255.0f, 1.0f);

こんなかんじで、255.0fで割る必要がある。

------------------------------------------------

<UI要素はCulling Maskできないと書かれてて>-------

FieldUICanvasを追加したものの、なぜかレイヤー分けしてもバトルカメラにエンカウント目安UIでてきたので
調べたところ。
Culling Maskができないとか書かれてた。

よって、FieldUICanvasを非表示にする方法を考えることになった。

他の普通のオブジェクトは[Field]でカメラ分けできると思うから、レイヤー自体は残しておきます。

ButtleMng.csのUpdate関数の最初のif文に、
戦闘モードじゃなかったらbuttleUICanvasをfalseに
するってところがあるから、このタイミングで
FieldUICanvasはtrueになっている必要がある。

よって、ButtleMngのpublic変数を増やして、
FieldUICanvasをアタッチできるようにしたら早い。

FieldUICanvasをfalseに戻すほうもちゃんと書いとく

これで、戦闘モード中はカメラに映らないように修正ができた。
-----------------------------------------------

<EncountColor.csの改良>------------------------
同じような計算を複数回行っているため、別関数に
計算内容をまとめて、フラグや値で処理を分けて、
計算結果を関数の返り値にするようにした。
(ColorValueCalculation関数のことです)
-----------------------------------------------

<キャラが歩いているときだけエンカウント時間加算>-
今は止まっているときでも時間が加算されているので
FieldMng.csを修正して、歩いているときだけ。に
変更していく。

[歩いている＝座標移動している]だから、
UnitychanController.csでフラグを立てて、
FieldMngで参照できるようにしたらいいかな？？

UnitychanControllerもマネージャー的なオブジェクトに近いから、今回はfindで検索しよう。

FieldMng.csにprivate変数でplayer_を追加して
findで名前検索。
Update関数でplayer_.GetMoveFlag()を呼び出す。

GetMoveFlag()というのは、UnitychanController.cs
で新規に作成した関数で、GetBoolの状態を取得する。

------------------------------------------------

<Findとプロトタイプ宣言からのインスペクター指定>-

別のオブジェクトについているスクリプトを見たい時
①find検索
②findTag検索
③public Gameobjectとしてプロトタイプ宣言して、　Inspectorから指定する

がある。

それぞれのメリットとデメリット↓
https://marunouchi-tech.i-studio.co.jp/2266/

まとめ部分だけ載せておくと、
a.マネージャー的なオブジェクトはStartの時にFind
b.表示非表示を繰り返すようなものはInspector上から　指定して使う
c.Insulatorから指定するのは便利だが、大量のオブジ　ェクトを確保しようとするとプロトタイプ宣言の箇　所がとても多くなる。
　そこは親オブジェクトだけInspector上から取得し、　子オブジェクト等は親オブジェクトから取得する。

つまり、表示非表示管理をしないものは基本findを
start関数で行うといいのかもしれない

------------------------------------------------

<コマンドの回転に区別をつける>-------------------
まずは、攻撃コマンドとそれ以外にわけてみる。

回転してたらわからなくなったからメモ
右回転と左回転を比べる。

右　　 左
0  と +-360は一緒 
90 と -270 は一緒
180と -180 は一緒
270と -90  は一緒

左　+　360 = 右!!!

マイナス値なら+360で計算したらうまくいった

Quaternion.Angleを使っているif文内に処理を
追加しました。

------------------------------------------------

<ButtleMng.csにコマンド情報を渡す>--------------
すでにこれまでの実装の経緯で、ButtleMng.csの引数にButtleUICanvasがいて、buttleCommandUI_という
変数にImageRotate.csの情報がある。

アタックモーションになっているときに、
if(buttleCommandUI_.GetNowCommand() == 　　ImageRotate.COMMAND.ATTACK)

というのでif文を追加したらうまく選択ができていた

GetNowCommandという関数はImageRotate.csに新規で
追加しました。

他のスクリプトでpublicのenumと==の判定をしたいときは、今回みたいなif文の書き方をしたらいいみたい

-----------------------------------------------

<unityちゃんの通常攻撃>-------------------------

KY_effectsというアセットのエフェクトで作成する。

参照したもの↓
https://gametukurikata.com/program/shockwave

KY_effects > MagicEffectsPackFree > prefab
の中の、ErekiBall2を複製して「UniAttack」と命名。
(オリジナルは念のためとっとくようにする)

①一度、ヒエラルキーにおいてアンパッケージ化する

②UniAttackの親オブジェクトにSphereColliderを
　つける。IsTriggerにチェックをつける
　RigidBodyを追加し、UseGravityのチェックを外す

③ButtleMng.csにAttackStart()という上記のサイト　の関数を追加して、②をアタッチできるようにする

④新規Scriptで、「MagicMove.cs」を作成
　内容は、上記のサイトのShockwaveMoveスクリプトを
　持ってくる。一部判定でいらない部分があるので
　削除もおこなう

⑤UniAttackに、MagicMove.csをアタッチ

⑥再びPrefab化する

⑦ButtleMngというオブジェクトについている　　ButtleMng.csにProjectファイルのprefabから直接　ドラッグ&ドロップする
　(ヒエラルキーに置いてたUniAttackは消してよし)

UniAttackが自然消滅しないから、Start関数に、
Destroy(this.gameObject,5);
みたいに指定した時間が過ぎたら消えるようにしとく

でもたぶん最終的には敵に当たったら消えるからいらないとは思う。


<発動させたキャラの位置から弾がでるようにする>
よくよく考えたら、ちゃんと座標指定ができてなかった。

ButtleMng.csのAttackStart()という関数で弾の発生位置を調整してインスタンスしているから、キャラの戦闘開始時の座標を保存して、それを使用する必要がある。

a.戦闘開始時のそれぞれのキャラ座標を保存する
①CharcterSettingの構造体に、buttlePosという変数　を追加する

②Update関数内で、setCallOnce_がfalseの時に
　foreach文で戦闘用座標と回転角度を代入している所　がある為、そこに
charSetting[(int)character.Key].buttlePos = character.Value.gameObject.transform.position;
　と追加する。
　おそらく、非戦闘時にメニュー画面でキャラの立　　ち位置を交換とかしても、戦闘開始時に必ずここの　処理が呼ばれるので、エフェクト発生位置の目安に　できる。

b.AttackStart関数でエフェクトの座標を調整する
　今行動ターンが来ているキャラだとわかるように      AttackStart((int)nowTurnChar_);という風に
　引数を持たせる。
　
　あとは、関数内で
　var adjustPos = 
　new Vector3(charSetting[charNum].buttlePos.x, 　　　　charSetting[charNum].buttlePos.y + 0.5f, 　　　　charSetting[charNum].buttlePos.z);
　とすれば完成ですね。

-----------------------------------------------

<通常攻撃が敵に当たるか確認する>----------------

まずはテストの敵を用意する。
①Cubeを出して配置
→BoxColliderのIsTriggerはチェックなしでok
→Rigidbodyの追加をし、UseGravityはチェックなし
②新規Tag  →Enemy
③MagicMove.csに判定があるので、敵に当たると
　弾と敵が消えるのを確認する
------------------------------------------------

<攻撃弾連打できちゃうバグ>----------------------
Spaceキーを押下したら～のif文の中で、
isMoveをtrueにしている箇所がある。
そこを、

if(!charSetting[(int)nowTurnChar_].isMove)
{
   AttackStart((int)nowTurnChar_);
   charSetting[(int)nowTurnChar_].isMove = true;
}

とすることで、連打しても1キャラにつき1攻撃エフェクトしか発生させないようにできる。

------------------------------------------------

敵をbox(豆腐くん)でつくって当たり判定のかくにん
当たったら色が赤になるーとかそんな感じでやろ。
最終的に、キャラのターンが変わるのは、敵に攻撃が当たって相手のダメージMotionが終了したら。みたいな判定になりそう。それなら構造体のisMoveとかanimTimeで作ったモーションに間をつくるってのがいらないかも。。。苦労したのに＞＜;

なにもしないでも敵に遭遇できるアイテムがあったら便利そう。

企画書のパワポを共有で用意するぐらいしとこ。



